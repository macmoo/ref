<!DOCTYPE html>

<head>
    <title></title>
    <!-- START -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- <link rel="stylesheet" type="text/css" href="../../etc/androidstudio.css"> -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/monokai-sublime.min.css">
    <link rel="stylesheet" type="text/css" href="../../etc/custom.css">
    <script type="text/javascript" src="../../etc/highlight.min.js"></script>
    <script type="text/javascript" src="../../etc/highlightjs-line-numbers.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>hljs.initLineNumbersOnLoad();</script>
    <!-- E N D -->
</head>

<body>
<!-- ############################################# -->
<pre><code class="javascript">// const로 정수를
// let로   변수를 취급
let   myName1 = "이름1";
const myName2 = "이름2";

// myName2 = "이름3"; // 에러

alert(myName1);
alert(myName2);
// ----------------------------
let currentDate = new Date();
let myFunc = () => console.log('함수다');

alert(currentDate);
myFunc();

let myVar;    // 초기값 미설정
alert(myVar); // undefined
// ----------------------------
// const
// 초기값의 생략이 불가능
// 값의 재설정이 불가능으로, 값의 변경이 불가능한 것은 아님
// 배열이나 오브젝트의 변경을 막으려면 Object#freeze()를 이용
const myArr = ['문','홍','안'];
console.log(myArr); // Array(3) [ "문", "홍", "안" ]

myArr[0] = '이';
console.log(myArr); // Array(3) [ "이", "홍", "안" ]

const myObj = {id:20, name:'한국'};
console.log(myObj); // Object { id: 20, name: "한국" }

myObj.name = '캐나다';
console.log(myObj); // Object { id: 20, name: "캐나다" }
// ----------------------------
// == 와 === 의 차이
// ==  : 형이 달라도 같은 것으로 판단
// === : 형이 다르면 다른 것으로 판단
// != , !== 도 같다
console.log(10 ==  '10'); // true
console.log(10 === '10'); // false</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 애로우함수 (=>)
// (인수) => { 처리내용 }
// 장점
// 1. 함수를 간결하게 작성가능
// 2. this를 속박가능
// ----------------------------
// 함수의 정의
const calcSum = (a,b,c) => {
    const result = a + b + c;
    return result;
};
console.log(calcSum(10,20,30)); // 60
// ----------------------------
// 인수가 1개일 경우, ()생략가능
// 인수가 0개이거나 2개 이상일 경우, ()생략불가
// ----------------------------
const myFunc1 = (a) => {
    return a + 2;
};
const myFunc2 = a => {
    return a + 3;    
};
console.log(myFunc1(10)); // 12
console.log(myFunc2(10)); // 13
// 애로우함수내의 처리가 1행일 경우,
// {}와 return을 생략가능
const myFunc3 = (a) => a + 4;
console.log(myFunc3(10)); // 14</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 함수의 인수에 초기값 설정
// 1. function myFunc(인수1, 인수2=초기값2, 인수3=초기값3){}
// 2. (인수1, 인수2=초기값2, 인수3=초기값3) => {}
// 초기값이 설정된 인수를 생략가능
// ----------------------------
function myFunc1(price, tax = 0.08){
    const result = price + price * tax;
    return result;
}
console.log(myFunc1(100));       // 108
console.log(myFunc1(100, 0.02)); // 102
// ----------------------------
// 함수에 임의의 개수의 인수를 건넴
// "...인수" 残余引数（rest parameters）
// 건네진 인수는 배열로 저장됨
// 1. function 함수명(...인수){}
// 2. (...인수) => {}
// 3. 인수[인덱스]
// ----------------------------
function calcSum(...prices){
    console.log(prices[0]); // 10, 5
    let result = 0;
    for(const value of prices)
        result += value;
    return result;
}
console.log(calcSum(10,20));    // 30
console.log(calcSum(5,10,20));  // 35</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// iphone인지 확인
const isIOS = navigator.userAgent.includes('iPhone');
console.log(isIOS); // false or true
// ----------------------------
// 문자열에 'vas'가 포함되는지 아닌지 확인
const flg = 'Javascript'.includes('vas');
console.log(flg);   // true</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 수치
// NaN : 수치이 아님.  부정한 계산결과
// ----------------------------
// 1.7976931348623157e+308
console.log(Number.MAX_VALUE);
// 5e-324
console.log(Number.MIN_VALUE);
// 9007199254740991
console.log(Number.MAX_SAFE_INTEGER);
// -9007199254740991
console.log(Number.MIN_SAFE_INTEGER);
// Infinity  (양의 무한의 값)
console.log(Number.POSITIVE_INFINITY);
// -Infinity (음의 무한의 값)
console.log(Number.NEGATIVE_INFINITY);</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 장방향 그라데이션
const rectangle = document.querySelector('.rectangle');

// 버튼이벤트
document.querySelector('.button').addEventListener('click', onClickButton);

function onClickButton(){
    // 0~359랜덤숫자 생성
    const randomHue        = Math.trunc(Math.random() * 360);

    // 그라데이션 시작, 종료 색 설정
    const randomColorStart = `hsl(${randomHue     }, 100%, 50%)`;
    const randomColorEnd   = `hsl(${randomHue + 40}, 100%, 50%)`;

    // 장방형의 그라데이션용 변수(--start, --end)을 변경
    rectangle.style.setProperty('--start', randomColorStart);
    rectangle.style.setProperty('--end'  , randomColorEnd);
}
// ----------------------------
// css
.rectangle {
    width :300px;
    height:300px;
    /* height:calc(100% - 50px); */
    --start: hsl(0  , 100%, 50%);
    --end  : hsl(322, 100%, 50%);
    background-image: linear-gradient(-135deg, var(--start), VAR(--end));
}</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 안전한 난수
// crypto.getRandomValues(형붙인 배열); // 리턴:난수배열
// ----------------------------
//랜덤정수(부호없는16비트)가 10개들어간 배열을 생성
const randomArr = crypto.getRandomValues(new Uint16Array(10));
console.log(randomArr);
// Uint16Array(10) [ 30106, 64439, 30547, 1975, 9450, 62468, 27533, 27756, 63786, 36283 ]
// 배열을 이어 난수를 생성
const random16 = randomArr.join('');
console.log(random16);
// 301066443930547197594506246827533277566378636283
// ----------------------------
// 부호없는 32비트 난수생성
const random32 = crypto.getRandomValues(new Uint32Array(10)).join('');
console.log(random32);
// 382979343515709866573468246670218395933328989172757469039542220903590269873746935950855881383786406
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 수학 계산
// ----------------------------
Math.abs(수치);  // 절대값
Math.pow(수치A, 수치B);  // 수치A의 수치B승
Math.sign(수치); // 수치부호를 계산
Math.sqrt(수치); // 평방근(루트2)
Math.log(수치);  // 자연대수를 계산
Math.exp(수치);  // 지수함수를 계산
Math.E           // 자연대수의 밑
Math.PI          // 원주율
Math.cos(수치);  // 코사인
Math.sin(수치);  // 사이
Math.tan(수치);  // 탄젠트
Math.acos(수치); // 아크코사인
Math.asin(수치); // 아크사인
Math.atan(수치); // 아크탄젠트
Math.atan2(y좌표, x좌표); // (x,y)의 좌표의 각도</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 문자열
// ----------------------------
// 길이
console.log("string".length); // 6
console.log(Array.from('string2').length); // 7
// ----------------------------
// 문자열양끝 공백, 탭, 개행 제거
console.log(" str ing ".trim()); // "str ing"
// ----------------------------
// 문자열 검색(검색결과없으면 -1을 반환)
// 대소문자 구분함, 인덱스를 반환
// - 대상문자열.indexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.lastIndexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.search(정규표현)
const str = 'Javascript를 배우자.';
const s1 = str.search(/Javascript/);
const s2 = str.search(/HTML/);
console.log(s1); // 0 : hit
console.log(s2); // -1 : no hit
// ----------------------------
// 문자열이 포함되어 있는가. (참/거짓을 리턴)
// - 대상문자열.includes(검색할 문자열, [검색개시 인덱스])
// 문자열로 시작하는가, 끝나는가
// - 대상문자열.startsWith(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.endsWith(검색할 문자열, [검색개시 인덱스])
const a1 = str.includes("script");
const a2 = str.startsWith("javascript");
const a3 = str.endsWith("배우자.");
console.log(a1); // true
console.log(a2); // false
console.log(a3); // true
// ----------------------------
// 문자추출
// 문자열.charAt(인덱스)
console.log("string".charAt(3)); // i
console.log("string".charAt());  // s
// 문자열.slice(시작인덱스, [종료인덱스])
// 문자열.substring(시작인덱스, [종료인덱스])
// 종료인덱스를 생략하면 문자열끝까지
// slice()음수지정가능(뒤에서부터 추출)
// slice()와 substring()은 시작idx가 종료idx보다 
// 클경우의 처리가 다름. (시작idx, 종료idx를 바꿔서 처리)
const str2 = "kwak no1";
console.log(str2.slice(2,4));       // ak
console.log(str2.substring(2,4));   // ak
console.log(str2.slice(0));         // kwak no1
console.log(str2.substring(0));     // kwak no1
console.log(str2.slice(1, -1));     // wak no
console.log(str2.substring(1, -1)); // k
console.log(str2.slice(3, 1));      // <empty string>
console.log(str2.substring(3, 1));  // wa
// ----------------------------
// 문자열.substr(시작인덱스, [취득문자수])
// @deprecated
console.log(str2.substr(1, 3));  // wak
// ----------------------------
// 문자열치환
// 문자열1/정규펴현을 문자열2로 바꿈
// 대상문자열.replace(문자열1, 문자열2)
// 대상문자열.replace(정규표현, 문자열2)
const phone = '111-2222-3333';
console.log(phone.replace(/-/g, '')); // 11122223333
// ----------------------------
// * 버튼의 디폴트 이벤트 무효화
// document.querySelector('#submitBtn')
//        .addEventListener('click'
//        , (event)=>{ event.defaultPrevented(); });
// ----------------------------
// 문자열분할
// 문자열.split([구분문자], [분할수])
// 문자열.split([정규표현], [분할수])
// 빈문자로 분할하면 한글자씩 들어간 배열이 리턴
// 인수를 생략하면 하나의 전체문자열이 들어간 배열 리턴
// ----------------------------
// 문자열결합
// 문자열1+문자열2+문자열3
// `${문자열1}${문자열2}${문자열3}`
// ----------------------------
// 문자열변환
// 대 - 소문자
// 문자열.toLowerCase()
// 문자열.toUpperCase()
// ----------------------------
// 정규표현
// "/패턴/"형식으로 사용
// -----------
// 패턴     의미
// x        x라는 1문자    
// xyx      xyz라는 문자열
// [xyz]    xyz중 1문자
// [a-z]    a~z중 1문자
// [^xyz]   xyz이외의 1문자
// [^a-z]   a~z이외의 1문자
// abc|xyz  abc 또는 xyz라는 문자열
// {숫자}   반복횟수
// ^x       첫문자가 x
// x$       마지막 문자가 x
// .        개행문자를 제외한 1문자
// x*       x가 0개 이상 반복
// \        다음문자를 이스케이프함
// \d       숫자     => [0~9]
// \D       숫자이외 => [^0~9]
// \w       영문자, 언더스코어 => [A-Za-z0-9_]
// \s       스페이스, 탭, 개행문자등의 공백문자
// \S       공백이외의 문자 => [^\s]
// \t       수평탭
// \n       개행문자
// -----------
// 조건에 매치하는 문자열 검색
// /패턴/.test(문자열)
console.log(/J/.test('Javasscript'));     // true
console.log(/^iP/.test('iPhone'));        // true
console.log(/iP$/.test('iPhone'));        // false
// 숫자포함
console.log(/\d/.test('iPh4one'));        // true
// a가 0회 이상 반복
console.log(/java.*/.test('javascript'));  // true
console.log(/java.*/.test('javasscript')); // true
console.log(/\d+-\d+-\d+/.test('090-1234-5678'));    // true
// 0에서 시작해서 10혹은 11자의 숫자인가 확인
console.log(/^[0][0-9]{9,10}$/.test('01234567890')); // true
// ----------------------------
// 소수점 표현
// 수치.toFixed([문자수]); // 소수점이하를 지정한 문자수로 한다.
// 수치.toPrecision([문자수]); // 지정문자수를 精度로 한다.
console.log((0.3333).toFixed(2)); // 0.33
console.log((0.3353).toFixed(2)); // 0.34
console.log((123.456).toFixed(3)); // 123.456
// ------------
console.log((0.3333).toPrecision(2)); // 0.33
console.log((0.3353).toPrecision(2)); // 0.34
console.log((123.456).toPrecision(3)); // 123
// 精度4에 의해 0이 매꿔짐
console.log((10).toPrecision(4)); // 10.00
// ----------------------------
const sndElem  = document.querySelector('.second');
// 3초후가 골
const goalTime = new Date().getTime() + 3 * 1000;
update();
function update(){
    // 현재시작
    const currentTime = new Date().getTime();
    // 남은시간
    const leftTime = goalTime - currentTime;
    if(leftTime < 0) return;
    // 초를 표시.소수점(미리초는 2자만)
    sndElem.innerText = (leftTime/1000).toFixed(2);
    // ★ 다음 프레임에서 다시 update를 실행
    requestAnimationFrame(update);
}
// ----------------------------
// 문자열 반복
// 문자열.padStart(반복할 길이, [추가할 문자열])
// 문자열.padEnd(반복할 길이, [추가할 문자열])
console.log('5'.padStart(2, '0'));  //  05
console.log('ff'.padEnd(6, '0'));   //  ff0000
console.log('ff'.padEnd(6));        // "ff    "
console.log('123'.padStart(3,'0')); // 123
function zeroPadding(num){
    return String(num).padStart(2, '0');
}
// ----------------------------
// 문자열을 URI인코드
// encodeURIComponent()는 다음 문자도 이스케이프함
// / ? & = + : @ $ ; , #
var uri1 = encodeURI('http://www.한글.com/주소.html');
console.log(uri1);
// http://www.%ED%95%9C%EA%B8%80.com/%EC%A3%BC%EC%86%8C.html
var uri2 = encodeURIComponent('http://www.한글.com/주소.html');
console.log(uri2);
// http%3A%2F%2Fwww.%ED%95%9C%EA%B8%80.com%2F%EC%A3%BC%EC%86%8C.html
// 디코드
console.log(decodeURI(uri1));
// http://www.한글.com/주소.html
console.log(decodeURIComponent(uri2));
// http://www.한글.com/주소.html
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 배열
// ----------------------------
// [] : 배열을 정의
const arr1 = [];               // 빈배열
const arr2 = [1,2,3];          // 배열 초기화
const arr3 = new Array(4,5,6); // 배열초기화
// 인수가 1개의 수치일 경우에는 지정개수의 배열이 작성됨
const arr4 = new Array(10);    // 10개의 수를 넣을수 있는 배열
// ----------------------------
console.log(arr3.length); // 3
// ----------------------------
// 배열의 각요소에 대해 처리 (1)
// 베열.forEach(콜백함수)
// 인수로 건넨 콜백함수를 써서 요소를 순서대로 처리
// 콜백함수 (* : 생략가능)
// ([요소*], [인덱스*], [元배열*]) => {} 
const arr5 = ['딸기','귤','사과'];
arr5.forEach((value, index) => {
    console.log(index, value);
});
// 0 딸기
// 1 귤
// 2 사과
// -----------
[1,2,3,4,5,6,7]
    .filter( (value) => value % 2 === 0)
    .forEach((value) => {
        console.log(value); // 2 4 6
    });  
// ----------------------------
// 배열의 각요소에 대해 처리 (2)
// for(const 요소 of 배열) {}
for(const val of arr5){
    console.log(val); // 딸기 , 귤 , 사과
}
// ----------------------------
// 배열의 각요소에 대해 처리 (3)
for(let i = 0; i < arr5.length; i++){
    console.log(arr5[i]); // 딸기 , 귤 , 사과
}
// ----------------------------
// 배열에 요소 추가
// 배열.unshift(요소1, 요소2) : 선두에 요소추가
// 배열.push(요소1, 요소2)    : 말미에 요소추가
// ----------------------------
// 배열.shift() : 선두의 요소를 제거
// 배열.pop()   : 마지막 요소를 제거
const arr7 = ['딸기','귤','사과'];
const itemShift = arr7.shift();
console.log(itemShift);      // 딸기
console.log(arr7);           // 귤, 사과
// ------------
const itemPop = arr7.pop();
console.log(itemPop);        // 사과
console.log(arr7);           // 귤
// ----------------------------
// 배열의 요소 일부는 치환
// 배열.splice(추가위치, 추출할 개수, 요소1, 요소2)
const arr8 = ['사과','귤'];
const arr9 = ['사과','귤'];
// ------------
arr8.splice(1, 0, '바나나');        // 1의 위치에 0개를 지우고 바나나를 추가
arr9.splice(1, 1, '바나나','딸기'); // 1의 위치에 1개를 지우고 추가
// ------------
console.log(arr8); // [ "사과", "바나나", "귤" ]
console.log(arr9); // [ "사과", "바나나", "딸기" ]
// ----------------------------
// 배열연결
// 배열1.concat(배열2, 배열3)
// [...배열1, ...배열2, ...배열3]
const a1 = [1,2,3];
const a2 = ['a','b','c'];
const a3 = ['ㄱ','ㄴ'];
const a4 = a1.concat(a2,a3);
const a5 = [...a1, ...a2];
console.log(a4); // [ 1, 2, 3, "a", "b", "c", "ㄱ", "ㄴ" ]
console.log(a5); // [ 1, 2, 3, "a", "b", "c" ]
// ----------------------------
// 배열요소를 문자열로 결합
const a6 = a2.join();
const a7 = a2.join('');
console.log(a6); // a,b,c
console.log(a7); // abc
// ----------------------------
// 요소 검색
// 배열.indexOf(검색하고 싶은 요소, [검색시작위치])
// 배열.lastIndexOf(검색하고 싶은 요소, [검색시작위치])
// 배열.includes(검색하고 싶은 요소, [검색시작위치])
const b1 = [0,2,4,6,4,2,0];
console.log(b1.indexOf(4));     // 2
console.log(b1.lastIndexOf(4)); // 4
console.log(b1.includes(3));    // false
// ----------------------------
// 배열에서 조건 검색
// 배열.find(콜백함수)
// : 콜백함수에 처음 일치하는 요소
// 배열.findIndex(테스트함수)
// : 콜백함수에 처음 일치하는 요소의 인덱스
// 콜백함수
// :  ([요소],[인덱스],[元배열]) => 진리값
const c1 = ['스즈키','다나카','다카하시','고토'];
const targetUser1 = c1.find((elem) => elem == '다나카');
// 위와 동일
const targetUser2 = c1.find((elem) => { return elem == '다나카'; });
const targetUser3 = c1.findIndex((elem) => { return elem == '다나카'; });
console.log(targetUser1); // 다나카
console.log(targetUser2); // 다나카
console.log(targetUser3); // 1
// ----------------------------
// 배열의 역순
// 배열.reverse()
const c2 = [1,3,5];
console.log(c2); // [ 1, 3, 5 ]
c2.reverse();
console.log(c2); // [ 5, 3, 1 ]
// ----------------------------
// 배열을 정렬
// 배열.sort([비교함수])
// : 비교함수의 리턴값의 대소에 따라 정렬
//   0미만   : a, b의 순으로 정렬 
//   0       : a, b순서을 안바꿈
//   0보다큼 : b, a의 순으로 바꿈
// : 비교함수를 생략하면 문자열로 유니코드순으로 정렬
const c3 = [1,2,3,3,4,5];
c3.sort((a,b) => {
    // a가 b보다 작으면, a,b순으로 정렬
    if(a <  b) return  1; 
    if(a == b) return  0;
    if(a >  b) return -1;
});
console.log(c3); // [ 5, 4, 3, 3, 2, 1 ]
// ----------------------------
// 문자열 대소무시하고 비교 정렬
const c4 = ['grape','Orange','apple'];
c4.sort();
console.log(c4); // [ "Orange", "apple", "grape" ]
// ------------
const c5 = ['grape','Orange','apple'];
c5.sort((a,b) => a.localeCompare(b));
console.log(c5); // [ "apple", "grape", "Orange" ]
// ----------------------------
// 배열에서 새 배열 만들기
// 배열.map(콜백함수)
// : 콜백함수에 따라 새로운 배열을 작성
// : ([요소],[인덱스],[元배열]) => 밴경후의 요소
//   요소를 받아, 변경후의 요소를 반환
// map()
// : 어떤 배열을 근거로 새로운 배열을 만듬
//   요소 하나씩하나씩 처리
//   forEach()와 비슷한데 
//   map()는 실행후의 결과를 배열로 반환하는 점이 다름
const idList1  = [4, 10, 20];
const newList1 = idList1.map((value) => `userid_${value}`);
console.log(newList1); // [ "userid_4", "userid_10", "userid_20" ]
// ------------
const idList2  = [3, 8, 12];
const newList2 = idList1.map((value, index) => `userid_${index + 1}_${value}`);
console.log(newList2); // [ "userid_1_4", "userid_2_10", "userid_3_20" ]
// ------------
const idList3 = [
    { id:  2, name:'스즈키'  },
    { id: 10, name:'다나카'  },
    { id:  4, name:'사토'    },
    { id: 29, name:'다카하시'},
    { id:101, name:'오기하라'}
];
const newList3 = idList3.map((value) => value.id);
// 위와 같음
const newList4 = idList3.map((value) => { return value.id });
console.log(newList3); // [ 2, 10, 4, 29, 101 ]
console.log(newList4); // [ 2, 10, 4, 29, 101 ]
// ----------------------------
// 한 배열에서 조건을 만족하는 배열을 작성
// 배열.filter(콜백함수)
// 콜백함수에 일치하는 배열을 생성
// ([요소],[인덱스],[元배열]) => 진리값
const d1 = [10,20,30,40];
const d2 = d1.filter((value) => value >= 30);
const d3 = d1.filter((value) => { return value >= 30 });
const d4 = d1.filter(function (value) { return value >= 30; })
console.log(d2); // [ 30, 40 ]
console.log(d3); // [ 30, 40 ]
console.log(d4); // [ 30, 40 ]
// map과 filter의 
// : 공통점은 기존배열은 건드리지 않으면서 요소들을 순회한 후 
//   새로운 배열을 리턴한다는 것이고, 
// : 차이점은 map은 콜백함수가 적용된 새 요소, 
//   filter는 조건문을 만족한 요소들을 반환한다는 점입니다.
// ----------------------------
// 각 요소들로 부터 단일 값을 만듬
// 배열.reduce(콜백함수, [초기값])
// : 각 요소의 왼쪽에서 오른쪽으로 처리해서 단일값을 만듬
// 배열.reduceRight(콜백함수, [초기값])
// : 각 요소의 오른쪽에서 왼쪽으로 처리해서 단일값을 만듬
// 콜백함수
// ((앞요소, 현재요소, 인덱스, 元배열)) => { /* 처리 */}
const e1   = [100, 500, 900];
const sum1 = e1.reduce((previous, current) => { return previous + current; });
// 위와 같음
const sum2 = e1.reduce((a, b) => a + b );
let   sum3 = 0;
for(const price of e1){
    sum3 += price;
}
console.log(sum1); // 1500
console.log(sum2); // 1500
console.log(sum3); // 1500
// 2차 배열을 1차 배열로 만듬
const e2 = [['바나나','사과','딸기'],['귤','포도']];
const e3 = e2.reduce((a,b) => { return a.concat(b); });
const e4 = e2.reduceRight((a,b) => { return a.concat(b); });
console.log(e3); // [ "바나나", "사과", "딸기", "귤", "포도" ]
console.log(e4); // [ "귤", "포도", "바나나", "사과", "딸기" ]
// ----------------------------
// 배열과 비슷한 오브젝트를 배열로 변환
// [...변환대상]
// "..." (スプレッド연산자)
// : ArrayLike오브젝트를 배열로 변환
// ArrayLike오브젝트
// : length프로퍼티로 길이를 취득가능
//   index가 부여된 요소를 가짐
//   예) NodeListOf오브젝트(배열은 아니기 때문에 filter()사용불가)
const f1 = '안녕하세요';
const f2 = [...f1];
console.log(f1); // 안녕하세요
console.log(f2); // "안", "녕", "하", "세", "요" ]
// ------------
// Array.from(변환대상, [콜백함수])
// 로도 변환가능
// ([요소],[인덱스],[元배열]) => {}
const f3 = Array.from(f1);
const f4 = Array.from(f1, (c) => `${c}!!`);
console.log(f3);
// "안", "녕", "하", "세", "요" ]
console.log(f4);
// [ "안!!", "녕!!", "하!!", "세!!", "요!!" ]
// ----------------------------
// 복수의 값을 한번에 대입 (분할대입)
// [변수1, 변수2, 변수3] = [값1, 값2, 값3]
let a, b, c;
[a, b, c] = [1, 2, 3];
console.log(a, b, c); // 1 2 3
// ------------
// 값 치환
const f5 = ['스즈키','다나카'];
console.log(f5); // [ "스즈키", "다나카" ]
[f5[0], f5[1]] = [f5[1], f5[0]];
console.log(f5); // [ "다나카", "스즈키" ]
// ----------------------------
// 배열 섞기
const g1 = [1,2,3,4,5];
const arrLen = g1.length;
// Fisher-Yates알고리즘
for(let i = arrLen - 1; i >= 0 ; i--){
    const randomIdx = Math.floor(Math.random() * (i+1));
    [g1[i], g1[randomIdx]] = [g1[randomIdx], g1[i]];
}
console.log(g1); // [ 5, 1, 3, 2, 4 ]
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 오브젝트
// : 복수의 프로퍼티를 갖음
// 프로퍼티
// : 키-값 조합
const object = {}; // 빈 오브젝트
// ----------------------------
const person = {
    id:1,
    name:'스즈키',
    age:28
}
console.log(person.id);      // 1
console.log(person[name]);   // undefined
console.log(person['name']); // 스즈키
// ----------------------------
person.id = 99;
console.log(person.id);      // 99
// ----------------------------
const resp = {
    result:true,
    list:[{id:1, name:'다나카', age:26}
        ,{id:2, name:'곽', age:39}]
};
console.log(resp.list[0].name); // 다나카
console.log(resp.list[1].id);   // 2
resp.list[1].id = 98;
console.log(resp.list[1].id);   // 98
// ----------------------------
// 함수도 가능
const myClass = {
    method1 : function(){
        console.log('1실행');
    },
    method2 : function(){
        console.log('2실행');
    }
};
myClass.method2(); // 2실행
// ----------------------------
// 오브젝트 복사
const object1 = {
    result:true,
    members:[
        {id:1, name:'다나카1', age:26},
        {id:2, name:'다나카2', age:27},
        {id:3, name:'다나카3', age:28}
    ]
};
// Object.assign() 사용
const copiedObj1 = Object.assign({}, object1);
// ----------------------------
// ...(스프레드연산자)사용
const copiedObj2 = {...object1};
// Object.assign()/...(스프레드연산자)는 얕은 복사
// 얕은복사:복사元、복사先가 같은 데이터를 참조
// 복사元의 오브젝트의 조작은 복사先에 영향을 끼침
console.log(copiedObj1.result);          // true
console.log(copiedObj2.members[0].name); // 다나카1
object1.result = false;
object1.members[0].name='스즈키';
console.log(copiedObj1.result);          // true
console.log(copiedObj2.members[0].name); // 스즈키
// ----------------------------
// 오브젝트에 프로퍼티의 존재 체크
// 오브젝트.hasOwnProperty('키')
var ret1 = object1.hasOwnProperty('result');
var ret2 = 'members' in object1;
var ret3 = object1.result != null;
var ret4 = object1.no != null;
console.log(ret1); // true
console.log(ret2); // true
console.log(ret3); // true
console.log(ret4); // false
// ----------------------------
// 값에 대해 처리
// Object.keys(오브젝트)
// Object.values(오브젝트)
// Object.entries(오브젝트) // 각 프로퍼티의 배열
const person2 = {
    id2:1,
    name2:'스즈키',
    age2:28
}
console.log(Object.keys(person2));    // [ "id2", "name2", "age2" ]
console.log(Object.values(person2));  // [ 1, "스즈키", 28 ]
console.log(Object.entries(person2));
// 0: Array [ "id", 1 ]
// 1: Array [ "name", "스즈키" ]
// 2: Array [ "age", 28 ]
// ----------------------------
// 복수의 변수에 값을 한번에 대입
// 변수명 일치 필요
const {id2, name2, age3} = person2;
console.log(name2); // 스즈키
console.log(age3);  // undefined
// 별명은 가능
const {name2:yourName} = person2;
console.log(yourName); // 스즈키
// ----------------------------
// 오브젝트를 편집불가로 변경
// Object.freeze(오브젝트)
// Object.isFrozen(오브젝트)
// 오브젝트는 const여도 프로퍼티의 추가/삭제/변경이 가능
const object2 = {id:10, name:'다나카'};
console.log(object2); // { id: 10, name: "다나카" }
object2.id = 12;
object2.address = '서울';
console.log(object2); // { id: 12, name: "다나카", address: "서울" }
// "'use strict';" => 선두에 선언 에러감지를 유효화
Object.freeze(object2);
object2.id = 99; // "'use strict';" 없으면 에러는 안남
object2.mail = 'a@gmail.com';
console.log(object2); // { id: 12, name: "다나카", address: "서울" }
// ----------------------------
const arr1 = [1,2,3];
Object.freeze(arr1);
console.log(arr1);
// arr1.push(99); // "'use strict';" 없어도 에러남
console.log(Object.isFrozen(arr1)); // true
// ----------------------------
// 다른 방법
// - Object.seal() : 프로퍼티의 추가/삭제만 금지, 변경은 가능.
// - Object.preventExtensions() : 프러퍼티의 추가만 금지, 삭제/변경가능.
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// * 데이터형
// 1) 기본형
//    - Boolean, String, Number
//      Undefined : 값이 미정을 나타내는 형 
//      Null      : 값이 존재하지 않음을 나타내는 형
//      Symbol    : 심볼형
//    - immutable
//    - call by value
// 2) 오브젝트형
//    - Object : 오브젝트형(기본형이외의 모든형(Array, Object, Date등))
//    - mutable
//    - call by ref
// ----------------------------
// * 데이터형 조사
// typeof 값
// ----------------------------
// * 인스턴스조사
// 값 instanceof 오브젝트
// ----------------------------
// * 형변환
// Boolean(값)
// String(값)
// Number(값)
// parseInt(문자열)
// parseFloat(문자열)
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
const date    = new Date();
const year    = date.getFullYear();
const month   = date.getMonth() + 1;
const day     = date.getDate();
const h       = date.getHours();
const m       = date.getMinutes();
const s       = date.getSeconds();
const dayList = ['일','월','화','수','목','금','통'];
const week    = dayList[date.getDay()];
// ----------------------------
document.querySelector(".log1").innerHTML = 
    `지금은 ${year}년 ${month}월 ${day}일 ${week}요일 `
    + `${h}시 ${m}분 ${s} 초이다.`;
// 지금은 2022년 2월 14일 월요일 21시 16분 57 초이다.
// ----------------------------
const locale    = date.toLocaleString();
const localDate = date.toLocaleDateString();
const localTime = date.toLocaleTimeString();
// ----------------------------
document.querySelector(".log2").innerHTML = 
    `${locale}<br/>`
    + `${localDate}<br/>`
    + `${localTime}`;
// 2022. 2. 14. 오후 9:16:57
// 2022. 2. 14.
// 오후 9:16:57
// ----------------------------
const num1 = Date.parse('2022/02/14');
console.log(num1);           // 1644764400000
console.log(date.getTime()); // 1644841858431
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
const date1 = new Date('2022/02/15 01:02:03');
const date2 = new Date('Tue Feb 15 2022 01:02:03');
const date3 = new Date(2022, 02, 15, 01, 02, 03);
console.log(date1); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
console.log(date2); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
console.log(date3); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
// ----------------------------
const date4 = new Date('2022/02/15 01:02:03');
date4.setMonth(date4.getMonth() -1); // 한달전
console.log(date4.toLocaleDateString()); // 2022. 1. 15.
date4.setDate(date4.getDate() + 5);  // 5일 뒤
console.log(date4.toLocaleDateString()); // 2022. 1. 20.
// ----------------------------
const dateA = new Date('2022/02/15');
const dateB = new Date('2022/03/15');
const diffM = dateB.getTime() - dateA.getTime();
const diffD = diffM / (24 * 60 * 60 * 1000);
console.log(`차이 : ${diffD}일`); // 차이 : 28일
// ----------------------------
const dateC = new Date('2022/02/15 01:02:03');
const dateD = new Date('2022/02/15 03:02:03');
const diffM2 = dateD.getTime() - dateC.getTime();
const diffD2 = diffM2 / (60 * 60 * 1000); // 60 * 1000 => 분
console.log(`차이 : ${diffD2}시간`); // 차이 : 2시간
// ----------------------------
// - setInterval() : 일정한 시간 간격으로 작업을 수행하기 위해서 사용합니다.
//   clearInterval 함수를 사용하여 중지할 수 있습니다. 주의할 점은 일정한 시간 
//   간격으로 실행되는 작업이 그 시간 간격보다 오래걸릴 경우 문제가 발생할 수 있습니다.
// - setTimeout()  : 일정한 시간 후에 작업을 한번 실행합니다. 보통 재귀적 호출을 
//   사용하여 작업을 반복합니다. 기본적으로 setInterval 과는 달리 지정된 시간을 
//   기다린후 작업을 수행하고, 다시 일정한 시간을 기다린후 작업을 수행하는 방식입니다.
//   지정된 시간 사이에 작업 시간이 추가 되는 것입니다. clearTimeout() 을 사용해서 
//   작업을 중지합니다.
// - clearInterval(), clearTimeout() : 이 실행중인 작업을 중지시키는 것은 아닙니다. 
//   지정된 작업은 모두 실행되고 다음 작업 스케쥴이 중지 되는 것입니다.
// ----------------------------
const oldT = Date.now();
setInterval(() => {
    const curT = Date.now();
    const diff = curT - oldT;
    const sec  = Math.floor(diff / 1000);
    document.querySelector(".sec1").innerHTML = `${sec}초경과`;
}, 1000);
// ----------------------------
// 카운트다운
const totalT  = 10000;
const oldT2   = Date.now();
const timerId = setInterval(() => {
    const curT = Date.now();
    const diff = curT - oldT2;
    const remainMSec = totalT - diff;
    const remainSec  = Math.ceil(remainMSec/ 1000);

    let label = `남은시간 : ${remainSec}`;

    // 남은시간이 0이하면
    if(remainMSec <= 0){
        // 타이머 종료
        clearInterval(timerId);
        // 타이머 종료 메시지
        label = '종료';
    }
    // 화면에 표시
    document.querySelector('.sec2').innerHTML = label;
}, 1000);
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 아날로그 시계
// ----------------------------
setInterval(()=>{
    const now = new Date();
    const h = now.getHours();   // 시간 0 ~ 23
    const m = now.getMinutes(); // 분   0 ~ 59
    const s = now.getSeconds(); // 초   0 ~ 59

    // 단침 : 단침은 시간뿐만 아니라 분도 각도에 고려해야함
    const degH = h * ( 360 / 12 ) + m * ( 360 / 12 / 60);
    // 분침
    const degM = m * ( 360 / 60 );
    // 초침
    const degS = s * ( 360 / 60 );

    const elemH = document.querySelector('.lineHour');
    const elemM = document.querySelector('.lineMin');
    const elemS = document.querySelector('.lineSec');

    elemH.style.transform = `rotate(${degH}deg)`;
    elemM.style.transform = `rotate(${degM}deg)`;
    elemS.style.transform = `rotate(${degS}deg)`;
}, 50);
// ----------------------------
// HTML
// &lt;div class="clock"&gt;
//     &lt;div class="lineHour"&gt;&lt;/div&gt;
//     &lt;div class="lineMin" &gt;&lt;/div&gt;
//     &lt;div class="lineSec" &gt;&lt;/div&gt;
// &lt;/div&gt;
// ----------------------------
// &lt;style&gt;
//     .clock{
//         border-radius: 50%;
//         border : 3px solid red;
//         width : 400px;
//         height : 400px;
//         background-color : rgba(255, 255, 255, 0.1);
//         position : relative;
//     }
//     .lineHour {
//         width : 10px;
//         height : 150px;
//         background: blue;
//         position: absolute;
//         top: calc(50% - 150px);
//         left: calc(50% - 5px);
//         transform-origin: bottom;
//     }
//     .lineMin{
//         width: 4px;
//         height: 200px;
//         background: black;
//         position: absolute;
//         top: calc(50% - 200px);
//         left: calc(50% - 2px);
//         transform-origin: bottom;
//     }
//     .lineSec{
//         width: 2px;
//         height: 200px;
//         background:  #cccccc;
//         position: absolute;
//         top: calc(50% -200px);
//         left: calc(50% - 1px);
//         transform-origin: bottom;
//     }
// &lt;/style&gt;
// ----------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// window객체이기때문에 window생략가능
// window.alert('');
// alert('');
// ----------------------------
// confirm() 
// : 확인 다이얼로그, return T/F
// ----------------------------
// 문자입력프롬프트
// prompt(메시지내용, 입력란에 표시할 초기값)
// : return 문자열
// : 닫을 때까지 브라우저 조작안됨
// const str1 = prompt('Q', 'input answer');
// console.log(str1);
// ----------------------------
// 브라우저 사이즈 조사
// : 단위는 px, 읽기전용
// : 변화는 resize이벤트를 참조
const w = window.innerWidth;
const h = window.innerHeight;
console.log(w);
console.log(h);
window.addEventListener('resize', resizeHandler);

function resizeHandler(event){
    const w1 = innerWidth;
    const h1 = innerHeight;
    document.querySelector('.val_w').innerHTML = `너비:${w1}px`;
    document.querySelector('.val_h').innerHTML = `높이:${h1}px`;
}
// ----------------------------
// 디바이스의 pixel비를 초사
const dpr = window.devicePixelRatio;
console.log(dpr); // 1.5
// 캔버스 논리적인 크기
const can_w = 200;
const can_h = 200;
// 캔버스 사이즈 조절
const canvas = document.querySelector('#myCanvas');
canvas.width  = can_w * dpr;
canvas.height = can_h * dpr;
canvas.style.width  = can_w + 'px';
canvas.style.height = can_h + 'px';

const context = canvas.getContext('2d');
// 스케일 설정
context.scale(dpr, dpr);
// 원
context.fillStyle = 'red';
context.arc(can_w / 2, can_h / 2, 100, 0, 2 * Math.PI);
context.fill();

// 로그표시
document.querySelector('.canv_log').innerHTML = `現在のデバイスピクセル比は ${dpr} です`;
// ---------------------------
// 터치 가능 조사
// window.ontouchstart
// : 터치시작이벤트
// navigator.pointerEnabled
// : 포인터 사용가능 조사
// navigator.maxTouchPoints
// : 포인터 최대치
const isSupported = !!(
    'ontouchstart' in window || // ios & android
    (navigator.pointerEnabled && navigator.maxTouchPoints > 0) // IE11+
);
console.log(isSupported); // false
// ---------------------------

</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ---------------------------
// 페이지 이동
console.log(location.href); // 현재웹페이지URL
// => file:///D:/200.dev/201.src/_githubIO/ref/_test/js/002.html
location.href = 'http://www.google.com';
// 값을 대입한 타이밍에 페이지 이동
// ---------------------------
// 페이지 리로드
location.reload();     // => 브라우저의 캐시를 사용.
location.reload(true); // => 브라우저의 캐시를 무시.
// ---------------------------
// 브라우저의 '뒤로 돌아가기' 버튼과 같은 동작
history.back();    // 돌아가기
history.forward(); // 진행
history.go(수치);  // 임의의 수만큰 돌아감
history.go(-1) == history.back();
// ---------------------------
// 앵커사용
const hash = location.hash;
console.log(hash);
// ---------------------------
// hash 변경 이벤트
// &lt;a href="#orange"&gt;オレンジのアンカーリンク&lt;/a&gt;
window.addEventListener('hashchange', handleHashChange);
handleHashChange();

function handleHashChange(){
    const hash = location.hash;
    document.querySelector('.log1').innerHTML = `현재의 앵커는 ${hash}`;
}
// ---------------------------
// 새로운 윈도우로 URL열기
const win = window.open('http://www.google.co.kr');
// 뒤에서 열리는 경우도 있기때문에 포커스를 맞춰줌
win.focus();
// ---------------------------
// 윈도우 스크롤양을 조사
const x = window.screenX;
const y = window.screenY;
console.log(x);
console.log(y);
// ---------------------------
// 윈도우를 스크롤 시킴
// window.scrollTo(0, 1000);
// ---------------------------
// 타이틀 변경
// document.title
const title = document.title;
document.querySelector('#btnApple').addEventListener('click', ()=>{
    document.title = 'APPLE';
});
document.querySelector('#btnOrange').addEventListener('click', ()=>{
    document.title = 'ORANGE';
});
// ---------------------------
// 윈도우가 포커스가 되어 있나 조사
window.addEventListener('focus', ()=>{
    document.querySelector('.log1').innerHTML = `Focus 되어 있음`;
});
window.addEventListener('blur', ()=>{
    document.querySelector('.log1').innerHTML = `Focus 되어 있지 않음`;
});
// ---------------------------
// 전체화면 표시
const btn = document.querySelector('#btnFull');
btn.addEventListener('click', ()=>{
    document.body.requestFullscreen();
});
// 전체화면 끄기
const btnE = document.querySelector('#btnExit');
btnE.addEventListener('click', ()=>{
    document.exitFullscreen();
});
// ---------------------------
// 온라인/오프라인 처리 분기
const isOnline = navigator.onLine; // 상태취득
if(isOnline === true){
    console.log('온라인')
}else{
    console.log('오프라인')
}
window.addEventListener('online', ()=>{
    console.log('온라인');
});
window.addEventListener('offline', ()=>{
    console.log('오프라인');
});
// ---------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 이벤트
// 이벤트타겟.addEventListener(이벤트명, 리스너, [옵션])
// : 이벤트리스너는 이벤트타겟에 이벤트가 발생했을 때의 처리를 말함
// ----------------------------
// 방법1
const button = document.querySelector('.clsBtn');
button.addEventListener('click', () => { console.log('1234'); });
// 방법2
button.addEventListener('click', function() { console.log('1234'); });
// 방법3
button.addEventListener('click', funcOnclick);
function funcOnclick() { console.log('1234')}; 
// ----------------------------
// 이벤트 정보참조
button.addEventListener('click', (e) => { 
    console.log(e.target); // 이벤트가 발생한 요소 참조`
    console.log(e.target.outerHTML); 
});
// ----------------------------
// 옵션
// capture : capture phase를 취득할 것인가 => 참/거짓
// once    : 리스너를 한번만 호출할 것인가 => 참/거짓
// passive : 패시브이벤트인가 아닌가 => 참/거짓
const opt = { once : true };
document.querySelector('.clsBtn2')
        .addEventListener('click', () => { console.log('1234'); }, opt);
// ----------------------------
// 이벤트 삭제
// - 함수명을 기재(애로우함수는 불가능)
// - addEventListener()의 인수도 같은 인수를 지정
const button3 = document.querySelector('.clsBtn3');
button3.addEventListener('click', funcOnclick3);
// 10초후 이벤트 리스너 삭제
setTimeout(() => { button3.removeEventListener('click', funcOnclick3);}, 10000);
function funcOnclick3() { console.log('3333')}; 
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 페이지가 표시될 때 처리
// - DOMContentLoaded : HTML문서 해석 완료시
// - load             : 모든 리소스의 읽기 완료시
// js의 DOM요소의 조작은 HTML문서의 읽기와 해석이 완료되 후에 가능
// 이 타이밍에 발생하는 것이 DOMContentLoaded이벤트
window.addEventListener('DOMContentLoaded', () => {
    // .box요소의 개수
    const boxNum = document.querySelectorAll('.box').length;
    console.log(`box의 개수는 ${boxNum}개이다.`);
});
// load이벤트는 페이지내의 모든 리소스의 읽기가 끝난후에 발생.
// 그때문에 DOMContentLoaded보다도 타이밍이 늦다.
// 페이지를 표시할때 요소를 조작하고 싶다면 'DOMContentLoaded"가 적절
// ----------------------------
// js의 defer는 스크립트가 HTML해석종료후에 실행됨.
// 이것은 'DOMContentLoaded'발생전.
// 때문에 'defer'를 설정했다면, 'DOMContentLoaded'는 불필요.
// defer : HTML해석완료후에 js스크립트를 실행-->
// &lt;script src="002.js" defer /&gt;
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 이벤트
// - click
// - mousedown
// - mouseup
// - mousemove
// - mouseenter
// - mouseleave
// - mouseover
// - mouseout
// ----------------------------
document.querySelector('.box').addEventListener('mouseenter', ()=>{
    console.log('.box요소 위에 포인트가 올라갔다.')
});
document.querySelector('.box').addEventListener('mouseleave', ()=>{
    console.log('.box요소 위에 포인트가 떠났다.')
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 키보드 입력
// - keydown
// - keyup
// - keypress : 글자를 생성하는 키를 누름.
document.querySelector('.textarea').addEventListener('keydown', () => {
    console.log('キーが押された');
});
document.querySelector('.textarea').addEventListener('keypress', () => {
    console.log('文字が入力された');
});
document.querySelector('.textarea').addEventListener('keyup', () => {
    console.log('キーが離された');
});
// ----------------------------
// 입력된 키 조사
// - 키보드이벤트.key         : 눌린 버튼의 값
// - 키보드이벤트.code        : 눌린 버튼의 코드
// - 키보드이벤트.altKey      : ALT키가 눌렸나
// - 키보드이벤트.ctrlKey     :
// - 키보드이벤트.shiftKey    :
// - 키보드이벤트.metaKey     : 메타키(윈도우키)가 눌렸나
// - 키보드이벤트.repeat      : 키가 눌린 상태인가
// - 키보드이벤트.isComposing : 입력이 미확정인가
window.addEventListener('keydown', handleKeydown);

function handleKeydown(event){
    const keyCode = event.keyCode;
    // 화살표키
    if(keyCode === 39) console.log('오른쪽 키가 눌림');
    if(keyCode === 37) console.log('왼쪽 키가 눌림');
    if(keyCode === 38) console.log('위쪽 키가 눌림');
    if(keyCode === 40) console.log('아래쪽 키가 눌림');
}
// ----------------------------
// 탭이 백그라운드가 됨
// - visibilitychange
//   : 브라우저의 탭이 표시/비표시 될때 실행
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        console.log('コンテンツが表示されました');
    return;
    }
    if (document.visibilityState === 'hidden') {
        console.log('コンテンツがバックグラウンドになりました');
    }
});
// ----------------------------
// 화면 사이즈가 변경 되었을 때
// - resize
/** ウインドウの幅を表示する要素 */
const widthLog = document.querySelector('#widthLog');
/** ウインドウの高さを表示する要素 */
const heightLog = document.querySelector('#heightLog');

// ウインドウがリサイズされる度に処理を実行する
window.addEventListener('resize', () => {
    widthLog.innerText = `${window.innerWidth}px`;
    heightLog.innerText = `${window.innerHeight}px`;
});
// ----------------------------
// 화면리사이즈 부하 경감
let resizeTimer;
window.addEventListener('resize', () => {
    if(resizeTimer != null)
        clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
        onResize();
    }, 1000);
});
// 리사이즈 처리
function onResize(){}
// ----------------------------
// 화면사이즈가 브레이크 포인트를 넘었을 때 처리
// - matchMedia(미디어쿼리) : 리턴 MediaQueryList
// - matchMedia(미디어쿼리).addListener(처리) 
//  : 미디어쿼리에 일치했을 때 처리를 실행함
// - matchMedia(미디어쿼리).matches
//  : 미디어쿼리에 일치하는가 어떤가

const rectAngle = document.querySelector('.rectangle');
// メディアクエリ情報
const mediaQueryList = matchMedia('(min-width: 600px)');
// メディアクエリが変更されたタイミングで処理
mediaQueryList.addListener(onMediaQueryChange);
/** メディアクエリが変更された際に実行される関数 */
function onMediaQueryChange(mediaQueryList) {
    if (mediaQueryList.matches === true) {
        rectAngle.classList.add('big-size');
        console.log('ウインドウサイズが600pxを超えました');
    } else {
        rectAngle.classList.remove('big-size');
        console.log('ウインドウサイズが600pxを下回りました');
    }
}
// ページ表示時に一度onMediaQueryChange()を実行しておく
onMediaQueryChange(mediaQueryList);
// CSS
// .rectangle {
//     background-image: linear-gradient(-135deg, #00aaff, #5500ff);
// }
// .rectangle.big-size {
//     background-image: linear-gradient(-135deg, red, #ff00a2);
// }
// .rectangle {
//     width: 100%;
//     height: calc(100% - 50px);
//     transition: 300ms ease-in-out all;
// }
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 이벤트를 발생시킴
// - 이벤트리스너.dispatchEvent(이벤트)   : 이벤트를 발생시킴
// - new Event('이벤트명', [{detail:값}]) : 이벤트를 생성함
// 프로그램 실행시부터 1초후에 #myBox요소에 클릭 이벤트를 발생시킴
const boxElement = document.querySelector('#myBox');
boxElement.addEventListener('click', () => {
    boxElement.innerHTML = 'クリックされました';
});
setTimeout(() => {
    boxElement.dispatchEvent(new Event('click'));
}, 1000);
// click만 가능
setTimeout(() => {
    boxElement.click();
}, 1000);
// ----------------------------
// 디폴트 이벤트를 캔슬
// - 이벤트.preventDefault()

/** マウスホイールを有効にするかどうか */
let enableMouseWheel = true;
// チェックボックスをクリックしたときの処理
document.querySelector('#mouseWheelToggle')
        .addEventListener('click', (event) => {
    // チェックボックスに値が入っていたら、マウスホイールを無効化する
    enableMouseWheel = event.target.checked === false;
});

// スクロール可能な要素上でマウスホイールしたときの処理
document.querySelector('.scrollable-element')
        .addEventListener('wheel', (event) => {
    // マウスホイールが有効な場合は処理を抜ける
    if (enableMouseWheel === true) {
        return;
    }
    // マウスホイールが無効な場合はevent.preventDefault()を実行
    event.preventDefault();
});
// ----------------------------
// 드래그 앤 드롭
// - dragstart : 요소의 드래그가 시작
// - drag
// - dragend
// - dragenter : 드래그중에 마우스가 요소의 위에 올라감
// - dragover  : 드래그중에 마우스가 요소에 존재함
// - dragleave
// - drop
// - event.dataTransfer.files
//   : 드롭된 파일의 정보, 리턴 FileList오브젝트
// ----------
const character = document.querySelector('.character');

character.addEventListener('dragstart', () => {
    console.log('dragstartイベント');
});

character.addEventListener('drag', () => {
    console.log('dragイベント');
});

character.addEventListener('dragend', () => {
    console.log('dragendイベント');
});

box.addEventListener('dragenter', () => {
    console.log('dragenterイベント');
});

box.addEventListener('dragover', () => {
    console.log('dragoverイベント');
});

box.addEventListener('dragleave', () => {
    console.log('dragleaveイベント');
});

// dragoverイベントの無効化
box.addEventListener('dragover', (event) => {
    event.preventDefault();
});

box.addEventListener('drop', () => {
    console.log('dropイベント');
});
// ---------- 
// 샘플
// ファイルアップロードゾーン
const fileZone = document.querySelector('.file-zone');

// ファイルアップロードゾーンに着脱するクラス
const className = 'on';

// ドラッグした要素が重なったときの処理
fileZone.addEventListener('dragover', (event) => {
    // デフォルトの挙動を停止
    event.preventDefault();
    fileZone.classList.add(className);
});

// ドラッグした要素が離れたときの処理
fileZone.addEventListener('dragleave', () => {
    // デフォルトの挙動を停止
    event.preventDefault();
    fileZone.classList.remove(className);
});

// ドロップした時の処理
fileZone.addEventListener('drop', (event) => {
    // デフォルトの挙動を停止
    event.preventDefault();
    fileZone.classList.remove(className);

    // Fileオブジェクトを参照
    const transferdFiles = event.dataTransfer.files;

    // 画像を表示する
    displayImages(transferdFiles);
});

/** 画像の表示処理 */
function displayImages(transferdFiles) {
    // 画像ファイルの格納配列
    const imageFileList = [];

    // ファイル数
    const fileNum = transferdFiles.length;

    // ファイルが画像のもののみを配列に格納する
    for (let i = 0; i < fileNum; i++) {
        if (transferdFiles[i].type.match('image.*') === false) {
            return;
        }
        imageFileList.push(transferdFiles[i]);
    }

    // 画像表示エリアの参照
    const imagePreviewArea = document.querySelector('.image-list');

    // 各画像ファイルについて処理
    for (const imageFile of imageFileList) {
        // 画像ファイルの読み込み処理
        const fileReader = new FileReader();
        fileReader.readAsDataURL(imageFile);
        fileReader.addEventListener('load', (event) => {
            const image = new Image();
            image.src = event.target.result;
            // 表示エリアの先頭に画像ファイルを表示
            imagePreviewArea.insertBefore(image, imagePreviewArea.firstChild);
        });
    }
}
// ---------- 
// CSS
// body {
//     display: block;
//     overflow: scroll;
// }
// 
// .file-zone {
//     background-color: rgba(0, 0, 0, 0.1);
//     box-sizing: border-box;
//     display: flex;
//     justify-content: center;
//     align-items: center;
//     width: 100%;
//     height: calc(100% - 200px);
//     transition: 100ms all ease-out;
// }
// 
// .file-zone.on {
//     background-color: rgba(97, 131, 209, 0.9);
// }
// 
// .file-preview-area {
//     width: 100%;
//     min-height: 200px;
//     background-color: rgba(0, 0, 0, 0.58);
// }
// 
// .file-preview-area .image-list {
//     display: grid;
//     overflow: scroll;
//     gap: 10px;
//     grid-template-columns: repeat(3, 1fr);
//     grid-auto-rows: 200px;
// }
// 
// .file-preview-area .image-list > img {
//     width: 100%;
//     height: 100%;
//     display: block;
//     object-fit: cover;z
// }
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - HTML상의 각 요소에의 접근구조는 
//   DOM이라는 인터페이스에 정의되어 있다.
//   DOM에서는 HTML문서르 트리구조로 취급함.
// - 트리의 각 구성요소를 노드라고 함.
//   JS의 Node오브젝트로 취급.
// - HTML문서 전체는 document로 취득가능하고 
//   그 자체가 큰 Node오브젝트가된다.
// - 요소노드는 Element오브젝트로 취급함.
//   Element오브젝트는 Node오브젝트를 계승.
// ----------------------------
// - 셀렉터로 요소를 취득
// document.querySelector(셀렉터명)
// #ID명, .클래스명, :nth-child(번호)등으로 지정
// 일치하는 요소가 복수개 있을때는 최초의 요소가 반환.
const logElement = document.querySelector('#log');
logElement.innerHTML = 'こんにちは';
// ----------------------------
// - ID로 요소 취득
//   document.getElementById(ID)
//   인수로 ID만 지정가능.
// ----------------------------
// - 셀렉터명에 해당하는 요소를 한번에 취득
//   document.querySelectorAll(셀렉터명)
//   요소의 배열(Nodelist)를 반환
// 各.box要素に対してループ
document.querySelectorAll('.box').forEach((targetBox) => {
    // .box要素をクリックしたときの処理
    targetBox.addEventListener('click', () => {
        // クリックされた.box要素のテキストを表示
        alert(`${targetBox.textContent}がクリックされました`);
    });
});
// ----------------------------
// - 클래스명과 일치하는 요소 취득
//   document.getElementByClassName(클래스명)
//   요소의 배열(HTML Collection)반환
// ----------------------------
// - &lt;HTML&gt;요소와 &lt;body&gt;요소를 취득
//   document.documentElement : 루트요소(html요소)
//   document.head : head요소
//                   head내에 script태그나 link태그를 삽입등에 사용
//   document.body : body요소
const themeChangeButton =
    document.querySelector('.theme-change-button');

// テーマ変更ボタンをクリックしたときの処理
themeChangeButton.addEventListener('click', () => {
    // body要素のクラスの「theme-dark」を切り替える
    document.body.classList.toggle('theme-dark');
});
// ----------
// CSS 
// body {
//     font-size: 20px;
//     color: #2f3b4c;
//     background-color: #f9f9f9;
//     transition: 300ms all ease-out;
// }
// 
// body.theme-dark {
//     background-color: #1e1e1e;
//     color: #fff;
// }
// 
// body:before {
//     background-image: none;
// }
// 
// .theme-change-button {
//     font-size: 12px;
//     width: auto;
//     color: initial;
//     background-color: white;
//     position: fixed;
//     top: 10px;
//     right: 10px;
//     margin-bottom: 10px;
//     padding: 10px;
//     cursor: pointer;
// }
// 
// body.theme-dark .theme-change-button {
//     background-color: #1e1e1e;
//     color: #fff;
// }
// 
// h1 {
//     font-size: 26px;
//     line-height: 1.5;
//     border-bottom: 1px solid #2f3b4c;
//     text-align: left;
//     transition: 300ms border-bottom-color ease-out;
// }
// 
// body.theme-dark h1 {
//     border-bottom-color: white;
// }
// 
// main {
//     height: auto;
//     background-color: transparent;
//     border-radius: 0;
//     max-width: 900px;
// }
// ----------------------------
// - 자식요소, 전후요소, 부모요소를 취득
//   부모노드.children
//   부모노드.firstElementChild
//   부모노드.lastElementChild   : 맨마지막 자식노드
//   노드.nextFlementSibling     : 다음(동생) 노드
//   노드.previousFlementSibling : 이전(형) 노드
//   자식노드.parentNode         : 부모도느
const parentElement = document.querySelector('#parent');
console.log(parentElement.children);
// ----------------------------
// - 부모요소의 어미에 요소를 추가
//   부모노드.appendChild(자식노드)
const container = document.querySelector('.container');
const myBox = document.querySelector('#myBox');
// 3秒後に#myBox要素を.container要素の末尾に追加する
setTimeout(() => {
    container.appendChild(myBox);
}, 3000);
// ----------------------------
// - 지정요소의 앞에 요소를 추가
//   부모노드.insertBefore(자식노드, 앞요소)
const container = document.querySelector('.container');
const myBox1 = document.querySelector('#myBox1');
const myBox2 = document.querySelector('#myBox2');
const box2 = document.querySelector('#box2');
// 3秒後に#myBox1要素を.containerの先頭に追加する
setTimeout(() => {
    container.insertBefore(myBox1, container.firstElementChild);
}, 3000);
// 4秒後に#myBox2要素を#box2要素の前に追加する
setTimeout(() => {
    container.insertBefore(myBox2, box2);
}, 4000);
// ----------------------------
// - HTML코드를 요소로 삽입
//   부모요소.insertAdjacentHTML(삽입위치, 문자열)
//   : 'beforebegin' => 부모요소의 직전
//   : 'afterbegin'  => 부모요소내의 선두
//   : 'beforeend'   => 부모요소내의 말미
//   : 'afterend'    => 부모요소의 직후
const container = document.querySelector('.container');
// 挿入する.new-box要素
const newBox1 = `<div class="new-box box">.new-box要素 - 1</div>`;
const newBox2 = `<div class="new-box box">.new-box要素 - 2</div>`;
const newBox3 = `<div class="new-box box">.new-box要素 - 3</div>`;
const newBox4 = `<div class="new-box box">.new-box要素 - 4</div>`;

setTimeout(() => {
	// .container要素内先頭に.new-box要素を追加する
	container.insertAdjacentHTML('beforebegin', newBox1);
	container.insertAdjacentHTML('afterbegin', newBox2);
	container.insertAdjacentHTML('beforeend' , newBox3);
	// .container要素の直後に.new-box要素を追加する
		container.insertAdjacentHTML('afterend', newBox4);
}, 3000);
// ----------
// HTML
// &lt;!-- beforebegin --&gt;
// &lt;div class="container"&gt;
// &lt;!-- afterbegin --&gt;
//   &lt;div class="box"&gt;子要素1&lt;/div&gt;
//   &lt;div class="box"&gt;子要素2&lt;/div&gt;
//   &lt;!-- beforeend --&gt;
// &lt;/div&gt;
// &lt;!-- afterend --&gt;
// ----------------------------
// - 요소를 동적으로 삭제
//   부모노드.removeChild(자식노드)
// 3秒後に処理を行う
setTimeout(() => {
    const parentElement = document.querySelector('#parent');
    const childElement = document.querySelector('#child');
    // #child要素を取り除く
    parentElement.removeChild(childElement);
}, 3000);
// ----------------------------
// - 자기자신의 요소를 삭제
//   노드.remove()
//   : 삭제하고 싶은 요소에 대해 처리를 실시
// 3秒後に処理を行う
setTimeout(() => {
    const childElement = document.querySelector('#child');
    // #child要素を取り除く
    childElement.remove();
}, 3000);
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 요소를 생성
//   document.createElement('태그명', 옵션)
// create-modal-buttonをクリックしたときの処理
document
    .querySelector('#create-modal-button')
    .addEventListener('click', displayModalWindow);

/** モーダルウインドウを表示する */
function displayModalWindow() {
    // モーダルウインドウを生成する
    const modalElement = document.createElement('div');
    // modalクラスを付与する
    modalElement.classList.add('modal');

    // モーダルウインドウの内部要素を生成する
    const innerElement = document.createElement('div');
    innerElement.classList.add('inner');
    innerElement.innerHTML = `
        <p>モーダルウインドウの中身です</p>
        <div class="character"></div>
    `;
    // モーダルウインドウに内部要素を配置する
    modalElement.appendChild(innerElement);
    // body要素にモーダルウインドウを配置する
    document.body.appendChild(modalElement);

    // 内部要素をクリックしたらモーダルウインドウを削除する処理
    innerElement.addEventListener('click', () => {
        closeModalWindow(modalElement);
    });
}

/** モーダルウインドウを閉じる */
function closeModalWindow(modalElement) {
    document.body.removeChild(modalElement);
}
// ----------
// CSS
// @import url(../../common/css/base_photo.css);
// body {
//     background-size: cover;
//     background: url("../common/bg_nature.jpg") center;
// }
// 
// .modal {
//     width: 100%;
//     height: 100%;
//     position: absolute;
//     top: 0;
//     left: 0;
//     background-color: rgba(0, 0, 0, 0.2);
//     display: flex;
//     justify-content: center;
//     align-items: center;
// }
// 
// .modal .inner {
//     width: 100%;
//     height: 100%;
//     background-color: rgba(255, 255, 255, 0.9);
//     margin: 10px;
//     display: block;
//     width: 960px;
//     height: 540px;
//     border-radius: 5px;
//     -webkit-backdrop-filter: blur(16px);
//     box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.3);
//     box-sizing: border-box;
//     padding: 20px;
//     text-align: center;
//     background-color: rgba(255, 255, 255, 0.9);
//     max-width: 600px;
//     max-height: 400px;
//     display: flex;
//     justify-content: center;
//     align-items: center;
//     flex-direction: column;
//     color: #333;
//     font-size: 1.5rem;
//     animation: fadeInAnimation 200ms ease-out;
// }
// 
// @keyframes fadeInAnimation {
//     from {
//         opacity: 0;
//     }
//     to {
//         opacity: 1;
//     }
// }
// ----------------------------
// - 요소를 복제
//   노드.cloneNode([진위값])
//   인수에 true를 넣으면 자식노드도 복제
setTimeout(() => {
    // #myBox要素を子ノードも含めて複製
    const clonedBox = document.querySelector('#myBox').cloneNode(true);
    document.querySelector('.container').appendChild(clonedBox);
}, 3000);
// ----------------------------
// - 요소를 다른 요소로 치환
//   부모노드.replaceChild(신노드, 구노드)
//   치환된 노드를 리턴
//   신노드와 구노드를 교체
//   교체대상이 자식노드가 아닐경우 에러발생
setTimeout(() => {
    // コンテナ
    const container = document.querySelector('.container');
    // 旧ボックス要素
    const oldBox = document.querySelector('.old-box');
    // 新ボックス要素。div要素を作り、「新ボックス」というテキストノードを追加する
    const newBox = document.createElement('div');
    newBox.textContent = '新ボックス';
    // new-box, boxというCSSクラスを追加する
    newBox.classList.add('new-box', 'box');
    // 新旧ボックスを入れ替える
    container.replaceChild(newBox, oldBox);
    }, 3000);
// ----------------------------
// - 신노드를 구노드와 교체
//   구노드.replaceWith(신노드)
//   리턴값없음
setTimeout(() => {
    // 旧ボックス要素
    const oldBox = document.querySelector('.old-box');
    // 新ボックス要素。div要素を作り、「新ボックス」というテキストノードを追加する
    const newBox = document.createElement('div');
    newBox.textContent = '新ボックス';
    // new-box, boxというCSSクラスを追加する
    newBox.classList.add('new-box', 'box');
    // 新旧ボックスを入れ替える
    oldBox.replaceWith(newBox);
    }, 3000);
// ----------
// CSS
// .container {
//     display: flex;
//     border: 2px dotted #fff;
//     padding: 10px;
// }
// 
// .container .new-box {
//     border: 4px solid #d03939;
// }
// ----------------------------
// - 요소내의 텍스트 취득/치환
//   노드.textContent
//   Node오브젝트의 프로퍼티
//   텍스트내의 HTML태그는 무시됨
const weatherElement = document.querySelector('#weather');

// 3秒後に#weatherの中身を書き換える
setTimeout(() => {
    weatherElement.textContent = '気温は24℃の予想です。';
}, 3000);
// ----------------------------
// - 요소내의 HTML을 취득/변경
//   요소.innerHTML
//   Element오브젝트의 프로퍼티
//   텍스트 뿐만 아니라 태그도 변경할 경우 사용
const weatherElement = document.querySelector('#weather');

// 3秒後に#weatherの中身を書き換える
setTimeout(() => {
    weatherElement.innerHTML = '気温は<strong>-3℃</strong>の予想です。';
}, 3000);
// ----------------------------
// - 요소(자기자신포함)의 HTML을 취득/변경
//   요소.outerHTML
//   innerHTML과 달리 자신도 대상에 포함
// a要素を一括取得する
const aElementList = document.querySelectorAll('a');

// 各a要素について処理する
aElementList.forEach((element) => {
    // aタグにtarget属性が存在しなかったらreturn
    if (element.hasAttribute('target') === false) {
        return;
    }
    // target属性_blankではなかったらreturn
    if (element.getAttribute('target') !== '_blank') {
        return;
    }
    // rel属性にnoopenerを付与する
    element.setAttribute('rel', 'noopener');
});</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 155
// - 요소의 속성을 취득/변경
//   요소.getAttribute(속성명, 값)
//   요소.setAttribute(속성명)
//   요소.hasAttribute(속성명)
const anchorElem = document.querySelector("#anchor");
console.log(anchorElem.getAttribute('href'));

const imageElem = document.querySelector("#image");
imageElem.setAttribute('src','test2.jpg');
// ----------------------------
// - [ref="noopener"]
//   [target="_blank"]가 설정되어 있는 a태그로 윈도우를 열면,
//   열린 윈도우에서 window.opener를 사용해서 원래의 윈도우를 
//   조작가능해짐. 위험을 동반하기 때문에 noopener를 사용.
// a要素を一括取得する
const aElementList = document.querySelectorAll('a');

// 各a要素について処理する
aElementList.forEach((element) => {
    // aタグにtarget属性が存在しなかったらreturn
    if (element.hasAttribute('target') === false) {
        return;
    }

    // target属性_blankではなかったらreturn
    if (element.getAttribute('target') !== '_blank') {
        return;
    }

    // rel属性にnoopenerを付与する
    element.setAttribute('rel', 'noopener');
});
// ----------------------------
// - 요소의 클래스 속성의 추가/삭제
//   요소.classList.add(클래스1, 클래스2, ...)
//   요소.classList.remove(클래스1, 클래스2, ...)
//   요소.classList.contains(클래스)
const box = document.querySelector('#box');
console.log(box.classList.contains('red'));
// ----------------------------
// - 요소의 클래스의 유무를 전환(동적으로 붙였다가 뗌)
//   요소.classList.toggle(클래스)
//   클래스가 설정되어 있다면 추가, 아니면 삭제를 토글
setInterval(()=>{
    box.classList.toggle('red');
});
// ----------
// .button要素すべてについて処理をする
document.querySelectorAll('.button').forEach((button) => {
    // .button要素をクリックしたときの処理を設定する
    button.addEventListener('click', () => {
        // .button要素の次の要素のクラスを切り替える
        button.nextElementSibling.classList.toggle('show');
    });
});
// ----------
// CSS
// @import url(../../common/css/base_photo.css);
// body {
//     background-size: cover;
//     background: url('../common/bg_snow.jpg') center;
// }
// 
// h1 {
//     -webkit-text-stroke: 1px white;
//     text-stroke: 1px white;
//     font-weight: bold;
// }
// 
// main {
//     padding: 10px;
// }
// 
// .section-wrapper {
//     display: flex;
// }
// 
// section {
//     width: calc(100% / 3);
//     padding-left: 5px;
//     padding-right: 5px;
//     box-sizing: border-box;
// }
// 
// .button {
//     width: 100%;
//     text-transform: none;
//     height: 40px;
//     line-height: 40px;
//     font-size: 20px;
//     background-color: #2673a6;
// }
// 
// .button:hover {
//     background-color: #2688bc;
// }
// 
// .button:active {
//     background-color: #265c8f;
// }
// 
// .button + .content {
//     display: none;
//     font-size: 20px;
//     margin-top: 10px;
//     border: 1px solid white;
//     background: rgba(0, 0, 0, 0.7);
//     border-radius: 2px;
//     padding: 10px;
//     box-shadow: 0px 1px 1px rgba(0, 0, 0, 0.3) inset;
//     text-align: left;
//     color: white;
// }
// 
// .button + .content.show {
//     display: block;
// }
// 
// .button + .content h2 {
//     font-size: 22px;
// }
// 
// .button + .content dt {
//     margin-bottom: 10px;
// }
// 
// .button + .content dl,
// .button + .content dt,
// .button + .content dd {
//     margin: 0;
// }
// ----------------------------
// - 스타일을 변경
//   요소.style.프로퍼티명
//   CSS의 케밥케이스가 아닌 카멜케이스
//   인라인스타일도 같은 취급
//   인라인스타일이 우선순위가 높다
const information = document.querySelector('#information');

// colorプロパティーの変更
information.style.color = 'white';
// font-sizeプロパティーの変更
information.style.fontSize = '70px';
// font-weightプロパティーの変更
information.style.fontWeight = '600';

const strokeColor = '#c52b84';
// -webkit-text-strokeプロパティーの変更
information.style.webkitTextStroke = `2px ${strokeColor}`;
// text-strokeプロパティーの変更
information.style.textStroke = `2px ${strokeColor}`;
// text-shadowプロパティーの変更
information.style.textShadow = `7px 7px 0 #bf3384`;
// ----------------------------
// - 스타일을 취득
//   getComputedStyle(요소).프로퍼티명
// ----------
// HTML
// &lt;div id="box" class="red"&gt;&lt;/div&gt;
// ----------
// CSS
// #box {
//     width: 100px;
//     height: 100px;
// }
// .red {
//     background-color: #ff2bc2;
// }
// .blue {
//     background-color: #2b85ff;
// }
// ----------
const box = document.querySelector('#box');
console.log(getComputedStyle(box).width);
// width値を取得する。100px
console.log(getComputedStyle(box).backgroundColor);
// background-colorを取得する。rgb(255, 43, 194)
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 161
// - 텍스트박스 정보 취득
//   인풋요소.value
//   인풋요소는 &lt;input type"text" /&gt;
const element = document.querySelector('#myText');
const value = element.value;
console.log(value);
// ----------------------------
// - 텍스트 박스 변경감지 이벤트
//   input  : input요소의 키입력과 동시에 발생
//   change : input요소의 변경시 발생(키입력시 또는 포커스떠날때 발생)
// input要素の参照
const element = document.querySelector('#myText');
// イベントを登録
element.addEventListener('input', handleChange);

function handleChange(event) {
    // 値を取得する
    const value = event.target.value;
    // 画面に反映
    document.querySelector('.log').innerHTML = value;
}
// ----------------------------
// - 텍스트애리어의 정보 취득
//   텍스트애리어요소.value
// textareaの参照
const element = document.querySelector('#myText');
// 値を取得
const value = element.value;
console.log(value); // 結果: '今日の天気は、(改行)曇りです。'
// ----------------------------
// - 텍스트애리어 변경 감지 이벤트
//   input  : 키입력과 동시 발생
//   change : 지연후 발생
// textareaの参照
const element = document.querySelector('#myText');
// イベントを登録
element.addEventListener('input', handleChange);

function handleChange(event) {
    // 値を取得
    const value = event.target.value;

    // 改行コードを改行タグに変換
    const htmlStr = value.split('\n').join('<br />');
    document.querySelector('.log').innerHTML = htmlStr;
}
// ----------------------------
// - 체크박스 정보 취득
//   인풋요소.checked
//   선택된 상태인가 아닌가를 반환
//   &lt;input type"checkbox" /&gt;
const cbA = document.querySelector('#cbA');
const checkedA = cbA.checked; // 選択状態を確認
console.log('checkedAの値', checkedA); // 結果: false
// true로 변경
cbA.checked = true;
// ----------------------------
// - 체크박스의 변경감지 이벤트
//   change 
// チェックボックスの参照
const cb = document.querySelector('#cbA');
cb.addEventListener('change', (event) => {
    // 選択状態を確認する
    const value = event.target.checked;

    // 画面に表示する
    const log = `チェックボックスAは ${value} になりました`;
    document.querySelector('.log').innerHTML = log;
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// ----------------------------
// - 로컬파일의 정보취득
//   인풋요소.files
//   &lt;input type"file" /&gt;
//   선택된 파일의 배열을 리턴
//   change이벤트의 event.target.files프로퍼티를 통해 파일리스트 참조 가능
//   multiple속성의 지정으로 복수파일의 업로드도 가능
// input要素を参照
const element = document.querySelector('#myFile');

// ファイル選択ダイアログが選択されたら
element.addEventListener('change', (event) => {
    const target = event.target;
    // 選択されたファイルを参照
    const files = target.files;
    // 配列になってるので、0番目のファイルを参照
    const file = files[0];

    // ユーザーが選択したファイル名を表示
    alert(`${file.name}が選択されました`);
});
// ----------------------------
// - 로컬파일을 텍스트로 읽기
//   readAdText(파일)
//   FileReader오브젝트를 사용
//   파일의 읽기는 비동기로 이루어지기때문에 
//   addEventListener()메소드를 사용해서, 읽기완료를 나타내는
//   load이벤트를 감시. load이벤트 완료후에는 FileReader오브젝트의
//   result프로퍼티를 통해 데이터에 액세스가 가능해짐.
// ----------
// HTML
// &lt;input type="file" id="myFile" accept=".txt"/&gt;
// &lt;p class="log"&gt;&lt;/p&gt;
// ----------
const element = document.querySelector('#myFile');
const pEl = document.querySelector('.log');

// ファイル選択ダイアログが選択されたら
element.addEventListener('input', (event) => {
    const target = event.target;
    // 選択されたファイルを参照
    const files = target.files;
    // 配列になってるので、0番目のファイルを参照
    const file = files[0];

    // FileReaderのインスタンスを作成
    const reader = new FileReader();
    // 読み込み終わったら
    reader.addEventListener('load', () => {
        // 結果をp要素に出力する
        pEl.textContent = reader.result;
    });
    // テキストファイルとして読み込む
    reader.readAsText(file);
});
// ----------------------------
// - 로컬파일을 DataURL데이터로 읽어들임
//   readAsDataURL(파일)
//   데이터를 송신용으로 취득하고싶을때
// ----------
// HTML
// &lt;input type="file" id="myFile" accept=".png, .jpg"/&gt;
// &lt;p class="log"&gt;&lt;img /&gt;&lt;/p&gt;
// ----------
const element = document.querySelector('#myFile');
const imgEl = document.querySelector('.log img');

// ファイル選択ダイアログが選択されたら
element.addEventListener('input', (event) => {
    const target = event.target;
    // 選択されたファイルを参照
    const files = target.files;
    // 配列になってるので、0番目のファイルを参照
    const file = files[0];

    // FileReaderのインスタンスを作成
    const reader = new FileReader();
    // 読み込み終わったら
    reader.addEventListener('load', () => {
        // 画像を表示
        imgEl.src = reader.result;
    });
    // テキストファイルとして読み込む
    reader.readAsDataURL(file);
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 라디오버튼 정보취득
//   폼요소[키명]
// ----------
// HTML
// form要素を参照
// &lt;form id="radioGroup"&gt;
// &lt;!-- 1つ目のラジオボタン群 --&gt;
// &lt;label&gt;&lt;input type="radio" name="fruit" value="apple" checked/&gt;Apple&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="fruit" value="orange"/&gt;Orange&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="fruit" value="grape"/&gt;Grape&lt;/label&gt;
// 
// &lt;!-- 2つ目のラジオボタン群 --&gt;
// &lt;label&gt;&lt;input type="radio" name="drink" value="coke" checked/&gt;coke&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="drink" value="wine"/&gt;wine&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="drink" value="tea"/&gt;tea&lt;/label&gt;
// &lt;/form&gt;
// ----------
const element = document.querySelector('form#radioGroup');

// 現在の選択状態を取得
const drinkValue = element.drink.value;
const fruitValue = element.fruit.value;

console.log(`drinkの値は ${drinkValue} です`);
console.log(`fruitValueの値は ${fruitValue} です`);
// ----------------------------
// - 라디오버튼 변경감지이벤트
//   change
// form要素を参照
const element = document.querySelector('#radioGroup');
// 変更を監視
element.addEventListener('change', handleChange);

function handleChange(event) {
    // 現在の選択状態を取得
    const drinkValue = element.drink.value;
    const fruitValue = element.fruit.value;

    console.log(`drinkの値は ${drinkValue} です`);
    console.log(`fruitValueの値は ${fruitValue} です`);
}
// ----------------------------
// - 드롭다운메뉴의 정보취득
//   셀렉터요소.value
// ----------
// HTML
// &lt;select id="mySelect"&gt;
// &lt;option value="apple"&gt;apple&lt;/option&gt;
// &lt;option value="orange"&gt;orange&lt;/option&gt;
// &lt;option value="grape" selected&gt;grape&lt;/option&gt;
// &lt;/select&gt;
// &lt;p class="log"&gt;&lt;/p&gt;
// ----------
// select要素の参照
const element = document.querySelector('#mySelect');
// 値を取得
const value = element.value;
// 整形して画面に表示
const log = `選択されているのは ${value} です`;
document.querySelector('.log').innerHTML = log;
// 값 변경
element.value = 'orange';
// ----------------------------
// - 드롭다운메뉴의 변경감지이벤트
//   change
// select要素の参照
const element = document.querySelector('#mySelect');
// 変更イベントを監視
element.addEventListener('change', handleChange);

function handleChange(event) {
    // 値を取得
    const value = element.value;

    // 整形して画面に表示
    const log = `選択されているのは ${value} です`;
    document.querySelector('.log').innerHTML = log;
}
// ----------------------------
// - 슬라이더의 정보취득
//   인풋요소.value
//   &lt;input type"range" /&gt;
//   슬라이더의 현재값을 문자열로 반환
// input要素の参照
const element = document.querySelector('#myRange');
// 現在の値を取得
const value = element.value;
// 画面に表示
document.querySelector('.log').innerHTML = `現在の値は ${value} です`;
element.value = 99;
// ----------------------------
// - 슬라이더의 변경감지 이벤트
//   input  : 슬라이더를 움직이는 중에도 발생
//   change : 이동이 끝난 후에만 발생
// input要素の参照
const element = document.querySelector('#myRange');
// 変更イベントを監視
element.addEventListener('input', handleChange);
function handleChange(event) {
    // 現在の値を取得
    const value = event.target.value;
    // 画面に表示
    document.querySelector('.log').innerHTML = `現在の値は ${value} です`;
}
// ----------------------------
// - 컬러픽커
//   인풋요소.value
//   &lt;input type"color" /&gt;
//   선택한 색을 리턴(문자열)
const element = document.querySelector('#myColor');
const value = element.value;
console.log(value); // 結果: '#ff0000'
// 변경
element.value="#00ff00";
// ----------------------------
// - 컬러픽커의 변경감지 이벤트
//      change : 이동이 끝난 후에만 발생
const cbA = document.querySelector('#myColor');
cbA.addEventListener('change', (event) => {
    // 選択された色を確認する
    const value = event.target.value;
    // 画面に表示する
    const log = `選択された色が ${value} になりました`;
    const logEl = document.querySelector('.log');
    logEl.innerHTML = log;
    logEl.style.backgroundColor = value;
});     
// ----------------------------
// - 47도도부현
// JISコードに対応した都道府県の連想配列
const PREF_LIST = [
    { value:  1, name: '北海道'   },
    { value:  2, name: '青森県'   },
    { value:  3, name: '岩手県'   },
    { value:  4, name: '宮城県'   },
    { value:  5, name: '秋田県'   },
    { value:  6, name: '山形県'   },
    { value:  7, name: '福島県'   },
    { value:  8, name: '茨城県'   },
    { value:  9, name: '栃木県'   },
    { value: 10, name: '群馬県'   },
    { value: 11, name: '埼玉県'   },
    { value: 12, name: '千葉県'   },
    { value: 13, name: '東京都'   },
    { value: 14, name: '神奈川県' },
    { value: 15, name: '新潟県'   },
    { value: 16, name: '富山県'   },
    { value: 17, name: '石川県'   },
    { value: 18, name: '福井県'   },
    { value: 19, name: '山梨県'   },
    { value: 20, name: '長野県'   },
    { value: 21, name: '岐阜県'   },
    { value: 22, name: '静岡県'   },
    { value: 23, name: '愛知県'   },
    { value: 24, name: '三重県'   },
    { value: 25, name: '滋賀県'   },
    { value: 26, name: '京都府'   },
    { value: 27, name: '大阪府'   },
    { value: 28, name: '兵庫県'   },
    { value: 29, name: '奈良県'   },
    { value: 30, name: '和歌山県' },
    { value: 31, name: '鳥取県'   },
    { value: 32, name: '島根県'   },
    { value: 33, name: '岡山県'   },
    { value: 34, name: '広島県'   },
    { value: 35, name: '山口県'   },
    { value: 36, name: '徳島県'   },
    { value: 37, name: '香川県'   },
    { value: 38, name: '愛媛県'   },
    { value: 39, name: '高知県'   },
    { value: 40, name: '福岡県'   },
    { value: 41, name: '佐賀県'   },
    { value: 42, name: '長崎県'   },
    { value: 43, name: '熊本県'   },
    { value: 44, name: '大分県'   },
    { value: 45, name: '宮崎県'   },
    { value: 46, name: '鹿児島県' },
    { value: 47, name: '沖縄県'   }
];
// select要素を参照
const selectElement = document.querySelector('#pref');

// option要素の初期表示を作成
let optionString = '<option value="">選択ください</option>';

// option要素を配列から作成
PREF_LIST.forEach((item) => {
    // 都道府県ごとにvalueとnameを反映
    optionString += `<option value="${item.value}">${item.name}</option>`;
});
// option要素をselect要素内に追加
selectElement.innerHTML = optionString;

// 変更時のイベント
selectElement.addEventListener('change', (event) => {
    // 現在の値を取得
    const value = event.target.value;
    // メッセージを作成
    const message = value === '' ? '選択されていません' : `選択されているのは ${value} です`;
    // 画面に表示
    document.querySelector('.log').innerHTML = message;
});
// ----------------------------
// - 폼의 송신시의 처리
//   송신전에 처리를 추가/재확인
//   submit : 폼의 송신시의 이벤트
// form要素の参照
const formElement = document.querySelector('form');
// 送信イベントを監視
formElement.addEventListener('submit', handleSubmit);

// 送信イベント発生時
function handleSubmit(event) {
    // confirmでユーザーに確認する
    const isYes = confirm('この内容で送信していいですか？');

    // 「いいえ」を選択した場合
    if (isYes === false) {
        // 挙動をキャンセル
        event.preventDefault();
    }
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - js에서 CSS Transitions, CSS Animations사용
//   CSS Transitions와 CSS Animations은 셀렉터의 상태변환에
//   반응해서 발생. 예) class지정에 임의의 클래스명의 존재유무가 
//   변하는 것이 트리거로 작동해서 발생
// ----------
// - CSS Transitions의 종료시에 처리
//   transitionend 이벤트
//   CSS의 Transition완료후에 발생
// ----------
// HTML
// &lt;div class="target"&gt;&lt;/div&gt;
// 
// &lt;div class="ui"&gt;
//   &lt;button&gt;
//     トランジションを確認する
//   &lt;/button&gt;
// 
//   &lt;div class="log"&gt;ログ表示エリア&lt;/div&gt;
// &lt;/div&gt;
// ----------
// CSS
// button {
//     background-color: rgba(0, 0, 0, 0.1);
//     padding: 10px;
//     color: #fff;
//     cursor: pointer;
//   }
//   
//   .target {
//     width: 100px;
//     height: 100px;
//     display: block;
//     position: absolute;
//     background: white;
//     top: 150px;
//     transition: all 2s;
//   }
//   
//   .target.state-show {
//     width: 400px;
//   }
//   
//   .centering {
//     position: relative;
//   }
//   
//   .ui {
//     position: absolute;
//     bottom: 100px;
//   }
//   
//   .log {
//     border: 1px solid white;
//     padding: 0 0.5em;
//   }
// ----------
// JS
const button = document.querySelector('button');
button.addEventListener('click', handleClick);

function handleClick() {
    const element = document.querySelector('.target');
    if (element.classList.contains('state-show') === false) {
        element.classList.add('state-show');
    } else {
        element.classList.remove('state-show');
    }
}

// CSS Transition のイベント
document.querySelector('.target')
        .addEventListener('transitionend', (event) => {
    document.querySelector('.log').innerHTML = 
        'transitionend 発生 : ' + new Date().toLocaleTimeString();
});
// ----------------------------
// - CSS Animations의 종료시에 처리
//   animationstart 이벤트
//   animationiteration 이벤트 : 애니메이션에서 반복이 발생했을 때의 이벤트
//   animationend 이벤트
// ----------
// HTML
// &lt;div class="rect"&gt;
// &lt;/div&gt;
// 
// &lt;div class="ui"&gt;
//   &lt;label&gt;
//     &lt;input type="checkbox" id="checkbox"/&gt;
//     アニメーションを確認する
//   &lt;/label&gt;
// 
//   &lt;div class="log"&gt;ログ表示エリア&lt;/div&gt;
// &lt;/div&gt;
// ----------
// CSS
// .rect {
//     display: block;
//     position: absolute;
//     background-size: contain;
//     top: 150px;
//     
//     width: 100px;
//     height: 100px;
//     background: url('images/loading.svg');
// }
// 
// .rect.state-show {
//   animation: infinite 1s rotate linear;
// }
// 
// @keyframes rotate {
//   0% {
//     transform: rotate(0deg);
//   }
//   100% {
//     transform: rotate(360deg);
//   }
// }
// 
// .centering {
//   position: relative;
// }
// 
// .ui {
//   position: absolute;
//   bottom: 100px;
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (element.classList.contains('state-show') === true) {
        element.classList.remove('state-show');
    } else {
        element.classList.add('state-show');
    }
});
const targetEl = document.querySelector('.rect');
targetEl.addEventListener('animationstart', (event) => {
    document.querySelector('.log').innerHTML = 'animationstart 発生 : ' + new Date().toLocaleTimeString();
});
targetEl.addEventListener('animationiteration', (event) => {
    document.querySelector('.log').innerHTML = 'animationiteration 発生 : ' + new Date().toLocaleTimeString();
});
targetEl.addEventListener('animationend', (event) => {
    document.querySelector('.log').innerHTML = 'animationend 発生 : ' + new Date().toLocaleTimeString();
});
// ----------------------------
// - 애니메이션을 위해 WEB Animations API를 사용
//   자유도 높은 애니메이션
//   js메인으로 모션을 작성
//   요소.animate(오브젝트, 오브젝트)
//   CSS Transitions와 CSS Animations의 경우에는 CSS에 모션을
//   사전에 등록할 필요가 있음.
//   WEB Animations API는 js만으로 관리 가능하고 종료시의 판정이 쉽다.
//   1번인수로 시작값과 종료값을 포함하는 오브젝트를, 
//   2번인수에는 애니메이션의 속성을 포함하는 오브젝트를 지정.
// ----------
// HTML
// &lt;!-- Web Animations API未対応ブラウザーのためのPolyfill --&gt;
// &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/web-animations/2.3.1/web-animations.min.js" defer&gt;&lt;/script&gt;
// &lt;script src="main.js" defer&gt;&lt;/script&gt;
// ----------
// CSS
// body {
//     margin: 0;
//     padding: 0;
//     display: flex;
//     justify-content: center;
//     overflow: hidden;
// }
// .container {
//     position: relative;
//     width: 940px;
//     height: 520px;
//     background: rgba(0, 0, 0, 0.5);
// }
// .rect {
//     width: 100px;
//     height: 100px;
//     display: block;
//     position: absolute;
//     background: white;
//     top: 200px;
// }
// ----------
// JS
// 要素を取得
const element = document.querySelector('.rect');
element.animate(
    {
        transform: [
            'translateX(0px) rotate(0deg)', // 開始値
            'translateX(800px) rotate(360deg)' // 終了値
        ]
    },
    {
        duration: 3000, // ミリ秒指定
        iterations: Infinity, // 繰り返し回数
        direction: 'normal', // 繰り返し挙動
        easing: 'ease' // 加減速種類
    }
);
// ----------------------------
// - 요소의 크기 변경
//   CSS의 transform프로퍼티
//   API의 scale()
// ----------
// - CSSTransitions으로 구현
// ----------
// CSS
// .rect {
//   width: 50px;
//   height: 50px;
//   display: block;
//   position: absolute;
//   background: white;
//   top: 150px;
//   transition: all 0.5s;
// }
// 
// .rect.state-show {
//   transform: scale(4);
// }
// 
// .centering {
//   position: relative;
// }
// 
// .ui {
//   position: absolute;
//   bottom: 100px;
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (element.classList.contains('state-show') === true) {
        element.classList.remove('state-show');
    } else {
        element.classList.add('state-show');
    }
});
// ----------------------------
// - Web API로 구현
// ----------
// CSS
// .rect {
//   width: 50px;
//   height: 50px;
//   display: block;
//   position: absolute;
//   background: white;
//   top: 150px;
// }
// 
// .centering {
//   position: relative;
// }
// 
// .ui {
//   position: absolute;
//   bottom: 100px;
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (event.target.checked === true) {
        element.animate(
        {
            transform: [
                'scale(1)', // 開始値
                'scale(5)' // 終了値
            ]
        },
        {
          duration: 500, // ミリ秒指定
          fill: 'forwards', // 終了時にプロパティーを保つ
          easing: 'ease' // 加減速種類
        }
    );
    } else {
        element.animate(
        {
            transform: [
                'scale(5)', // 開始値
                'scale(1)' // 終了値
            ]
        },
        {
          duration: 500, // ミリ秒指定
          fill: 'forwards', // 終了時にプロパティーを保つ
          easing: 'ease' // 加減速種類
        }
        );
    }
});
// ----------------------------
// - 요소를 이동
//   CSS의 translate():요소의 수직,수평이동 가능
// ----------
// - CSSTransitions으로 구현
// ----------
// HTML
// &lt;div class="rect"&gt;&lt;/div&gt;
// ----------
// CSS
// .rect {
//   width: 100px;
//   height: 100px;
//   display: block;
//   position: absolute;
//   background: white;
//   top: 150px;
//   transition: all 3s;
// }
// 
// .rect.state-show {
//   transform: translate(300px, 0px);
// }
// 
// .centering {
//   position: relative;
// }
// 
// .ui {
//   position: absolute;
//   bottom: 100px;
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (element.classList.contains('state-show') === true) {
        element.classList.remove('state-show');
    } else {
        element.classList.add('state-show');
    }
});
// ----------
// - Web API로 구현
// ----------
// CSS
// .rect {
//   width: 100px;
//   height: 100px;
//   display: block;
//   position: absolute;
//   background: white;
//   top: 150px;
// }
// 
// .centering {
//   position: relative;
// }
// 
// .ui {
//   position: absolute;
//   bottom: 100px;
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (event.target.checked === true) {
        element.animate(
            {
                transform: [
                    'translateX(0px)', // 開始値
                    'translateX(300px)' // 終了値
                ]
            },
            {
                duration: 3000, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    } else {
        element.animate(
            {
                transform: [
                    'translateX(300px)', // 開始値
                    'translateX(0px)' // 終了値
                ]
            },
            {
                duration: 3000, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    }
}); 
// ----------------------------
// - 요소의 투명도를 변경
//   CSS의 opacity프로퍼티 1:불투명, 0:완전투명
// ----------
// - CSSTransitions으로 구현
// ----------
// CSS
// .rect.state-show {
//     opacity: 0.5;
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (element.classList.contains('state-show') === true) {
        element.classList.remove('state-show');
    } else {
        element.classList.add('state-show');
    }
});
// ----------
// - Web API로 구현
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (event.target.checked === true) {
        element.animate(
            {
                opacity: [
                    1.0, // 開始値
                    0.5 // 終了値
                ]
            },
            {
                duration: 500, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    } else {
        element.animate(
            {
                opacity: [
                    0.5, // 開始値
                    1.0 // 終了値
                ]
            },
            {
                duration: 500, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    }
});
// ----------------------------
// - 요소의 명도를 변화
//   CSS의 filter프로퍼티에 brightness(숫자)를 사용
//   숫자 > 100% => 밝게
//   숫자 < 100% => 어둡게
// ----------
// - CSSTransitions으로 구현
// ----------
// CSS
// .rect {
//     display: block;
//     position: absolute;
//     top: 50px;
//     filter: brightness(100%);
//     transition: all 0.5s;
// }
// 
// .rect.state-show {
//     filter: brightness(300%);
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (element.classList.contains('state-show') === true) {
        element.classList.remove('state-show');
    } else {
        element.classList.add('state-show');
    }
});
// ----------
// - Web API로 구현
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (event.target.checked === true) {
        element.animate(
            {
                filter: [
                    'brightness(100%)', // 開始値
                    'brightness(300%)' // 終了値
                ]
            },
            {
                duration: 500, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    } else {
        element.animate(
            {
                filter: [
                    'brightness(300%)', // 開始値
                    'brightness(100%)' // 終了値
                ]
            },
            {
                duration: 500, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    }
});
// ----------------------------
// - 요소의 채도를 변경
//   CSS의 filter프로퍼티에 grayscale(숫자)를 사용
//   숫자 = 0%   => 통상
//   숫자 = 100% => 모노크로
// ----------
// - CSSTransitions으로 구현
// ----------
// CSS
// .rect {
//     display: block;
//     position: absolute;
//     top: 50px;
//     filter: grayscale(0%);
//     transition: all 0.5s;
// }
// .rect.state-show {
//     filter: grayscale(100%);
// }
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (element.classList.contains('state-show') === true) {
        element.classList.remove('state-show');
    } else {
        element.classList.add('state-show');
    }
});
// ----------
// - Web API로 구현
// ----------
// JS
document.querySelector('#checkbox').addEventListener('change', (event) => {
    const element = document.querySelector('.rect');
    if (event.target.checked === true) {
        element.animate(
            {
                filter: [
                    'grayscale(0%)', // 開始値
                    'grayscale(100%)' // 終了値
                ]
            },
            {
                duration: 500, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    } else {
        element.animate(
            {
                filter: [
                    'grayscale(100%)', // 開始値
                    'grayscale(0%)' // 終了値
                ]
            },
            {
                duration: 500, // ミリ秒指定
                fill: 'forwards', // 終了時にプロパティーを保つ
                easing: 'ease' // 加減速種類
            }
        );
    }
);
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - requestAnimationFrame()을 사용
//   requestAnimationFrame(함수)
//   시간경과로 호출할 함수를 등록
//   화면을 다시 그리기전에 함수호추를 요구하는 명령
//   읿반적인 디스플레이는 1초에 60회 화면을 갱신 => 약 16미리초
//   setTimeout(), setInterval()에서 이것보다 작은 시간을 지정해도
//   화면에 표시되지 않는 쓸모없는 처리가 발생할 가능성이 있다.
//   웹애니메이션에서는 requestAnimationFrame()를 사용하는 것으로 보다
//   부드럽고 효율적으로 표시가 가능.
//   requestAnimationFrame()은 한번만 호출됨
//   cancelAnimationFrame()로 호출을 캔슬
//   requestID라는 ID(수치)를 반환.
tick();
var requestId = 0; 
function tick(){
    requestId = requestAnimationFrame(tick);
    // 애니메이션 처리를 기술
    console.log(requestId);
}
cancelAnimationFrame(requestId);
// ----------------------------
// var
// var name = 'bathingape' => OK
// var name = 'javascript' => OK
// ----------
// let 과 const 의 차이점:immutable
// let 은 변수에 재할당이 가능
// const는 변수 재선언, 변수 재할당 모두 불가능
// ----------------------------
// 호이스팅(Hoisting)이란, var 선언문이나 function 선언문 등을 
// 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다.
// var 로 선언된 변수와는 달리 let 로 선언된 변수를 선언문 이전에 
// 참조하면 참조 에러(ReferenceError)가 발생
// => 변수 선언에는 기본적으로 const를 사용하고, 
//    재할당이 필요한 경우에 한정해 let 을 사용하는 것이 좋다.
// const 를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전.
// 재할당이 필요한 경우에 한정해 let 을 사용.  변수의 스코프는 최대한 좁게.
// 재할당이 필요 없는 상수와 객체에는 const로.
// ----------------------------
// - requestAnimationFrame()으로 HTML요소를 움직이게 함
//   요소의 style속성을 사용.
//   style속성의 대부분을 단위를 필요로 하기 때문에 주의.
// ----------
// HTML
// &lt;div class="stoker"&gt;
// 👻
// &lt;/div&gt;
// ----------
// CSS
// .stoker {
//   position: fixed;
//   top: 0;
//   left: 0;
//   will-change: transform;
//   font-size: 5rem;
// }
// ----------
// JS
// マウスストーカーの要素を取得
const el = document.querySelector('.stoker');

// マウス座標
let mouseX = 0;
let mouseY = 0;
// ストーカーの座標
let currentX = 0;
let currentY = 0;
// マウス移動時
document.body.addEventListener('mousemove', (event) => {
    // マウス座標を保存
    mouseX = event.clientX;
    mouseY = event.clientY;
});

tick();
function tick() {
    // アニメーションフレームを指定
    requestAnimationFrame(tick);

    // マウス座標を遅延してストーカーの座標へ反映する
    currentX += (mouseX - currentX) * 0.1;
    currentY += (mouseY - currentY) * 0.1;

    // ストーカーの要素へ反映
    el.style.transform = `translate(${currentX}px, ${currentY}px)`;
}
// ----------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 191
// - 화상을 스크립트로 읽기
//   src
//   HTML내에 img요소를 배치하고, 참조시 src속성에 문자열을 대입.
//   임의의 타이밍에 화상을 읽기 가능.
// ----------
// HTML
// ----------
// &lt;img id="myImageA" /&gt;
// &lt;img id="myImageB" /&gt;
// ----------
// JS
// ----------
const imgA = document.querySelector('#myImageA');
imgA.src = 'images/photo_a.jpg';

const imgB = document.querySelector('#myImageB');
imgB.src = 'images/photo_b.jpg';
// ----------------------------
// - 화상읽기 완료후에 처리실시
//   onload
// ----------
// HTML
// ----------
// &lt;img id="myImage" width="640" height="426"/&gt;
// ----------
// CSS
// ----------
// img.loading {
//     background-color: black;
//     background-image: url("images/loading.gif");
//     background-position: center;
//     background-repeat: no-repeat;
// }
// ----------
// JS
// ----------
const img = document.querySelector('#myImage');
img.onload = () => {
    // 画像の読み込み完了後の処理
    img.classList.remove('loading');
};
img.src = 'images/photo.jpg';
img.classList.add('loading');
// ----------------------------
// - 웹페이지내의 화상의 읽기를 지연시킴
//   DOMContentLoaded이벤트발생시에 img요소를 검색해서,
//   data-src속성의 값을 Map에 저장한 후에 클리어한다.
//   다음에 필요해시점에 Map에서 src속성을 가져온다.   
// ----------------------------
// ----------
// HTML
// ----------
// &lt;p&gt;
//    &lt;img data-src="images/photo_a.jpg" width="320" height="214"/&gt;
//    &lt;img data-src="images/photo_b.jpg" width="320" height="214"/&gt;
// &lt;/p&gt;
// &lt;button class="btn"&gt;読み込む&lt;/button&gt;
// ----------
// JS
// ----------
// 保存用にMapを用意
const srcMap = new Map();
window.addEventListener('DOMContentLoaded', () => {
    // img要素を一括で参照
    const imgs = document.querySelectorAll('img');
    imgs.forEach((img) => {
        // 各img要素のdata-src属性をMapに保存
        srcMap.set(img, img.dataset.src);
        // 遅延読み込みのため空にしておく
        img.removeAttribute('src');
    });
});

const btn = document.querySelector('.btn');
btn.addEventListener('click', () => {
     // img要素を一括で参照
    const imgs = document.querySelectorAll('img');
    imgs.forEach((img) => {
        // 保存していたMapからsrcを割り当てる
        const source = srcMap.get(img);
        img.src = source;
    });
});
// ----------------------------
// - Base64의 화상을 표시
//   Base64의 화상은 문자열로 화상을 관리가능.
//   Base64화상의 문자열을 src속성에 대입
//   Base64문자열은 선두가 
//   [data:image/jpeg;base64]나 
//   [data:image/png;base64]로 되어있다.
// ----------
// HTML
// ----------
// &lt;img id="myImage" /&gt;
// ----------
// JS
// ----------
const img = document.querySelector('#myImage');
img.src = 'data:image/jpeg;base64,/9j/4AAQSkZJR......';
// ----------------------------
// - 스크립트로 img요소를 추가
//   new image() => img요소의 인스턴스를 생성
//   document.createElement('img')도 같은 역할
//   document.body.appendChild()로 추가.
// ----------
// HTML
// ----------
// &lt;div class="container"&gt;&lt;/div&gt;
// ----------
// CSS// 
// ----------
// .container {
//     display: flex;
//     flex-wrap: wrap;
//     justify-content: space-between;
// }
// .container img {
//     width: 250px;
//     height: 180px;
// }
// ----------
// JS
// ----------
// 挿入したい要素の参照を取得
const container = document.querySelector('.container');
for (let i = 0; i < 10; i++) {
    // Imageオブジェクトを作る
    const img = document.createElement('img');
    // src属性にファイルパスを指定
    img.src = `images/photo-${i}.jpg`;
    // 要素に挿入する
    container.appendChild(img);
}
// ----------------------------
// - 음성사용
//   src      : 리소스지정
//   controls : 컨트롤바 표시
//   loop     : 루프지정
//   preload  : 프리로드 종류를 지정
//    => auto     : 자동
//    => metadata : 메타데이터만을 읽음
//    => none     : 자동읽기안함
// ----------
// HTML
// ----------
// &lt;h2&gt;コントロールあり&lt;/h2&gt;
// &lt;audio src="music.mp3" controls&gt;&lt;/audio&gt;
// &lt;h2&gt;プリロードなし&lt;/h2&gt;
// &lt;audio src="music.mp3" controls preload="none"&gt;&lt;/audio&gt;
// &lt;h2&gt;ループ再生&lt;/h2&gt;
// &lt;audio src="music.mp3" controls loop&gt;&lt;/audio&gt;
// ----------------------------
// - 음성을 js로 제어
//   play()  : 반환값 promise
//   pause()
// - 음성의 재생위치 변경
//   currentTime : 재생헤드의 값, 읽기쓰기 가능, 초
//   duration    : 음성의 길이, 읽기전용, 초
//   음성의 메타정보를 전부읽기전까진 길이는 취득안됨
//   그래서 loadedmetadata이벤트를 감시 => 메타정보의 읽기완료를 나타냄 
// - 음성의 볼륨조절
//   volume : 0.0 ~ 1.0
//   muted  : 뮤트인지 아닌지
// ----------
// HTML
// ----------
// &lt;audio id="myAudio" src="assets/music.mp3" controls&gt;&lt;/audio&gt;
// &lt;/div&gt;
// &lt;div&gt;
//     &lt;button id="btnPlay"&gt;再生&lt;/button&gt;
//     &lt;button id="btnPause"&gt;停止&lt;/button&gt;
//     &lt;button id="btnSkip"&gt;半分飛ぶ&lt;/button&gt;
//     &lt;button id="btnVMin"&gt;볼륨Min&lt;/button&gt;
//     &lt;button id="btnVMax"&gt;볼륨Max&lt;/button&gt;
//     &lt;button id="btnMute"&gt;MUTE&lt;/button&gt; 
// &lt;/div&gt;
// ----------
// CSS
// ----------
// button {
//     background-color: rgba(0, 0, 0, 0.1);
//     padding: 10px;
//     color: #fff;
//     cursor: pointer;
// }
// ----------
// JS
// ----------
const audio = document.querySelector('#myAudio');
audio.addEventListener('loadedmetadata', () => {
    console.log(audio.duration); // 音声の長さ(秒) => 60.048
});
document.querySelector('#btnPlay').addEventListener('click', () => {
    audio.play();
});
document.querySelector('#btnPause').addEventListener('click', () => {
    audio.pause();
});
document.querySelector('#btnSkip').addEventListener('click', () => {
    audio.currentTime = 30;
});
document.querySelector('#btnVMin').addEventListener('click', () => {
    audio.volume = 0.0;
});
document.querySelector('#btnVMax').addEventListener('click', () => {
    audio.volume = 1.0;
});
document.querySelector('#btnMute').addEventListener('click', () => {
    audio.muted = true;
});
// ----------------------------
// - 음성읽기 (Web Audio API)
//   동시에 복수의 파일 재생
//   사운드비쥬얼라이저 작성
//   오디오정보를 서버에 전송
// ----------
// HTML 
// ----------
// &lt;button onclick="loadAndPlay()"&gt;再生する&lt;/button&gt;
// &lt;button onclick="stop()"&gt;停止する&lt;/button&gt;
// ----------   
// JS
// ----------
loadAndPlay();

let source;

// 再生させたいとき
async function loadAndPlay() {
    const context = new AudioContext();

    // サウンドファイルを読み込む
    const data = await fetch('assets/music.mp3');
    // ArrayBuffer として扱う
    const buffer = await data.arrayBuffer();
    // オーディオデータとして変換する
    const decodedBuffer = await context.decodeAudioData(buffer);

    // ソースを作成
    source = context.createBufferSource();
    // ソースにオーディオデータを割り当てる
    source.buffer = decodedBuffer;
    // スピーカーをつなげる
    source.connect(context.destination);
    // 再生を開始する
    source.start(0);
}

// 停止させたいとき
function stop() {
    // 再生を停止する
    source.stop();
}
// ----------------------------
// - 동영상을 재생
//   src
//   controls
//   autoplay
//   loop
//   preload
//    => auto     : 자동
//    => metadata : 메타데이터만을 읽음
//    => none     : 자동읽기안함
//   playsinline : 인라인 재생을 지정, 동영상에 웹페이지에 묻어서 재생
//   width, height 지정이 없으면 동영상 사이즈에 맞춰짐
//   poster : 썸네일지정
// ----------
// HTML
// ----------
// &lt;video src="sample.mp4" controls autoplay loop preload="auto"&gt;&lt;/video&gt;
// &lt;video src="sample.mp4" autoplay playsinline muted&gt;&lt;/video&gt;
// &lt;video src="sample.mp4" poster="photo.jpg"&gt;&lt;/video&gt;
// ----------------------------
// - 동영상을 JS로 제어
//   play()
//   pause()
// ----------
// JS
// ----------
const video = document.querySelector('#myVideo');
document.querySelector('#btnPlay').addEventListener('click', () => {
    video.play();
});
document.querySelector('#btnPause').addEventListener('click', () => {
    video.pause();
});
// ----------------------------
// - 카메라사용
//   getUserMedia()
//   video요소의 srcObject속성에 웹카메라의 스트림을 지정해서 표시.
//   video요소에 autoplay속성을 지정. 지정안하면 브라우저에 따라 지연됨.
// ----------
// HTML
// ----------
// &lt;button onclick="loadAndPlay()"&gt;再生する&lt;/button&gt;
// &lt;button onclick="stop()"&gt;停止する&lt;/button&gt;
// &lt;video id="myVideo" width="640" height="480" autoplay&gt;&lt;/video&gt;
// ----------
// CSS
// ----------
// button {
//     margin-bottom: 10px;
//     background-color: rgba(0, 0, 0, 0.1);
//     padding: 10px;
//     color: #fff;
//     cursor: pointer;
// }
// #log {
//     font-size: 48px;
// }
// #myVideo {
//     filter: grayscale(100);
// }
// ----------
// JS
// ----------
let stream;

async function loadAndPlay() {
    const video = document.getElementById('myVideo');
    stream = await getDeviceStream({
        video: { width: 640, height: 320 },
        audio: false
    });
    video.srcObject = stream;
}

function stop() {
    const video = document.getElementById('myVideo');
    const tracks = stream.getTracks();

    tracks.forEach((track) => {
        track.stop();
    });

    video.srcObject = null;
}

function getDeviceStream(option) {
    if ('getUserMedia' in navigator.mediaDevices) {
        return navigator.mediaDevices.getUserMedia(option);
    } else {
        return new Promise(function(resolve, reject) {
        navigator.getUserMedia(option, resolve, reject);
        });
    }
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 204
// - SVG 
//  : 스케러블 벡터 그래픽
//    DOM으로써 조작가능
//    2차원의 그래픽을 XML로 기술하기 위한 언어.
// ----------
// HTML에 직접기술
// ----------
// &lt;svg xmlns="http://www.w3.org/2000/svg"
// viewbox="0 0 540 540" 
// width="500"
// height="500"&gt;
// &lt;path fill-opacity="0"
//      stroke="#999999"
//      d="M25, 349
//         c57, -84, 138, -176, 228, -166
//         c111, 11, 120, 200, 260, 81"&gt;
// &lt;/svg&gt;
// ----------------------------
// - SVG동적생성
//   document.createElementNS('http://www.w3.org/2000/svg', SVG요소명)
//   HTML과 SVG는 엄밀히 이름공간이 다르기 때문에 1번 인수처럼 지정해야함.
// ----------
// HTML
// ----------
// &lt;main class="centering"&gt;
// &lt;div&gt;
//   &lt;svg viewBox="0 0 200 200"
//        width="200" 
//        height="200"
//        id="mySvg"&gt;
//   &lt;/svg&gt;Z
// &lt;/div&gt;
// &lt;/main&gt;
// ----------
// JS
// ----------
const myCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');

myCircle.setAttribute('cx', '100');
myCircle.setAttribute('cy', '100');
myCircle.setAttribute('r', '100');
myCircle.setAttribute('fill', '#FFFF8D');

const mySvg = document.querySelector('#mySvg');
mySvg.appendChild(myCircle);
// ----------------------------
// - SVG요소의 스타일변경
//   요소.setAttribute(속성명, 값)
// ----------
// HTML
// ----------
// &lt;svg viewBox="0 0 200 200"
//            width="200" height="200"&gt;
//         &lt;circle id="myCircle1"
//                 cx="100" 
//                 cy="100"
//                 stroke-width="2"
//                 stroke="#FFFFFF"
//         /&gt;
// &lt;/svg&gt;
// ----------
// JS
// ----------
const circle1 = document.querySelector('#myCircle1');
circle1.setAttribute('r', '100'); // 半径を指定
circle1.setAttribute('fill', '#FFFF8D'); // 塗りの色を指定
circle1.setAttribute('fill-opacity', '0.5'); // 塗りの透明度を指定
// ----------------------------
// - SVG요소를 마우스로 조작
// ----------
// JS
// ----------
const circle = document.querySelector('#myCircle');
circle.addEventListener('click', (event) => {
    alert('クリックされました');
});
// ----------------------------
// - SVG요소에 애니메이션 추가
//   requestAnimationFrame()사용
// ----------
// HTML
// ----------
// &lt;svg viewBox="0 0 200 200"
// width="200" height="200"&gt;
// &lt;circle id="myCircle"
//      cx="100" cy="100"
//      r="95"
//      fill="#BBDEFB"/&gt;
// &lt;/svg&gt;
// ----------
// JS
// ----------
const myCircle = document.querySelector('#myCircle');
let time = 0;

animate();

function animate() {
    // 時間で変化
    time += 0.1;
    // 色を変化
    myCircle.style.fill = `hsl(0, 100%, ${time}%)`;
    // 目標値に達するまで繰り返す
    if (time < 50) {
        requestAnimationFrame(animate);
    }
}
// ----------------------------
// - SVG로 그림 그래픽을 다운로드하게 함
//   document.querySelector()로 선택
//   -> outerHTML프로퍼티로 문자열을 취득.
// ----------
// JS
// ----------
// 保存ボタンをクリックしたときの処理
document.querySelector('#btnSave').addEventListener('click', saveFile);
// ファイルとして保存
function saveFile() {
    // ファイル名
    const fileName = `mySvg.svg`;
    // SVG要素を取得
    const content = document.querySelector('#mySvg').outerHTML;
    // データを準備
    const dataUrl = 'data:image/svg+xml,\n' + encodeURIComponent(content);

    // BOMの文字化け対策
    const bom = new Uint8Array([0xef, 0xbb, 0xbf]);
    const blob = new Blob([bom, content], { type: 'text/plain' });

    if (window.navigator.msSaveBlob) {
        // for IE
        window.navigator.msSaveBlob(blob, fileName);
    } else if (window.URL && window.URL.createObjectURL) {
        // for Firefox, Chrome, Safari
        const a = document.createElement('a');
        a.download = fileName;
        a.href = window.URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    } else {
        // for Safari
        window.open(dataUrl, '_blank');
    }
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 캔버스요소 취급
//   canvas.getContext('2d') => 캔버스로부터 명령군을 취득
//   context.fillRect(x,y,폭,높이) => 지정영역을 채색
//   캔버스는 비트맵베이스의 그래픽
//   일러스트등의 그래픽스 => SVG
//   이미지 가공등 => canvas 적합
// ----------
// HTML
// ----------
// &lt;main class="centering"&gt;
//   &lt;canvas id="my-canvas"
//              width="400"
//              height="400"&gt;
//   &lt;/canvas&gt;
// &lt;/main&gt;
// ----------
// JS
// ----------
// キャンバス要素の参照を取得
const canvas = document.querySelector('#my-canvas');
// コンテキストを取得
const context = canvas.getContext('2d');
// 図形を描く
context.fillRect(0, 0, 100, 100);
// ----------------------------
// - 캔버스 색칠과 선
//   context.fillStyle프로퍼티
//   context.strokeRect(x,y,폭,높이) => 경계선을 그림
//   context.fillRect(x,y,폭,높이) => 색칠
//   fillRect()를 실행하기 전에는 fillStyle를 설정할 필요가 있다. 순서에 주의
// ----------
// - 색칠
// ----------
// キャンバス要素の参照を取得
const canvas = document.querySelector('#my-canvas');
// コンテキストを取得
const context = canvas.getContext('2d');
// 塗りの色を指定
context.fillStyle = 'red';
// 矩形を描く
context.fillRect(0, 0, 100, 100);
// ----------
// - 선
// ----------
// キャンバス要素の参照を取得
const canvas = document.querySelector('#my-canvas');
// コンテキストを取得
const context = canvas.getContext('2d');
// 線の幅を指定
context.lineWidth = 3;
// 選の色を指定
context.strokeStyle = 'red';
// 矩形を線で描く
context.strokeRect(0, 0, 100, 100);
// ----------------------------
// - 캔버스에 이미지 출력
//   context.drawImage(image,dx,dy)
//   화상은 Image오브젝트를 사용해서 그림.
//   Image오브젝트의 읽기가 끝나지 않으면 캔버스에 그리지 않기
//   때문에, 그리기전에 onload로 읽기를 사전에 끝냄.
// ----------
// JS
// ----------
// キャンバス要素の参照を取得
const canvas = document.querySelector('#my-canvas');
// コンテキストを取得
const context = canvas.getContext('2d');

// Imageインスタンスを作成
const img = new Image();
// 画像読み込み後の処理
img.onload = () => {
    // コンテキストを通してcanvasに描く
    context.drawImage(img, 0, 0);
};
// 画像を読み込みを開始する
img.src = 'sample.jpg';
// ----------------------------
// - 캔버스의 화소정보 취득
//   context.getImageData(dx, dy, width, height)
//   => 지정영역의 픽셀정보를 취득
//      리턴:ImageData오브젝트
// ----------
// JS
// ----------
// キャンバス要素の参照を取得
const canvas = document.querySelector('#my-canvas');
// コンテキストを取得
const context = canvas.getContext('2d');
// 塗りの色を指定
context.fillStyle = 'red';
// 矩形を描く
context.fillRect(0, 0, 100, 100);
// 画素情報を得る
const imageData = context.getImageData(0, 0, 100, 100);
console.log(imageData.data); // 画素配列
// ----------------------------
// - 화상의 RGBA값 취득
//   getImageData()
//   마우스의 좌표취득 -> 좌표의 RGBA값 취득
// ----------
// JS
// ----------
// キャンバス要素の参照を取得
const canvas = document.querySelector('#my-canvas');
// コンテキストを取得
const context = canvas.getContext('2d');
// Imageインスタンスを作成
const img = new Image();
// 画像読み込み後の処理
img.onload = () => {
    // コンテキストを通してcanvasに描く
    context.drawImage(img, 0, 0);
};
// 画像を読み込みを開始する
img.src = 'sample.jpg';

// マウスが動いたとき
canvas.addEventListener('mousemove', (event) => {
    // マウスの座標を取得
    const x = event.layerX;
    const y = event.layerY;
    // ImageDataを取得
    const imageData = context.getImageData(x, y, 1, 1);
    // 画素配列を取得
    const data = imageData.data;
    const r = data[0]; // 赤
    const g = data[1]; // 緑
    const b = data[2]; // 青
    const a = data[3]; // アルファ
    // 文字列として色情報を扱う
    const color = `rgba(${r}, ${g}, ${b}, ${a})`;

    const el = document.querySelector('.log');
    // 背景色に指定
    el.style.background = color;
    // 文字として指定
    el.textContent = color;
});
// ----------------------------
// - 캔버스의 화상을 가공
//   context.putImageData(이미지데이터)
// ----------
// JS
// ----------
// キャンバス要素の参照を取得
const canvas1 = document.querySelector('#canvas-original');
// コンテキストを取得
const context1 = canvas1.getContext('2d');
// Imageインスタンスを作成
const img = new Image();
// 画像読み込み後の処理
img.onload = () => {
    // コンテキストを通してcanvasに描く
    context1.drawImage(img, 0, 0);

    // 画素情報を得る
    const imageData = context1.getImageData(0, 0, 150, 150);
    const data = imageData.data;

    const monoImageData = new ImageData(150, 150);

    const monoArr = monoImageData.data;
    for (let i = 0; i < data.length / 4; i += 1) {
        // 画素情報を取得
        const r = data[i * 4 + 0];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];

        // 平均値を求める（簡易的な計算のため）
        const color = (r + g + b) / 3;

        // 新しい配列に色を指定
        monoArr[i * 4 + 0] = color;
        monoArr[i * 4 + 1] = color;
        monoArr[i * 4 + 2] = color;
        monoArr[i * 4 + 3] = a;
    }

    // キャンバス要素の参照を取得
    const canvas2 = document.querySelector('#canvas-effected');
    // コンテキストを取得
    const context2 = canvas2.getContext('2d');
    // コンテキストに新しい画素情報を割り当てる
    context2.putImageData(monoImageData, 0, 0);
};
// 画像を読み込みを開始する
img.src = 'sample.jpg';
// ----------------------------
// - 캔버스의 화상을 DataURL으로 취득
//   canvas.toDataURL()
//   DB에 화상을 문자열로 저장할때등.
// ----------
// JS
// ----------
// キャンバス要素の参照を取得
const canvas = document.querySelector('#my-canvas');
// コンテキストを取得
const context = canvas.getContext('2d');
context.fillStyle = 'red';
context.fillRect(0, 0, 100, 100);
context.fillStyle = 'green';
context.fillRect(25, 25, 50, 50);

// Base64の文字列を得る
const data = canvas.toDataURL();
console.log(data);

// img要素に代入する
const img = document.querySelector('#my-img');
img.src = data;
// ----------------------------
// - PNG/JPEG등 다른 형식의 DataURL을 취득
//   canvas.toDataURL([형식])
//   JPEG은 배경색이 검정이 되어 투과되지 않음 주의.
//   PNG는 화질의 열화가 없다.
// ----------
// HTML
// ----------
// &lt;main class="centering"&gt;
// &lt;div class="header"&gt;
//   &lt;p&gt;Save as Image File&lt;/p&gt;
//   &lt;button id="btnJpeg"&gt;JPEG&lt;/button&gt;
//   &lt;button id="btnPng"&gt;PNG&lt;/button&gt;
//   &lt;button id="btnWebp"&gt;WebP&lt;/button&gt;
// &lt;/div&gt;
// &lt;div class="hGroup"&gt;
//   &lt;div&gt;
//     canvas要素&lt;br/&gt;
//     &lt;canvas id='myCanvas'
//             width="300"
//             height="300"&gt;
//     &lt;/canvas&gt;
//   &lt;/div&gt;
// 
//   &lt;div&gt;
//     img要素&lt;br/&gt;
//     &lt;img id='myImg'
//          width="300"
//          height="300"/&gt;
//   &lt;/div&gt;
// &lt;/div&gt;
// &lt;/main&gt;
// ----------
// CSS
// ----------
// .header button {
//     background-color: rgba(0, 0, 0, 0.1);
//     padding: 10px;
//     color: #fff;
//     cursor: pointer;
//     display: inline-block;
//     width: 200px;
// }
//   
// .hGroup {
//     display: flex;
//     justify-content: center;
// }
// ----------
// JS
// ----------
const STAGE_W = 300; // 幅
const STAGE_H = 300; // 高さ
const CENTER_X = STAGE_W / 2; // 中心X座標
const CENTER_Y = STAGE_H / 2; // 中心Y座標
const MAX = 150; // ループ回数

// 変数の初期化
const canvas = document.getElementById('myCanvas');
const context = canvas.getContext('2d');
let n = 0; // カウント

// アニメーションを開始
tick();

function tick() {
    // 描画をリセット
    context.clearRect(0, 0, STAGE_W, STAGE_H);

    // 変数
    let oldX = CENTER_X;
    let oldY = CENTER_Y;

    // 模様を描く
    for (let i = 0; i < MAX; i++) {
        context.beginPath();
        context.lineWidth = 1;
        context.strokeStyle = 'hsl(' + ((i / MAX) * 360 + n * 4000) + ', 100%, 50%)';
        context.moveTo(oldX, oldY);
        context.lineTo((oldX = CENTER_X + i * Math.cos(i + i * n)), (oldY = CENTER_Y + i * Math.sin(i + i * n)));
        context.stroke();
    }

    // カウントを更新
    n += 0.00025;

    requestAnimationFrame(tick);
}

// JPEG 画像を取得
const btnJpeg = document.querySelector('#btnJpeg');
btnJpeg.addEventListener('click', () => {
    const data = canvas.toDataURL('image/jpeg');
    cloneToImage(data);
});

// PNG 画像を取得
const btnPng = document.querySelector('#btnPng');
btnPng.addEventListener('click', () => {
    const data = canvas.toDataURL('image/png');
    cloneToImage(data);
});

// WebP 画像を取得
const btnWebp = document.querySelector('#btnWebp');
btnWebp.addEventListener('click', () => {
    const data = canvas.toDataURL('image/webp');
    cloneToImage(data);
});

// img要素にDataURLの文字列を代入
function cloneToImage(data) {
    document.querySelector('#myImg').src = data;
}
// ----------------------------
// - 캔버스에서 그린것을 다운로드할 때
//   new Blob(배열, 옵션)
//   a요소 이용.
//   화상을 toDataURL()로 Base64문자열로 취득
//   바이너리취급하기때문에 Blob오브젝트로 변환.
// ----------
// JS
// ----------
// キャンバス要素の参照を取得
const canvas1 = document.querySelector('#canvas-original');
// コンテキストを取得
const context1 = canvas1.getContext('2d');
// Imageインスタンスを作成
const img = new Image();
// 画像読み込み後の処理
img.onload = () => {
    // コンテキストを通してcanvasに描く
    context1.drawImage(img, 0, 0);

    // 画素情報を得る
    const imageData = context1.getImageData(0, 0, 150, 150);
    const data = imageData.data;

    const monoImageData = new ImageData(150, 150);

    const monoArr = monoImageData.data;
    for (let i = 0; i < data.length / 4; i += 1) {
        // 画素情報を取得
        const r = data[i * 4 + 0];
        const g = data[i * 4 + 1];
        const b = data[i * 4 + 2];
        const a = data[i * 4 + 3];

        // 平均値を求める（簡易的な計算のため）
        const color = (r + g + b) / 3;

        // 新しい配列に色を指定
        monoArr[i * 4 + 0] = color;
        monoArr[i * 4 + 1] = color;
        monoArr[i * 4 + 2] = color;
        monoArr[i * 4 + 3] = a;
    }

    // キャンバス要素の参照を取得
    const canvas2 = document.querySelector('#canvas-effected');
    // コンテキストを取得
    const context2 = canvas2.getContext('2d');
    // コンテキストに新しい画素情報を割り当てる
    context2.putImageData(monoImageData, 0, 0);
};
// 画像を読み込みを開始する
img.src = 'sample.jpg';

const btnDownload = document.querySelector('#btnDownload');
btnDownload.addEventListener('click', () => {
    // キャンバス要素の参照を取得
    const canvas2 = document.querySelector('#canvas-effected');

    // ファイルの種類とファイル名を指定
    const mimeType = 'image/png';
    const fileName = 'download.png';

    // Base64文字列を取得
    const base64 = canvas2.toDataURL(mimeType);

    // Base64文字列からUint8Arrayに変換
    const bin = atob(base64.replace(/^.*,/, ''));
    const buffer = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) {
        buffer[i] = bin.charCodeAt(i);
    }

    // Blobを作成
    const blob = new Blob([buffer.buffer], {
        type: mimeType
    });

    // 画像をダウンロードする
    if (window.navigator.msSaveBlob) {
        // for IE
        window.navigator.msSaveBlob(blob, fileName);
    } else if (window.URL && window.URL.createObjectURL) {
        // for Firefox, Chrome, Safari
        const a = document.createElement('a');
        a.download = fileName;
        a.href = window.URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    } else {
        // for Other
        window.open(base64, '_blank');
    }
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 13장
//   처리 실행 타이밍 제어
// ----------------------------
// - 일정시간 후 처리
//   setTimeout(함수, 미리초)
//   => 지정 미리초 후에 함수를 호출
//      타이머ID(수치)를 반환
//   setTimeout함수는 한번만 호출된다.
//   1. setTimer(timer1, 1000);
//      function timer() {} 
//   2. setTimer(function(){}, 1000);
//   3. setTimer(()=>{}, 1000); 
//   => 2는 this의 스코프가 바뀌는 경우가 있어 프로퍼티에 접근이 잘되지
//      않을수 있기때문에 this의 스코프가 변하지 않는 애로우함수를 이용할 것.
// ----------
// JS
// ----------
console.log('起動時の時刻', new Date().toLocaleTimeString());

setTimeout(() => {
    // 任意の処理
    console.log('setTimeout後の時刻', new Date().toLocaleTimeString());
}, 1000); // 1000ミリ秒後に実行
// ----------------------------
// - 일정시간 후의 처리를 해제
//   clearTimeout(타이머ID)
// ----------
// ----------
// JS
// ----------
const timerId = setTimeout(() => {
    // 任意の処理
}, 1000);
clearTimeout(timerId); // 해제
// ----------------------------
// - 일정시간 단위로 처리를 실시
//   setInterval(함수, 미리초)
//   웹페이지가 열려있으면 계속 실행됨.
// ----------
// JS
// ----------
console.log('起動時の時刻', new Date().toLocaleTimeString());
setInterval(() => {
    // 任意の処理
    console.log('setIntervalでの時刻', new Date().toLocaleTimeString());
}, 1000); // 1000ミリ秒後に実行
// ----------------------------
// - 해제
//   clearInterval(타이머ID)
// ----------
// JS
// ----------
const intervalId = setInterval(timer1, 1000);
let count = 0;

function timer1() {
    count += 1;
    console.log('setIntervalでの時刻', new Date().toLocaleTimeString());
    if(count === 3) {
        clearInterval(intervalId);
    }
}
// ----------------------------
// - 비동기처리를 하는 Promise사용
//   new Promise(함수)
//   => Promise인스턴스를 작성
//   Promise인스턴스.then(함수)
//   => 성공했을시의 콜백함수를 호출
//      Promise반환
//   : Promise오브젝트는 비동기처리를 다루는 기능.
//     Promise생성자의 인수로 비동기처리를 원하는 함수를 지정.
//     이 함수안에서 비동기처리의 완료로서 resolve()가 호출되는 것을 기다림.
//     then()을 써서, resolve()가 실행된 후에 계속할 처리를 기술.
// ----------
// JS
// ----------
const promise = new Promise((resolve) => {
	setTimeout(()=>{
		// resolve()를 부르면 Promise처리는 완료
		console.log('resolve()직전');
		resolve();
	}, 1000);
});

// then()로 뒤에오는 처리를 기술
promise.then(()=>{
	console.log('다음 처리');
});
// ----------
// JS
// ----------
const promise = new Promise((resolve) => {
	setTimeout(()=>{
		// resolve()는 인수로 임의의 값 설정 가능.
		// 여기서 설정한 값이 then()안의 처리에서 사용가능.
		resolve('orange');
	}, 1000);
});

// then()로 뒤에오는 처리를 기술
promise.then((value)=>{
	console.log(value);
});
// ----------------------------
// - Promise의 처리 성공, 실패시 처리실행
//   Promise인스턴스.catch(함수)
//   => 실패시의 콜백함수를 호출
//   Promise에서 실패시의 처리를 하고싶으면, 생성자의 인수에 
//   reject를 포함하는 함수를 지정.
//   reject가 실행될때에는 catch()가 호출된다.
// ----------
// JS
// ----------
const promise = new Promise((resolve, rejct) => {
	if(flag === true){
		resolve('orange');
	}else{
		reject('apple');
	}
});
promise.then((value)=>{
	console.log(value);
});
promise.catch((value)=>{
	console.log(value);
});
// => 위의 코드를 메소드 체인으로 변경
new Promise((resolve, rejct) => {
	if(flag === true){
		resolve('orange');
	}else{
		reject('apple');
	}
}).then((value)=>{
	console.log(value);
}).catch((value)=>{
	console.log(value);
});
// ----------------------------
// - Promise로 병행처리
//   all()
//   복수의 처리를 동시에 실행시켜, 모두 완료되었을때 다음 처리를
//   하기위해서는 Promise.all()를 사용.
// ----------
// JS
// ----------
// 配列を作成
const arrFunc = [];
for (let i = 0; i < 5; i++) {
	const func = (resolve) => {
		console.log(`処理${i}を開始`, new Date().toLocaleTimeString());
		// 0〜2秒ぐらいで遅延
		const delayMsec = 2000 * Math.random();

		// 遅延処理
		setTimeout(() => {
			console.log(`処理${i}が完了`, new Date().toLocaleTimeString());
			resolve();
		}, delayMsec);
	};
	// 配列に保存
	arrFunc.push(func);
}

console.log(arrFunc);

// 関数を含めた配列を、Promiseの配列に変換
const arrPromise = arrFunc.map((func) => new Promise(func));

console.log(arrPromise);

// 並列処理を実行
Promise.all(arrPromise).then(() => {
	console.log('すべての処理が完了しました');
});
// ----------------------------
// - Promise를 직렬처리
//   1. Promise만으로 구현하는 방법
//   2. await(), async()를 사용하는 방법
//   => 2가 코드가 간결해짐
// ----------
// JS - 1. Promise만으로 구현
// ----------
Promise.resolve()
	.then(
		() =>
		new Promise((resolve) => {
			setTimeout(() => {
			console.log('1つめのPromise', new Date().toLocaleTimeString());
			resolve();
			}, 1000);
		})
	)
	.then(
		() =>
		new Promise((resolve) => {
			setTimeout(() => {
			console.log('2つめのPromise', new Date().toLocaleTimeString());
			resolve();
			}, 1000);
		})
);
// ----------
// JS - 2. await(), async()로 구현
// ----------
start();

async function start() {
	await new Promise((resolve) => {
		setTimeout(() => {
			console.log('1つめのPromise', new Date().toLocaleTimeString());
			resolve();
		}, 1000);
	});

	await new Promise((resolve) => {
		setTimeout(() => {
			console.log('2つめのPromise', new Date().toLocaleTimeString());
			resolve();
		}, 1000);
	});
}
// ----------------------------
// - Promise로 동적으로 직렬처리
//   복수의 비동기처리를 순서대로 처리해, 모든 처리의 완료를 기다리고 싶을때.
//   Promise는 인스턴스화한 순간에 함수가 실행되기 때문에 Promise실행직전까지
//   인스턴스를 만들지 않는게 포인트.
// ----------
// JS
// ----------
// 配列を作成
const listFunctions = [];

// 動的に関数を追加
for (let i = 0; i < 5; i++) {
	// 1秒後に処理をする非同期関数を作成
	const func = (resolve) => {
		// setTimeoutで遅延処理
		setTimeout(() => {
			console.log(`関数${i}が完了しました`, new Date().toLocaleTimeString());
			resolve(); // Promiseを完了
		}, 1000);
	};
	// 配列に保存
	listFunctions.push(func);
}
// 配列の中身を出力
console.log(listFunctions); // 結果: [ [Function: func], ...

execute();

async function execute() {
	// 非同期処理を順番に実行
	for (let i = 0; i < listFunctions.length; i++) {
		const func = listFunctions[i];
		await new Promise(func);
	}
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 14장 : 다양한 데이터 송수신방법
// ----------------------------
// - JSON 파스
//   JSON문자열을 js오브젝트로 전개하고 싶을때
//   네트워크에서 읽어들인 JSON문자열을 다루고 싶을때
//   JSON.parse(문자열)
//   => JSON형식의 문자열을 JSON오브젝트로 변환
// ----------
// JS
// ----------
const jsonString = `{"students":40,"grade":4,"name":"1반"}`;

const data = JSON.parse(jsonString);

console.log(data);
console.log(data.students);
console.log(data.grade);
console.log(data.name);
// ----------------------------
// - 오브젝트를 JSON으로 변환
//   JSON.stringfy(obj)
// ----------
// JS
// ----------zn
const jsonObj = {a:1000, b:"안녕"};
const str = JSON.stringify(jsonObj);
console.log(str);
// ----------------------------
// - JSON변환시에 인덴트를 부여
//   JSON.stringfy(obj, null, ' ')
// ----------
// JS
// ----------
const str2 = JSON.stringify(jsonObj, null, '   ');
console.log(str2);
// ----------------------------
// - JSON변환룰 커스터마이즈
//   JSON.stringfy(obj, replacer)
//   => 오브젝트의 일부데이트를 변환해서 JSON문자열로 변환
// ----------
// JS
// ----------
const replacer = (key, value) => {
	// 수치이면 무시
	if(typeof value === 'number'){
		return undefined;;
	}
	return value;
};

const obj  = {pref:'tokyo', orange:100, flag:true, apple:300};
const str3 = JSON.stringify(obj, replacer, '  ');
console.log(str3);
// => 
// {
// 	 "pref": "tokyo",
// 	 "flag": true
// }
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - fetch()로 텍스트읽기
//   fetch(URL) => URL로부터 데이터를 취득
//   외부파일을 간단히 수신가능.
//   프로그램상에서는 데이터의 다운로드가 끝나는 시간을 알수없기때문에
//   비동기처리로 구현. Promise.then()을 사용.
//   읽어들인 데이터를 해석할 필요가 있는데 텍스트의 경우, text()사용
// ----------
// 1. Promise만으로 구현한경우
// ----------
fetch('sample.txt') // 1. 데이터취득
.then((data)=>data.text()) // 2. 텍스트데이트로써 해석
.then((text)=>{console.log(text);}); // 3. 해석결과로 처리
// ----------
// 2. await, async을 사용한 경우
// ----------
async function load(){
	const data2 = await fetch('sample.txt'); // 1
	const text2 = await data2.text(); // 2
	console.log(text2);
}
// ----------------------------
// - fetch()로 JSON읽기
//   1. fetch()로 데이터읽기
//   2. json()로 JSON포맷으로 해석
// ----------
// JSON
// ----------
{
	"name": "別所分校",
	"classes": [
		{
			"students": 40,
			"grade": 4,
			"name": "C組"
		},
		{
			"students": 20,
			"grade": 2,
			"name": "B組"
		}
	]
}
// ----------
// JS - 1. Promise만으로 구현
// ----------
fetch('samle.json')
.then((data) => data.json())
.then((obj) => {console.log(obj));}
// ----------
// JS - 2. await, async을 사용한 경우
// ----------
const btn = document.querySelector('button'); // ボタン要素を取得
btn.addEventListener('click', () => {
	// ボタンをクリックしたとき
	async function load() {
		// ファイルを読み込む
		const data = await fetch('sample.json');
		// JSONとして解析
		const obj = await data.json();
		console.log(obj); // 結果: {name: "別所分校", classes: Array(2)}
		// テキストを出力
		document.querySelector('#log').innerHTML = JSON.stringify(obj, null, '  ');
	}
	load();
});
// ----------------------------
// - fetch()로 XML읽기
//   => JSON은 변환후 바로 참조가 가능하기 때문에 코드량이 적다. 
// ----------------------------
// XML
// ----------
// &lt;data version="1"&gt;
//     &lt;orange&gt;1&lt;/orange&gt;
//     &lt;apple&gt;2&lt;/apple&gt;
// &lt;/data&gt;
// ----------
// JS - 1. Promise만으로 구현
// ----------
fetch('sample.xml')
.then((response) => response.text())
.then((str) => new DOMParser().parseFromString(str, 'application/xml'))
.then((xml) => {
	console.log(xml);
	console.log(xml.querySelector('orange').innerHTML);
})
// ----------
// JS - 2. await, async을 사용한 경우
// ----------
const btn = document.querySelector('button'); // ボタン要素を取得
btn.addEventListener('click', () => {
	// ボタンをクリックしたとき
	async function load() {
		// ファイルを読み込む
		const response = await fetch('sample.xml');
		// テキストとして解析
		const text = await response.text();
		// XMLとして解析
		const xml = new DOMParser().parseFromString(text, 'application/xml');

		console.log(xml); // 結果: #document
		// テキストを出力
		document.querySelector('#log').textContent = text;
	}
	load();
});
// ----------------------------
// - fetch()로 바이너리읽기
//   blob()
//   바이너리는 웹의 3D데이터나 화상해석분야등에서 쓰인다.
// ----------
// JS - 1. Promise만으로 구현
// ----------
fetch('sample.jpg')
.then((res) => res.blob())
.then((blob) => {
	const image = new Image();
	image.src   = URL.createObjectURL(blob);
	document.body.appendChild(image);
});
// ----------
// JS - 2. await, async을 사용한 경우
// ----------
const btn = document.querySelector('button'); // ボタン要素を取得
btn.addEventListener('click', () => {
	// ボタンをクリックしたとき
	async function load() {
		// データを読み込む
		const res = await fetch('./sample.jpg');
		// blob として解析する
		const blob = await res.blob();

		// img 要素を作る
		const image = new Image();
		// blob を src 属性に代入
		image.src = URL.createObjectURL(blob);
		// 画面に表示する
		document.querySelector('#log').appendChild(image);
	}
	load();
});
// ----------------------------
// - fetch()로 데이터를 송신
//   웹서버에 데이터를 넘기고 싶을때는 fetch()를 사용.
//   데이터송신방법: GET , POST 2종류
//   GET는 SEO(검색엔진최적화)와 상성이 좋다. but 개인정보 노출
//   POST는 https일 경우 제3자가 내용을 볼수 없다.
//   POST는 헤더, 보디 정보를 지정해야 함.
// ----------
// - JSON포맷으로 송신
// ----------
const obj = {hello:'world'};

const data = {
	method  : 'POST',
	headers : {'Content-Type':'application/json'},
	body    : JSON.stringify(obj)
};

fetch('./new', data)
	.then((res) => res.text())
	.then(console.log);
// ----------
// PHP
// ----------
// <?php
// 		$json_string = file_get_contents('php://input');
// 		// 문자열을 JSON데이터로 변환
// 		$obj = json_decode($json_string);
// 		echo $obj -> {"hello")};
// ?>
// ----------
// - Form방식으로 송신(multipart/form-data방식)
//   PHP쪽에서 받기 편하다.
//   키/값의 조합으로 송신데이터 정의가능.
//   주로 화상이나 첨부파일등을 서버에 업로드 할때 쓰이는 포맷.
//   Content-Type는 자동적으로 설정되기 때문에 코드에서 명시적 지정하면 안됨.
// ----------
const body = new FormData();
body.set('hello', 'world');

const data = {
	method  : 'POST',
	body    : body
};

fetch('./new', data)
	.then((res) => res.text())
	.then(console.log);
// ----------
// PHP
// ----------
// <?php
// 		echo $_POST["hello"];
// ?>
// ----------
// - Form방식으로 송신(application/x-www-form-unlencoded방식)
//   [키1=값1&키2=값2&...]형식으로 서버에 송신.
//   일본어같은 멀티바이트문자는 사용안되기때문에 URL인코드를 해서 서버에 송신.
// 	 URLSearchParams인스턴스를 작성, set()로 키/값을 설정.
//   Content-Type를 명시적으로 지정[application/x-www-form-unlencoded; charset=utf-8]
const param = new URLSearchParams();
param.set('hello', 'world');

const data = {
	method  : 'POST',
	headers : { 
		'Content-Type':'application/x-www-form-unlencoded; charset=utf-8'
	},	
	body    : param
};

fetch('./new.php', data)
	.then((res) => res.text())
	.then(console.log);
// ----------
// PHP
// ----------
// <?php
// 		echo $_POST["hello"];
// ?>
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - XMLHttpRequest로 텍스트 읽어들임
//   오래된 브라우저로 데이터송신시.
//   fetch()보다 오래전부터 이용. 보다 저레벨 제어가 가능.
//   : new XMLHttpRequest() => 인스턴스 생성
//     open(메소드, url) => 리쿼스트를 초기화.
//     send() => 리퀘스트를 송신
//   : 읽기완료 => load이벤트 감시
// ----------
const btn = document.querySelector('button'); // ボタン要素を取得
btn.addEventListener('click', () => {
    // ボタンをクリックしたとき
    // XHRを作成
    const req = new XMLHttpRequest();
    // 読み込み完了時のイベント
    req.addEventListener('load', (event) => {
        // レスポンスを受け取る
        const text = event.target.responseText;

        // テキストを出力
        document.querySelector('#log').innerHTML = text;
    });
    // ファイルを指定
    req.open('GET', './sample.txt');
    // 読み込み開始
    req.send();
});
// ----------------------------
// - XMLHttpRequest의 데이터 읽기 상황을 취득
//   : 프로그래스바를 표시하고 싶을때등
//   : progress이벤트 감시.
//   : event.loaded => 현재 읽은 양
//     event.totla  => 총용량
// ----------
// HTML
// ----------
// &lt;div class="progress"&gt;
// &lt;div class="progress-bar"&gt;&lt;/div&gt;
// &lt;/div&gt
// ----------
// JS
// ----------
const btn = document.querySelector('button'); // ボタン要素を取得
btn.addEventListener('click', () => {
    // ボタンをクリックしたとき
    // XHRを作成
    const req = new XMLHttpRequest();
    // データの種類を設定
    req.responseType = 'blob';

    req.addEventListener('progress', (event) => {
        // 読み込みの割合を算出(0〜1)
        const rate = event.loaded / event.total;

        // プログレスバーの幅を変更する
        const element = document.querySelector('.progress-bar');
        element.style.width = `${rate * 100}%`;
    });

    // 読み込み完了時のイベント
    req.addEventListener('load', (event) => {
        // レスポンスを受け取る
        const data = event.target.response;
        // 画像データに変換
        const source = URL.createObjectURL(data);

        // 画像を作成
        const image = new Image();
        image.src = source;
        // テキストを出力
        document.querySelector('#log').appendChild(image);
    });
    // ファイルを指定
    req.open('GET', './sample.jpg');
    // 読み込み開始
    req.send();
});
// ----------------------------
// - XMLHttpRequest으로 읽기중의 통신을 취소.
//   abort() => abort이벤트가 발생하고, load이벤트 발생안함.
// ----------
const btn = document.querySelector('button'); // ボタン要素を取得
btn.addEventListener('click', () => {
    // ボタンをクリックしたとき
    // XHRを作成
    const req = new XMLHttpRequest();
    // データの種類を設定
    req.responseType = 'blob';

    // 読み込みに失敗したときのイベント
    req.addEventListener('abort', (event) => {
        // 画面に表示
        document.querySelector('#log').textContent = '読み込みに失敗しました';
    });

    // 読み込み完了時のイベント
    req.addEventListener('load', (event) => {
        // レスポンスを受け取る
        const data = event.target.response;
        // 画像データに変換
        const source = URL.createObjectURL(data);
        // 画像を作成
        const image = new Image();
        image.src = source;
        // テキストを出力
        document.querySelector('#log').appendChild(image);
    });
    // ファイルを指定
    req.open('GET', './sample.jpg');
    // 読み込み開始
    req.send();

    // 50%の確率で
    if (Math.random() > 0.5) {
        // わざと読み込みを中断する
        req.abort();
    }
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 백그라운드에서 스크립트를 실행.
//   : 부하가 높은 처리를 실행할때.
//   : new Worker(파일패스)
//   : js는 메인스레드에서 동작함
//     부하높은 처리를 하면
//     -> UI를 담당하는 메인스레드가 멈춤
//     -> 조작불가능상태가 됨.
//   : Web Worker는 메인스크립트의 스레드와 
//     스레드가 다르기 때문에 DOM조작이 불가능하다.
//     또, Web Worker는 페이지가 열려있을때만 실행된다.
//   : Web Worker와 메인스레드가 데이터 통신할때는 
//     postMessage()로 송신하고, 
//     받은 메시지는 onmessage이벤트핸들러로 답신한다.
//     메시지는 onmessage이벤트의 data속성에 담겨진다.
// ----------
// main.js
// ----------
// 参照を取得
const numA   = document.querySelector('#numA');
const numB   = document.querySelector('#numB');
const result = document.querySelector('.result');
const btn    = document.querySelector('button');

// ワーカーを作成
const worker = new Worker('worker.js');

// ボタンをクリックしたとき
btn.addEventListener('click', () => {
    worker.postMessage([Number(numA.value), Number(numB.value)]);
    console.log('[メインスクリプト] ワーカーへメッセージを送信');
});

// ワーカーから受信したとき
worker.onmessage = function(e) {
    // 結果を画面に表示
    result.textContent = e.data;
    console.log('[メインスクリプト] ワーカーからメッセージを受信');
};
// ----------
// worker.js
// ----------
onmessage = (e) => {
    console.log('[ワーカー] メインスクリプトからメッセージを受信');

    // 足し算を実行
    const result = e.data[0] + e.data[1];

    console.log('[ワーカー] メインスクリプトにメッセージを送信');
    postMessage(result);
};
// ----------------------------
// - 백그라운드에서 서비스워커를 실행
//   : 브라우저의 뒤에서 네트워크를 감시할때등
//   : navigator.serviceWorker.register()
//     => 서비스워커를 등록.
//        반환값 : Promise
//   : 서비스워커 => 열려있는 웹페이지의 뒤에서 항상 기동하는 스크립트.
//     웹워커는 페이지가 열려있을 때만 실행된다.
//     서비스워커는 브라우저를 닫아도 실행가능하다.
//     => 푸쉬통지나 캐쉬기능을 이용하는데 유용.
//   : 서비스워커에서 캐쉬를 이용하려면, 구글이 제공하는 
//     라이브러리 Workbox를 이용하는게 좋다.
//     서비스워커에 URL룰을 기재하는것만으로 이용가능.
//     오프라인시에 웹페이지를 표시한다거나, HTTP캐쉬에서도 강력한 캐쉬기능을
//     구축할수 있기때문에 웹사이트의 고속配信에 유용.
// ----------
// main.js
// ----------
if ('serviceWorker' in navigator) {
    navigator.serviceWorker
        .register('serviceworker.js')
        .then((registration) => {
            // 登録成功
            console.log('ServiceWorkerの登録に成功');
        })
        .catch((error) => {
            // 登録失敗
            console.log('ServiceWorkerの登録に失敗: ', error);
        });
} else {
    console.log('ServiceWorkerに未対応です');
}
// ----------
// serviceworker.js
// ----------
self.addEventListener('fetch', (event) => {
    console.log('通信が発生', event.request);
});
// ----------------------------
// - 푸쉬통지를 실행.
//   : 브라우저에서 OS의 통지기능을 이용해서 통지하려 할때.
//     브라우저에서 웹페이지를 열었을때만 가능.
//   : Notification.permission => 브라우저가 통지를 허용하고 있는가.
//     Notification.requestPermission() => 통지허용을 요구.
//     new Notification(통지타이틀) => 통지를 함.
//   : 브라우저를 닫은 상태에서도 푸쉬통지를 사용하고 싶으면
//     => 서비스워커를 이용. 
//        https://ics.media/entry/11763/
// ----------
const btn = document.querySelector('button');
btn.addEventListener('click', notify);

// 通知を試みる
function notify() {
    switch (Notification.permission) {
        case 'default': // デフォルト状態だったら
            // 通知の許可を求めます
            Notification.requestPermission();
            break;
        case 'granted': // 許可されていれば
            // 許可されている場合はNotificationで通知
            new Notification('こんにちは');
            break;
        case 'denied': // 拒否されていれば
            alert('通知が拒否されています');
            break;
    }
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// ----------------------------
// - 15장
// ----------
// - localStorage로 로컬데이터 사용.
//   : 데이터를 영속적으로 브라우저에 보관.
//   : localStorage.setItem('myParam', data) => 로컬스토리지에 데이터 보존
//     localStorage.getItem('myParam) => 로컬스토리지에서 데이터 가져옴
//   : 로컬스토리지는 브라우저에 데이터를 보존가능한 수단.
//     window오브젝트에 localStorage오브젝트가 존재하기 때문에 
//     localStorage로 직접 호출가능. 
//     보존기간의 제한이 없다.
//   : 프라이빗 브라우징 모드일 경우 브라우저 마다 로컬스토리지 운용방법이 다르다.
//   : sessionStorage
//     localStorage와 사용법은 동일하지만 세션이 끝나면(브라우저를 닫으면) 클리어 된다.
// ----------
const section = document.querySelector('.localStorage'); // 親要素を取得
const btnRead = section.querySelector('.btnRead'); // ボタン要素を取得
const btnSave = section.querySelector('.btnSave'); // ボタン要素を取得
const input   = section.querySelector('input'); // テキスト入力欄の要素

// 「保存する」ボタンをクリックしたとき
btnSave.addEventListener('click', () => {
    // テキスト入力欄の文字列を取得
    const data = input.value;
    // ローカルストレージに保存
    localStorage.setItem('myKey', data);
});

// 「読み出す」ボタンをクリックしたとき
btnRead.addEventListener('click', () => {
    // ローカルストレージから読み出す
    const data = localStorage.getItem('myKey');
    // テキスト入力欄の文字列に代入
    input.value = data;
});
// ----------------------------
// - Storage API로 데이터를 삭제
//   : localStorage.removeItem(키명) => 일부삭제
//     localStorage.clear()          => 전부삭제
// ----------
const section   = document.querySelector('.localStorage'); // 親要素を取得
const btnClear  = section.querySelector('.btnClear'); // ボタン要素を取得
const btnRemove = section.querySelector('.btnRemove'); // ボタン要素を取得
const btnSave   = section.querySelector('.btnSave'); // ボタン要素を取得
const input     = section.querySelector('input'); // テキスト入力欄の要素

// 「保存する」ボタンをクリックしたとき
btnSave.addEventListener('click', () => {
    // テキスト入力欄の文字列を取得
    const data = input.value;
    // ローカルストレージに保存
    localStorage.setItem('myKey1', data);
    localStorage.setItem('myKey2', data);
});

// 「削除する」ボタンをクリックしたとき
btnRemove.addEventListener('click', () => {
    // ローカルストレージから削除する
    localStorage.removeItem('myKey1');
});

// 「クリアする」ボタンをクリックしたとき
btnClear.addEventListener('click', () => {
    // クリアする
    localStorage.clear();
});
// ----------------------------
// - Cookie로 로컬데이터를 사용.
//   : document.cookie => 쿠리를 참조.
//   : 쿠키에는 1차원의 문자열만 보존 가능.
//     클라이언트에서 이용가능하지만, 
//     서버쪽에도 공유해서 읽기/쓰기가 가능.
//   : 특수기호나 일본어는 인코드에서 저장하고, 읽을때 디코드가 필요.
//   : 쿠키의 사양
//     .쿠키는 브라우저가 자동적으로 웹서버에 전송
//     .쿠키는 유효기간의 설정이 가능
//     .지우지 않는한 계속 유지됨
//     .도메인단위로 유지됨. 다만, 동일 도메인이라도 http와 https는 다른 영역에 보존됨.
// ----------
const btnRead = document.querySelector('.btnRead'); // ボタン要素を取得
const btnSave = document.querySelector('.btnSave'); // ボタン要素を取得

// 「保存する」ボタンをクリックしたとき
btnSave.addEventListener('click', () => {
    // クッキーを保存する（代入しているが、それぞれが保存できる）
    document.cookie = 'id=1';
    document.cookie = 'age=30';
    document.cookie = `name=${encodeURIComponent('山田')}`;
});
// 「読み出す」ボタンをクリックしたとき
btnRead.addEventListener('click', () => {
    // クッキーを読み出す
    alert(document.cookie);
    // => [id=1; age=30; name=%E5%B1%B1%E7%94%B0]
});
// ----------------------------
// - 쿠키로부터 데이터 읽기
//   쿠키의 문자열값을 연상배열로 분해
// ----------
const btnRead = document.querySelector('.btnRead'); // ボタン要素を取得
const btnSave = document.querySelector('.btnSave'); // ボタン要素を取得

// 「保存する」ボタンをクリックしたとき
btnSave.addEventListener('click', () => {
    // クッキーを保存する
    document.cookie = 'id=1';
    document.cookie = 'age=30';
    document.cookie = `name=${encodeURIComponent('山田')}`;
});

// 「読み出す」ボタンをクリックしたとき
btnRead.addEventListener('click', () => {
    // クッキーを読み出す
    const obj = convertCookieToObject(document.cookie);
    console.log(obj); // => [Object { id: "1", age: "30", name: "山田" }]
    document.querySelector('#log').innerHTML = JSON.stringify(obj, null, '  ');
});

/**
 * クッキーをObjectに変換します。
 * @param cookies クッキー文字列
 * @return 連想配列
 */
function convertCookieToObject(cookies) {
    const cookieItems = cookies.split(';');

    const obj = {};
    cookieItems.forEach((item) => {
        // 「=」で分解
        var elem = item.split('=');
        // キーを取得
        const key = elem[0].trim();
        // バリューを取得
        const val = decodeURIComponent(elem[1]);
        // 保存
        obj[key] = val;
    });
    return obj;
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 위치정보취득
//   : Geolocation API로 취득
//   : navigator.geolocation.getCurrentPosition(성공시의함수, 실패시의함수)
//   : position.coords.latitude  => 위도
//     position.coords.longitude => 경도
//     position.coords.accuracy  => 위도경도의 오차
//   : 위도 => 仰角(ぎょうかく), 앙각, (수평에서 위를)올려본각
//     경도 => 方位角(ういかく), 수평에서 옆으로의 각
//     경도 
// ----------
// https://macmoo.github.io/ref/f/7phone/001_geo.html
// ----------
// 현재위치 취득
navigator.geolocation.getCurrentPosition(getSuccess, getError);

// 취득성공
function getSuccess(position){
    // 위도
    const lat = position.coords.latitude;
    // 경도
    const lng = position.coords.longitude;
    // 오차(m)
    const acc = Math.floor(position.coords.accuracy);

    alert(`위도 : ${lat}\n` 
        + `경도 : ${lng}\n`
        + `오차 : ${acc}`);
}

// 취득실패(거부)
function getError(){
    alert('Geolocation Error');
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 자이로 센서, 가속도 센서 사용
//   : event.beta  => x축의 기울기
//     event.gamma => y축의 기울기
//     event.alpha => z축의 기울기
//   : event.acceleration.x => x축의 가속도
//     event.acceleration.y => y축의 가속도
//     DeviceOrientation이벤트로 검출.
//     event.acceleration.z => z축의 가속도
//   : 자이로 센서는 기울기를 검출하는 센서.
// ----------
window.addEventListener('deviceorientation', deviceOrientationHandler);
function deviceOrientationHandler(event){
    const beta  = evnet.beta;  // x축
    const gamma = evnet.gamma; // y축
    const alpha = evnet.alpha; // z축

    alert(`X축 : ${beta}\n`
        + `Y축 : ${gamma}\n`
        + `Z축 : ${alpha}\n`);
}
// ----------------------------
window.addEventListener('devicemotion', deviceMotionHandler);
function deviceMotionHandler(event){
    const x = event.acceleration.x;
    const y = event.acceleration.y;
    const z = event.acceleration.z;
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 진동
//   : navigator.vibrate(진동시킬 미리초)
// ----------
// 1000미리초 진동
navigator.vibrate(1000);
// 500진동, 100정지, 그후에 500진동
navigator.vibrate([500,100,500]);
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">
// ----------------------------
// - 17장 : 디버그
// ----------------------------
// - 정보, 경로, 에러 출력
// ----------
console.log('ログです');
console.info('情報です');
console.warn('警告です');
console.error('エラーです');
// ----------------------------
// - 오브젝트의 구조를 출력
//   : console.dir(오브젝트)   => 트리구조로 출력
//     console.table(오브젝트) => 테이블형식으로 출력
// ----------
const myObject = {
    id: 2,
    name: '鈴木'
};
console.dir(myObject);
// body要素の構造を出力
console.dir(document.body);
// ----------
// console.table のサンプル
const myArray = [
    { id: 100, name: '鈴木', age: 25 },
    { id: 200, name: '田中', age: 30 },
    { id: 300, name: '太郎', age: 35 }
];
console.table(myArray);
// ----------------------------
// - 에러오브젝트 생성.
//   : new Error(에러내용)
//     Error인스턴스.message => 에러내용
const err = new Error("에러가 발생");
console.log(err.message);
// ----------------------------
// - 에러throw 
//   : throw Error인스턴스
// ---------------
// CSS
// ---------------
// @import url(../../common/css/base_photo.css);
// 
// body {
//     background-size: cover;
//     background: url("../common/bg_nature.jpg") center;
// }
// ---------------
// JS
// ---------------
/** 引数valueが数値でない場合にエラーを発生させる関数 */
function myFunction(value) {
    if (typeof value !== 'number') {
        // エラーを生成する
        const error = new Error(`「${value}」はNumberではありません`);
        // エラー内容をアラートで表示する
        alert(error.message);
        // エラーを投げる
        throw error;
    }
    console.log(`「${value}」は数値です`);
}
// 関数に数値を渡す（エラーなし）
myFunction(5);
// 関数に文字列を渡す（エラーが発生する）
myFunction('鈴木');
// ----------------------------
// - 에러 catch
// ---------------
const a = 10;
try {
    a = 20;
} catch (error) {
    console.log(`에러가 발생: ${error.message}`);
}
// 중단되지 않고 실행됨.
console.log(`정수a의 값은${a}이다`);
// ----------------------------
// - finally
// ---------------
/** 50%の確率でエラーが発生し、try cacthで処理する */
function generateError() {
    try {
        // 50%の確率でエラーを発生させる
        if (Math.random() > 0.5) {
            throw new Error();
        } else {
            console.log('エラーなし');
        }
    } catch (error) {
        // エラー発生時の処理
        console.log(`エラーが発生`);
    } finally {
        // エラー発生有無に関わらず実行される
        console.log('エラーの処理が完了しました');
        console.log('----------');
    }
}
// 3秒ごとにgenerateError()を実行する
setInterval(generateError, 3000);
// ----------------------------
// - 에러의 종류
//   : RangeError     => 값이 허용범위밖
//     ReferenceError => 선언안된 변수를 참조
//     SyntaxError    => 언어의 구문이 부정
//     TypeError      => 데이터형이 부정
//     URIError       => URI가 부정
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// ----------------------------
// - 18장 : 함수, 클래스
// ----------------------------
// - 클래스 작성
//   : new 클래스명()
// - 클래스 변수.
//   : 클래스에 속하는 변수는 
//     클래스필드, 클래스변수, 멤버변수라고 함.
//   : 멤버변수에 초기값을 대입하지 않으면 undefined.
// ---------------
class MyClass{
    constructor(){
        // let이나 const로 기재하지않음.
        this.classField = 12;
    }
    classMethod(){
        console.log('메소드 실행됨!');
    }
}

const myInstance = new MyClass();
console.log(myInstance.classField);
myInstance.classMethod();
// ----------------------------
// - 정적 메소드
//   : 인스턴스 작성없이 호출가능.
// ---------------
class MyClass2{
    static method2(){
        console.log('정적 메소드 실행됨!');
    }
}
MyClass2.method2();
// ----------------------------
// - 클래스 상속
//   : class 클래스명 extends 부모클래스명
// ---------------
class MyParent {
    parentMethod(){
        console.log('부모 메소드 실행됨!');
    }
}
class MyChild extends MyParent{
    constructor(){
        super();
    }
    childMethod(){
        console.log('자식 메소드 실행됨!');
    }
}

const myChild = new MyChild();
myChild.parentMethod();
myChild.childMethod();
// ----------------------------
// - getter/setter
// ---------------
class MyClass3{
    set customField(value){
        console.log("setter");
        this._customField = value;
    }
    get customField(){
        console.log("getter");
        return this._customField;
    }
    constructor(value){
        console.log("constructor");
        this._customField = value;
    }
}
const myInstance3 = new MyClass3();
myInstance3.customField = 20;
// myInstance3.customField(20); // 이건 불가능.함수가 아니다.
console.log(myInstance3.customField);

// ----------------------------
// - this가 참조하는 것을 고정. 
//   : () => {}    (애로우함수)
//     애로우함수를 사용하면, this의 실행장소에 관계없이
//     참조하는 곳이 바뀌지않기때문에 코드를 읽기쉬움.
// ---------------
class LikeCounter {
    constructor() {
        // ボタンをクリックした数
        this.clickedCount = 0;
    
        const button = document.querySelector('.button');
        const clickedCountText = document.querySelector('.clickedCountText');
    
        // 애로우함수로 이벤트리스너를 정의`
        button.addEventListener('click', () => {
            this.clickedCount += 1;
            clickedCountText.textContent = this.clickedCount;
        });
    }
new LikeCounter();
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">s
// ----------------------------
// - 19장 : 심화
// ----------------------------
// - JS읽기 타이밍 최적화
//   : HTML해석중에 script태그를 만나면 HTML해석이 멈추고 
//     js파일의 다운로드/실행이 동기되어 시작됨.
//     async나 defer를 쓰면 HTML의 해석이 멈추지 않음.
//   : &lt;script src="path" async &gt;&lt;/script&gt;
//     => js파일을 비동기로 읽고, 읽기가 완료되면 즉시 실행.
//     &lt;script src="path" defer &gt;&lt;/script&gt;
//     => js파일을 비동기로 읽고, HTML해석완료후에 실행. 
//   : async / defer의 차이는 실행타이밍
//   : defer가 설정된 스크립트가 복수개 있을경우, 위에서부터 순차처리.
//     async는 처리 순서 보장안함.
//     => async는 다른 js파일과 독립되어 실행되는 처리에 이용하는 것이 좋다.
//   : defer속성을 사용하면 DOM취득이 쉽다.
///    => HTML해석이 끝난후 실행되기 때문에 document.querySelector()등의
//        DOM상의 각요소를 조작할수 있다.
// ----------------------------
// - 처리별로 파일을 분할(ES모듈)
//   : ES모듈 => 복수의 js파일을 의존관계에 따라 적절하게 읽어들이는 구조를 말함.
//     ES모듈을 사용하면 처리별로 js파일을 분할 가능.
//     출력하는 모듈에는 export를, 모듈을 읽어들일 때는 import를 사용.
// ---------------
// HTML
// ---------------
// ES모듈을 사용할 때는 type에 module을 지정.
// &lt;script type="module" src="main.js" defer&gt;&lt;/script&gt;
// ---------------
// MyClass1.js
// ---------------
export class MyClass1 {
    myMethod1() {
        return 'MyClass1のメソッドが実行されました';
    }
}
// ---------------
// MyClass2.js
// ---------------
export class MyClass2 {
    myMethod2() {
        return 'MyClass2のメソッドが実行されました';
    }
}
// ---------------
// main.js
// ---------------
// MyClass1.jsをimport
import { MyClass1 } from './MyClass1.js';
// MyClass2.jsをimport
import { MyClass2 } from './MyClass2.js';

// MyClass1のメソッドより文字列を取得する
const message1 = new MyClass1().myMethod1();
// MyClass2のメソッドより文字列を取得する
const message2 = new MyClass2().myMethod2();

// #log要素に出力する
const log = document.querySelector('#log');
log.innerHTML += `<p>${message1}</p>`;
log.innerHTML += `<p>${message2}</p>`;
// ----------------------------
// - 모듈을 export
//   : export 모듈 => 모듈을 공개함.
//   : 클래스, 오브젝트, 변수, 정수, 함수등 모든것을 모듈로서 취급가능.
//   : export default => 하나의 js파일로부터 하나의 모듈만을 export한다.
//     export default 모듈명;
// ---------------
export const myConstant = 2; 
export const myObject   = { name:'KK', age:18 };
export function myFunc  = { console.log('my task'); }
export class MyClass    = { constructor(){} }
// ----------------------------
// - 모듈을 import
//   : import { 모듈명 } from './파일명.js'
//   : 파일의 확장자는 필수.
// ---------------
// . js파일에서 모듈을 읽음.
import { 모듈명 } from './파일.js';
// . 하나의 파일에서 복수개의 모듈을 읽음.
import { 모듈명1, 모둘명2 } from './파일.js';
// . 모듈명1을 모둘명2라는 이름으로 읽음.
import { 모듈명1 as 모둘명2 } from './파일.js';
// . js파일에서 [export defaul]로 정의된 모듈을 읽어 들임.
import 모듈명 from './파일.js';
// . js파일에서 모든 모듈을 읽어들여, 모듈명으로 한다.
import * as 모듈명 from './파일.js';
// . 모듈을 읽기만함.
import './파일.js';
// . 서버상의 모듈을 import
import * as RemoteModule from 'https://exp.com/module.js';
// ----------------------------
// - 모듈을 사용한 js를 HTML에서 읽기.
// &lt;script type="module" src="main.js" defer&gt;&lt;/script&gt;
// 다른 방법
// &lt;script type="module"&gt;
//     import { MyClass } from './MyClass.js';
//     new MyClass();
// &lt;/script&gt;
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - iterator
//   : 오브젝트[Symbol.iterator]() => 이터레이터취득
//     이터레이터.next() => 다음 이터레이터를 취득
//   : 이터레이터.value  => 현재의 값
//     이터레이터.done   => 종료했는가 (T/F)
//   : 이터레이터 => 복수의 값을 연속해서 억세스 가능한 구조를 갖고 있는 오브젝트.
//     iterable오브젝트 => for .. of 처리가 가능.
// ---------------
const array = ['鈴木', '高橋', '田中'];

const iterator = array[Symbol.iterator]();

const next1 = iterator.next();
console.log(next1.value); // 結果: '鈴木'
console.log(next1.done); // 結果: false

const next2 = iterator.next();
console.log(next2.value); // 結果: '高橋'
console.log(next2.done); // 結果: false

const next3 = iterator.next();
console.log(next3.value); // 結果: '田中'
console.log(next3.done); // 結果: false

const next4 = iterator.next();
console.log(next4.value); // 結果: undefined
console.log(next4.done); // 結果: true
// ----------------------------
// - iterator를 자작 (generator)
//   : function* 함수명() {}  => generator를 정의
//     yield 값               => 값을 반환.(다음 값을 지정)
//   : yield는 그 시점에 함수의 실행을 멈추고, next()가 호출되면 
//     계속해서 실행되는 성질을 갖고 있다.
// ---------------
function* myGenerator(){
    yield '스즈키';
    yield '다나카';
    yield '고토';
}
// next()로 값을 하나하나 출력
const myIterable = myGenerator();
console.log(myIterable.next().value);
console.log(myIterable.next().value);
console.log(myIterable.next().value);
console.log(myIterable.next().done);
// for .. of로 값에 접근
const myIterable2 = myGenerator();
for(let value of myIterable2) {
    console.log(value);
}
// ---------------
function* myGenerator() {
    console.log('こんにちは');
    yield 1000;
    console.log('今日はいい天気ですね');
    yield 2000;
    console.log('明日は晴れるでしょう');
    yield 3000;
}
const myIterable = myGenerator();

// 結果
// 1秒後、「こんにちは」が出力された後、1000が出力される
// 2秒後、「今日はいい天気ですね」が出力された後、2000が出力される
// 3秒後、「明日は晴れるでしょう」が出力された後、3000が出力される
// それ以降はundfinedが出力される
setInterval(() => {
    console.log(myIterable.next().value);
}, 1000);
// ----------------------------
// ジェネレータの定義
function* range(start, end) {
    let result = start;
    while (result <= end) {
        yield result;
        result++;
    }
}

// 使用例
for (let value of range(2, 6)) {
    console.log(value); // 結果: 2, 3, 4, 5, 6...と順番に出力される
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">
// ----------------------------
// - Symbol
//   : 절대 중복되지 않는 데이터를 취급할때.
//     빌트인 오브젝트에 독자메소드를 추가할경우의 메소드 명을 작성할때.
//   : Symbol(문자열 또는 수치) => 심볼생성
//   : 심볼 => 다른것과 중복되지 않는 값을 취급한다.
//   : new를 쓰지않고 단지 Symbol()로 생성
// ---------------
const symbol1 = Symbol();
const symbol2 = Symbol();
console.log(symbol1 == symbol2);  // false
console.log(symbol1 === symbol2); // false
console.log(typeof symbol1);      // symbol
console.log(symbol1);             // Symbol()
const symbol3 = Symbol('foo');
const symbol4 = Symbol('foo');
console.log(symbol3 == symbol4);  // false
// ----------------------------
// - 배열이나 오브젝트에 독자메소드를 추가.
//   : 오브젝트.prototype[심볼] = function(){}
//     => 오브젝트에 독자메소드를 추가.
//     오브젝트[심볼]()
//     => 독자메소드를 실행.
//   : prototype => 오브젝트에 멤버(멤버함수, 멤버변수)를 추가하기 위한 프로퍼티이다.
//     Object를 상속받는 모든 객체는 prototype가 있다.
//   : 이미 존재하는 멤버와 같은 이름으로 추가할 경우 덮어씌어진다.
//     => Symbol을 사용하는 이유
console.log(String.prototype);
console.log(Array.prototype);
console.log(Date.prototype);
// ---------------
// [myMethod]라는 심볼생성.
const myMethod = Symbol();
// 독자메소드 추가.
Array.prototype[myMethod] = function(){
    console.log('독자메소드이다.');
}
// 독자메소드 실행.
const arr = [1,2,3];
arr[myMethod](); // 독자메소드이다.
// ---------------
// 배열에 셔플메소드 추가.
const shuffle = Symbol();

Array.prototype[shuffle] = function(){
    const arrayLength = this.length;
    for(let i = arrayLength - 1; i >= 0 ; i --){
        const randomIndex = Math.floor(Math.random() * (i+1));
        [this[i], this[randomIndex]] = [this[randomIndex], this[i]];
    }
    return this; // 자기자신을 반환.
};
// 테스트
// 배열에서 짝수를 빼내어 셔플하고 100배로 한다.
const arr2 = [1,2,3,4,5,6,7,8,9,10];
const arr3 = arr2.filter((value) => value % 2 === 0)
                    [shuffle]()
                    .map((value) => value * 100);
console.log(arr3);
// => Array(5) [ 400, 200, 800, 600, 1000 ]
// ---------------
// 이렇게도 가능.
Array.prototype.myMethod = function(){
    console.log('안녕');
}
const arr4 = [1,2,3];
arr4.myMethod(); // 안녕
// ----------------------------
// - Map을 사용.
//   : 메소드
//     new Map(iterable한 객체) => Map객체를 초기화.
//     맵.set(키, 값)   => 맵에 키/값을 등록
//     맵.get(키)       => 값 취득
//     맵.has(키)       => 키의 값이 존재하나
//     맵.delete(키)    => 키의 값을 삭제
//     맵.clear()       => 모두 삭제
//     맵.keys()        => 키로 이루어진 iterator객체
//     맵.values()      => 값으로 이루어진 iterator객체
//     맵.entries()     => 키/값의 배열로 이루어진 iterator객체
//     맵.forEach(콜백) => 각 페어에 대해 처리를 함.
//   : 프로퍼티
//     맵.size          => 키 / 값의 페어수
//   : forEach의 콜백구문
//     (키, 값) => {}   => 키 / 값을 받아 처리를 함.
//   : 키가 이미 존재할경우, 덮어씌어진다.
// ---------------
// 맴 초기화.
const memberList = new Map();
// 맵 값 설정.
memberList.set( 20, '스즈키');
memberList.set( 50, '다나카');
memberList.set(120, '다카하시');
// 이렇게도 기술가능
// memberList.set( 20, '스즈키')
//             .set( 50, '다나카' )
//             .set(120, '다카하시');
// 값 취득.
console.log(memberList.get(20)); // 스즈키
// 맵의 존재 확인.
console.log(memberList.has(50)); // true
// ---------------
// 맵 생성2
const memMap = new Map([[20, '스즈키'],[50, '다나카'],[120, '다카하시']]);
console.log(memMap.get(50));        // 다나카
console.log(memMap.get(502));       // undefined
const keySymbol = Symbol();
memMap.set(keySymbol, '고토우');
console.log(memMap.get(keySymbol)); // 고토우

console.log(memMap.size);           // 4
// 키
const keyList = memMap.keys();
for(let key of keyList){
    console.log(memMap.get(key));
}
// 값
const valList = memMap.values();
for(let val of valList){
    console.log(val);
}
// 엔트리
memMap.delete(keySymbol);
memMap.forEach((value, key) => {
    console.log(`${key} : ${value}`);
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - Set => 중복하지 않는 값의 컬렉션
//   : 인덱스나 키로 값에 접근이 불가능
//     기존에 있는 값을 세트하면 무시됨.
//   : 메소드
//     new Set(iterable객체)
//     세트.add(값)
//     세트.has(값)
//     세트.delete(값)
//     세트.clear()
//     세트.values()
//     세트.forEach(콜백함수)
//   : 프로퍼티
//     세트.size
// ---------------
const userList = new Set();
userList.add( 20);
userList.add( 50);
userList.add(120);
// userList.add( 20)
//         .add( 50)
//         .add(120);
console.log(userList.has(50)); // true
// 초기화2
const userList2 = new Set([20, 50, 120]);
// for .. of
const userValList = userList.values();
for(let value of userValList){
    console.log(value);// 20, 50, 120
}
// forEach
userList.forEach((value)=>{
    console.log(value);// 20, 50, 120
});
// 이미 있는 값은 무시됨.
userList.add(120);
userList.forEach((value)=>{
    console.log(value); // 20, 50, 120
});
// 스플레트연산자로 배열로 변환.
const userIdArr = [...userList];
console.log(userIdArr);
// => Array(3) [ 20, 50, 120 ]
console.log(userList.size); // 3
// ----------------------------
// JavaScriptコードレシピ 完
// ----------------------------</code></pre>
<!-- ############################################# -->

</body>
</html>