<!DOCTYPE html>

<head>
    <title></title>
    <!-- START -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- <link rel="stylesheet" type="text/css" href="../../etc/androidstudio.css"> -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/monokai-sublime.min.css">
    <link rel="stylesheet" type="text/css" href="../../etc/custom.css">
    <script type="text/javascript" src="../../etc/highlight.min.js"></script>
    <script type="text/javascript" src="../../etc/highlightjs-line-numbers.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>hljs.initLineNumbersOnLoad();</script>
    <!-- E N D -->
</head>

<body>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
//
// Java 逆引きレシピ 第２版
// - 基本
//
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// static멤버를 임포트
// -----------------------------------
// 임포트 안함
double a     = 3.214;
double r     = 1.23;
long   value = Math.round(a);
double area  = r * r * Math.PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23
// 임포트 함
// import static java.lang.Math.round;
// import static java.lang.Math.PI;
double a     = 3.214;
double r     = 1.23;
long   value = round(a);
double area  = r * r * PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 리터럴
// -----------------------------------
int  oct = 040;
int  hex = 0x20;
int  bin = 0b0100000;
int    a = 100_000_000; // 수치 리터럴(7이후)
float  b = 3.14f;
double c = 3.14;  // f가 없으면 디폴트로 double
double d = 3.14d;

System.out.println("oct : " + oct); // oct:32
System.out.println("hex : " + hex); // hex:32
System.out.println("bin : " + bin); // bin:32
System.out.println("a   : " + a);   // a:100000000
System.out.println("b   : " + b);   // b:3.14
System.out.println("c   : " + c);   // c:3.14
System.out.println("d   : " + d);   // d:3.14</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 비트연산
// 비트연산/시프트연산의 결과는 반드시 int가 된다.
// 좌변, 우변중 한쪽이 long일 경우에는 결과도 long이 된다.
// -----------------------------------
// 2진수표기로 int형 생성
int a = Integer.parseInt("000000000000000000000000000100", 2);
int b = Integer.parseInt("000000000000000000000000000101", 2);
System.out.println(Integer.toBinaryString(a));   // 100
System.out.println(Integer.toBinaryString(b));   // 101
int and = a & b;
System.out.println(Integer.toBinaryString(and)); // 100
int or  = a | b;
System.out.println(Integer.toBinaryString(or));  // 101
int xor = a ^ b;
System.out.println(Integer.toBinaryString(xor)); // 1
int not = ~a;
System.out.println(Integer.toBinaryString(not));
// 11111111111111111111111111111011
// 시프트연산자
// >>  왼쪽은 시프트전의 최위비트로 채운다.
// >>> 왼쪽은 0으로 채운다.
int left1 = a << 1;
System.out.println(Integer.toBinaryString(left1));  // 1000
int left2 = a << 2;
System.out.println(Integer.toBinaryString(left2));  // 10000
int right1 = b >> 1;
System.out.println(Integer.toBinaryString(right1)); // 10
int right2 = b >>> 1;
System.out.println(Integer.toBinaryString(right2)); // 10
int right3 = b >> 2;
System.out.println(Integer.toBinaryString(right3)); // 1</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 오브젝트의 형을 조사
// instanceof 연산자
// -----------------------------------
Object obj1 = "abc";
Object obj2 = new ArrayList<>();;
Object obj3 = null;

if(obj1 instanceof String) {
    String str = (String)obj1;
    System.out.println(str);
}

// ArrayList는 List의 実装클래스이기때문에 true
if(obj2 instanceof List)
    System.out.println("List");

// obj3는 null이기때문에 false를 반환
if(obj3 instanceof Object)
    System.out.println("Object");

// -----------------------------------
// 결과:
// abc
// List
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 캐스트
// - 업캐스트 : 보다 추상적인 형으로 변환
// - 다운캐스트: 보다 구체적인 형으로 변환
// 괄호필요, 실패시 ClassCastException
// -----------------------------------
// 업캐스트
ArrayList<String> aList = new ArrayList<>();
// ArrayList는 List인터페이스를 구현하고 있기때문에 OK
List<String> bList = aList;
// ---------------
// 다운캐스트
List<String> a = new ArrayList<>();
ArrayList<String> b = (ArrayList<String>) a;
// LinkedList<String> c = (LinkedList<String>)a; // 예외발생
// ---------------
// 클래스오브젝트의 cast()로 다운캐스트
Object obj = Integer.valueOf(1);
Integer i = Integer.class.cast(obj);</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 래퍼클래스
// 컬렉션에는 오브젝트만 넣을수 있다. 기본형은 안됨
// 오토박싱:기본형에서 래퍼클래스로의 자동변환
// 언박싱 :래퍼클래스에서 기본형으로의 자동변환
// -----------------------------------
List<Integer> list = new ArrayList<>();
int i = 0;
list.add(i);         // 오토박싱
int j = list.get(0); // 언박싱
// ---------------
// * 주의 ( remove()등 )
list.remove(0); // 0번째 요소 삭제
list.remove(Integer.valueOf(0)); // 값이 0인 요소를 삭제</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// Optional
// - java8에서 도입된 콘테이너클래스
// - 존재하는지 아닌지 알수없는 값을 표현하기 위함.
// - 값이 존재하지 않는 가능성이 있음을 명시되고, 에러방지가 가능
// - 기본형의 Optional이 존재
// OptionalInt, OptionalLong, OptionalDouble
// 래퍼형으로의 변환을 피할수 있기때문에 Optional보다 효율적이다.
// -----------------------------------
// 값을 갖는 Optional오브젝트
// of()에 null을 건네면 예외가 throw된다.
Optional<String> exist = Optional.of("123");
// 값을 가지지 않는 빈 Optional오브젝트
Optional<String> empty = Optional.empty();
// 값이 null이 아닐 경우에는 값을 갖는 Optional
// 값이 null일 경우에는 빈 Optional을 생성
String valEmpty = "";
String valNull  = null;
String valStr   = "Test String";
Optional<String> optionalEmpty = Optional.ofNullable(valEmpty);
Optional<String> optionalNull  = Optional.ofNullable(valNull);
Optional<String> optionalStr   = Optional.ofNullable(valStr);
System.out.println(exist); // Optional[123]
System.out.println(empty); // Optional.empty
System.out.println(optionalEmpty); // Optional[]
System.out.println(optionalNull);  // Optional.empty
System.out.println(optionalStr);   // Optional[Test String]
// -----------------------------------
// Optional에서는 get()로 값 취득 가능
// 값이 존재하지 않으면 NoSuchElementException발생
// 그래서, 값의 존재여부를 알수 없을때는
// orElse()이나 orElseGet()로 값이 존재하지 않을경우 디폴트값을 지정하거나
// orElseThrow()로 임의의 예외를 throw가능
// -----------------------------------
try {
    String val = optionalEmpty.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 X
try {
    String val = optionalNull.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// No value present
// 값이 존재하지 않을때, 문자열을 반환
String val1 = optionalEmpty.orElse("A");
String val2 = optionalNull.orElse("B");
String val3 = optionalStr.orElse("C");
System.out.println("[" + val1 + "]"); // []
System.out.println("[" + val2 + "]"); // [B]
System.out.println("[" + val3 + "]"); // [Test String]
// 값이 존재하지 않을때, 람다식결과를 반환
String val4 = optionalNull.orElseGet(() -> {
    return new SimpleDateFormat("yyyyMMdd").format(new Date());
});
System.out.println("[" + val4 + "]"); // [20220110]
// 값이 존재하지 않을때, 예외발생
try {
    String val5 = optionalNull.orElseThrow(() -> new Exception("값이 없다"));
    System.out.println("예외발생 X");
} catch (Exception e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// 값이 없다
// -----------------------------------
// 값이 있을 경우에만 처리함
// 값의 존재 체크후 처리
if (optionalEmpty.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 있음 : []
if (optionalNull.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 없음
// 값이 있을때만 람디식처리
optionalEmpty.ifPresent(s -> {
    System.out.println("처리[" + s + "]");
}); // 처리[]
optionalNull.ifPresent(s -> {
    System.out.println("처리[" + s + "]"); // 출력안됨
});
// -----------------------------------
// filter()
// Optional의 값이 지정한 조건을 만족하지 않는 경우,
// 빈Optional로 변환한다.
// => Optional의 값이 특정조건을 만족하는 경우에만 처리.
// -----------------------------------
// Optional 생성
String val6 = "1234567890";
Optional<String> opt6 = Optional.ofNullable(val6);
// 값이 10자 이생일 경우에만 처리함.
opt6.filter(s -> s.length() >= 10).ifPresent(s -> {
    System.out.println("처리:[" + s + "]");
});
// => 처리:[1234567890]
// -----------------------------------
// map()
// Optional의 값을 변환한, 새로운 Optional오브젝트를 생성.
// 인수의 람다식이 null일경우, 빈Optional을 반환
String val7 = "abcde";
Optional<String> opt7 = Optional.ofNullable(val7);
// 값을 대문자로 변환
Optional<String> map7 = opt7.map(s -> s.toUpperCase());
System.out.println(map7); // Optional[ABCDE]
System.out.println(map7.get()); // ABCDE
// -----------------------------------
// flatMap()
// 인수로 건네는 람다식은 Optional을 반환
// 빈Optional에대한 flatMap()은 map()과 같이 람다식을 실행하지 않고
// 빈Optional을 반환.
Optional<String> userName = Optional.ofNullable("sa");
Optional<String> password = Optional.ofNullable("sa");
boolean isValid = userName.flatMap(u -> {
    return password.map(p -> {
        return u.equals("sa") && p.equals("sa");
    });
}).orElse(false);

if(isValid)
    System.out.println("true");
else
    System.out.println("false");
// => true</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// exception
// -----------------------------------
// 호출한 곳에서 ParseException, IOException를 캐치
public void createFile() throws ParseException, IOException{
    // 1
    if(...) {
        // 처리
    } else {
        throw new IOException("실패");
    }
    // 2
    try {
        // ParseException, IOException를 스로
        
    }catch(Exception e) {
        // 그대로 스로할 경우에는 던질 예외를 throws에 적어줌
        throw e; 
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// try-with-resource
// : try블록내에서 예외발생여부와 관계없이 리소스가 
//   클로즈되는 것을 보장한다.
// : 복수선언가능(클로즈는 선언의 역순으로 실행됨)
// -----------------------------------
// 샘플1 복수선언시 ";" 으로 구분
try(InputStream in = new FileInputStream("test.txt");
        OutputStream out = new FileOutputStream("test2.txt")){
    // InputStream의 내용을 OutputStream에 씀
}
// 샘플2
// catch, try블록은 try-with-resource문 처리후 실행됨
// => 리소스가 클로즈된후 실행됨
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e) {
    e.printStackTrace();
}finally {
    System.out.println("처리종료");
}
// 샘플3
// try블록과 리소스클로즈중에 예외가 발생하면
// try블록에서 발생항 예외만 throw된다. 후자는 무시됨.
// 정보는 이하로 취득
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e){
    for(Throwable t : e.getSuppressed()) {
        t.printStackTrace();
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 스택트레이스 정보 취득
// Throwable#printStackTrace()
// : 스택트레이스를 스트림에 출력만 가능.
// Thread#getStackTrace();
// -----------------------------------
try {
    int t = 3/0;
}catch(Exception e){
    e.printStackTrace();
    System.out.println("------------------------");
    for(StackTraceElement elem : e.getStackTrace()) {
        String str = new StringBuffer()
        .append(elem.getClassName()).append(" - ")
        .append(elem.getMethodName()).append(" - ")
        .append(elem.getFileName()).append(" - ")
        .append(elem.getLineNumber()).toString();
        System.out.println(str);
    }
}
//	java.lang.ArithmeticException: / by zero
//	at old.Src001.main(Src001.java:13)
//	------------------------
//	old.Src001 - main - Src001.java - 13
// -----------------------------------
StackTraceElement[] list = Thread.currentThread().getStackTrace();
for(StackTraceElement elem : list) {
    // ...
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// *람다식
// 1) 함수의 처리를 1행으로 기술할 경우
//    식의 결과가 람다식의 반환값이 된다.
//    (인수리스트) -> 식
// 2) 복수행으로 기술할 경우
//    람다식을 {}으로 묶을때는 return문이 필요.
//    (인수리스트) -> {
//      함수처리
//      return 값;
//    }
//
// *용도
// 1) 익명클래스 대신 사용
// 2) 컬렉션 요소에 대해 사용
// -----------------------------------
// *함수형 인터페이스
// 구현해야하는 메소드가 1개의 인터페이스인 경우.
// (예 Comparator인터페이스)
// 이 함수형인터페이스를 구현한 클래스대신에 람다식을 사용 가능.
// -----------------------------------
// 기존의 익명클래스
List<String> list = Arrays.asList("Java123","Scala","Groovy");
System.out.println("1 : " + list);
list.sort(new Comparator<String>(){
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});
System.out.println("2 : " + list);
// 람다식으로 구현
list.sort((String s1, String s2) -> s2.length() - s1.length());
System.out.println("3 : " + list);
// -----------------------------------
// 1 : [Java123, Scala, Groovy]
// 2 : [Scala, Groovy, Java123]
// 3 : [Java123, Groovy, Scala]
// -----------------------------------
// *람다식의 인수가 명백한 경우에는 형생략이 가능
list.sort((s1, s2) -> s2.length() - s1.length());
// *인수가 1개인 경우에는 인수리스트의 ()생략가능
list.forEach(s -> System.out.println(s));
// Java123
// Groovy
// Scala
// -----------------------------------
// 컬렉션 요소의 조작
list.forEach(s -> System.out.println(s));
// -----------------------------------
// *람다식에서 사용가능한 외부변수
//  람다식 내부에서는 값을 변경하지 않는 외부변수는 final 취급을
//  하기때문에 참조가능 
public void outer(String message) {
    Runnable r = () -> {
        // 람다식 내부에서 outer()의 인수 참조가능
        System.out.println(message);
    }
    
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            // java8이후부터 outer()의 인수가 final이 아니라도 참조가능
            System.out.println(message);
        }
    };
}
// -----------------------------------
// 외부변수 참조 불가능한 경우
public void outer(String message) {
    Runnable run = () -> {
        // 람다식 내부에서 outer()의 인수 참조
        System.out.println(message);
    }
    // 인수에 값을 대입하면 컴파일 에러
    message = "hoge";
}</code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
</body>

</html>