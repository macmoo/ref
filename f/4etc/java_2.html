<!DOCTYPE html>

<head>
    <title></title>
    <!-- START -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- <link rel="stylesheet" type="text/css" href="../../etc/androidstudio.css"> -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/monokai-sublime.min.css">
    <link rel="stylesheet" type="text/css" href="../../etc/custom.css">
    <script type="text/javascript" src="../../etc/highlight.min.js"></script>
    <script type="text/javascript" src="../../etc/highlightjs-line-numbers.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>hljs.initLineNumbersOnLoad();</script>
    <!-- E N D -->
</head>

<body>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
//
// Java 逆引きレシピ 第２版
// - 基本
//
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// static멤버를 임포트
// -----------------------------------
// 임포트 안함
double a     = 3.214;
double r     = 1.23;
long   value = Math.round(a);
double area  = r * r * Math.PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23
// 임포트 함
// import static java.lang.Math.round;
// import static java.lang.Math.PI;
double a     = 3.214;
double r     = 1.23;
long   value = round(a);
double area  = r * r * PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 리터럴
// -----------------------------------
int  oct = 040;
int  hex = 0x20;
int  bin = 0b0100000;
int    a = 100_000_000; // 수치 리터럴(7이후)
float  b = 3.14f;
double c = 3.14;  // f가 없으면 디폴트로 double
double d = 3.14d;

System.out.println("oct : " + oct); // oct:32
System.out.println("hex : " + hex); // hex:32
System.out.println("bin : " + bin); // bin:32
System.out.println("a   : " + a);   // a:100000000
System.out.println("b   : " + b);   // b:3.14
System.out.println("c   : " + c);   // c:3.14
System.out.println("d   : " + d);   // d:3.14</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 비트연산
// 비트연산/시프트연산의 결과는 반드시 int가 된다.
// 좌변, 우변중 한쪽이 long일 경우에는 결과도 long이 된다.
// -----------------------------------
// 2진수표기로 int형 생성
int a = Integer.parseInt("000000000000000000000000000100", 2);
int b = Integer.parseInt("000000000000000000000000000101", 2);
System.out.println(Integer.toBinaryString(a));   // 100
System.out.println(Integer.toBinaryString(b));   // 101
int and = a & b;
System.out.println(Integer.toBinaryString(and)); // 100
int or  = a | b;
System.out.println(Integer.toBinaryString(or));  // 101
int xor = a ^ b;
System.out.println(Integer.toBinaryString(xor)); // 1
int not = ~a;
System.out.println(Integer.toBinaryString(not));
// 11111111111111111111111111111011
// 시프트연산자
// >>  왼쪽은 시프트전의 최위비트로 채운다.
// >>> 왼쪽은 0으로 채운다.
int left1 = a << 1;
System.out.println(Integer.toBinaryString(left1));  // 1000
int left2 = a << 2;
System.out.println(Integer.toBinaryString(left2));  // 10000
int right1 = b >> 1;
System.out.println(Integer.toBinaryString(right1)); // 10
int right2 = b >>> 1;
System.out.println(Integer.toBinaryString(right2)); // 10
int right3 = b >> 2;
System.out.println(Integer.toBinaryString(right3)); // 1</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 오브젝트의 형을 조사
// instanceof 연산자
// -----------------------------------
Object obj1 = "abc";
Object obj2 = new ArrayList<>();;
Object obj3 = null;

if(obj1 instanceof String) {
    String str = (String)obj1;
    System.out.println(str);
}

// ArrayList는 List의 実装클래스이기때문에 true
if(obj2 instanceof List)
    System.out.println("List");

// obj3는 null이기때문에 false를 반환
if(obj3 instanceof Object)
    System.out.println("Object");

// -----------------------------------
// 결과:
// abc
// List
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 캐스트
// - 업캐스트 : 보다 추상적인 형으로 변환
// - 다운캐스트: 보다 구체적인 형으로 변환
// 괄호필요, 실패시 ClassCastException
// -----------------------------------
// 업캐스트
ArrayList<String> aList = new ArrayList<>();
// ArrayList는 List인터페이스를 구현하고 있기때문에 OK
List<String> bList = aList;
// ---------------
// 다운캐스트
List<String> a = new ArrayList<>();
ArrayList<String> b = (ArrayList<String>) a;
// LinkedList<String> c = (LinkedList<String>)a; // 예외발생
// ---------------
// 클래스오브젝트의 cast()로 다운캐스트
Object obj = Integer.valueOf(1);
Integer i = Integer.class.cast(obj);</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 래퍼클래스
// 컬렉션에는 오브젝트만 넣을수 있다. 기본형은 안됨
// 오토박싱:기본형에서 래퍼클래스로의 자동변환
// 언박싱 :래퍼클래스에서 기본형으로의 자동변환
// -----------------------------------
List<Integer> list = new ArrayList<>();
int i = 0;
list.add(i);         // 오토박싱
int j = list.get(0); // 언박싱
// ---------------
// * 주의 ( remove()등 )
list.remove(0); // 0번째 요소 삭제
list.remove(Integer.valueOf(0)); // 값이 0인 요소를 삭제</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// Optional
// - java8에서 도입된 콘테이너클래스
// - 존재하는지 아닌지 알수없는 값을 표현하기 위함.
// - 값이 존재하지 않는 가능성이 있음을 명시되고, 에러방지가 가능
// - 기본형의 Optional이 존재
// OptionalInt, OptionalLong, OptionalDouble
// 래퍼형으로의 변환을 피할수 있기때문에 Optional보다 효율적이다.
// -----------------------------------
// 값을 갖는 Optional오브젝트
// of()에 null을 건네면 예외가 throw된다.
Optional<String> exist = Optional.of("123");
// 값을 가지지 않는 빈 Optional오브젝트
Optional<String> empty = Optional.empty();
// 값이 null이 아닐 경우에는 값을 갖는 Optional
// 값이 null일 경우에는 빈 Optional을 생성
String valEmpty = "";
String valNull  = null;
String valStr   = "Test String";
Optional<String> optionalEmpty = Optional.ofNullable(valEmpty);
Optional<String> optionalNull  = Optional.ofNullable(valNull);
Optional<String> optionalStr   = Optional.ofNullable(valStr);
System.out.println(exist); // Optional[123]
System.out.println(empty); // Optional.empty
System.out.println(optionalEmpty); // Optional[]
System.out.println(optionalNull);  // Optional.empty
System.out.println(optionalStr);   // Optional[Test String]
// -----------------------------------
// Optional에서는 get()로 값 취득 가능
// 값이 존재하지 않으면 NoSuchElementException발생
// 그래서, 값의 존재여부를 알수 없을때는
// orElse()이나 orElseGet()로 값이 존재하지 않을경우 디폴트값을 지정하거나
// orElseThrow()로 임의의 예외를 throw가능
// -----------------------------------
try {
    String val = optionalEmpty.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 X
try {
    String val = optionalNull.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// No value present
// 값이 존재하지 않을때, 문자열을 반환
String val1 = optionalEmpty.orElse("A");
String val2 = optionalNull.orElse("B");
String val3 = optionalStr.orElse("C");
System.out.println("[" + val1 + "]"); // []
System.out.println("[" + val2 + "]"); // [B]
System.out.println("[" + val3 + "]"); // [Test String]
// 값이 존재하지 않을때, 람다식결과를 반환
String val4 = optionalNull.orElseGet(() -> {
    return new SimpleDateFormat("yyyyMMdd").format(new Date());
});
System.out.println("[" + val4 + "]"); // [20220110]
// 값이 존재하지 않을때, 예외발생
try {
    String val5 = optionalNull.orElseThrow(() -> new Exception("값이 없다"));
    System.out.println("예외발생 X");
} catch (Exception e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// 값이 없다
// -----------------------------------
// 값이 있을 경우에만 처리함
// 값의 존재 체크후 처리
if (optionalEmpty.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 있음 : []
if (optionalNull.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 없음
// 값이 있을때만 람디식처리
optionalEmpty.ifPresent(s -> {
    System.out.println("처리[" + s + "]");
}); // 처리[]
optionalNull.ifPresent(s -> {
    System.out.println("처리[" + s + "]"); // 출력안됨
});
// -----------------------------------
// filter()
// Optional의 값이 지정한 조건을 만족하지 않는 경우,
// 빈Optional로 변환한다.
// => Optional의 값이 특정조건을 만족하는 경우에만 처리.
// -----------------------------------
// Optional 생성
String val6 = "1234567890";
Optional<String> opt6 = Optional.ofNullable(val6);
// 값이 10자 이생일 경우에만 처리함.
opt6.filter(s -> s.length() >= 10).ifPresent(s -> {
    System.out.println("처리:[" + s + "]");
});
// => 처리:[1234567890]
// -----------------------------------
// map()
// Optional의 값을 변환한, 새로운 Optional오브젝트를 생성.
// 인수의 람다식이 null일경우, 빈Optional을 반환
String val7 = "abcde";
Optional<String> opt7 = Optional.ofNullable(val7);
// 값을 대문자로 변환
Optional<String> map7 = opt7.map(s -> s.toUpperCase());
System.out.println(map7); // Optional[ABCDE]
System.out.println(map7.get()); // ABCDE
// -----------------------------------
// flatMap()
// 인수로 건네는 람다식은 Optional을 반환
// 빈Optional에대한 flatMap()은 map()과 같이 람다식을 실행하지 않고
// 빈Optional을 반환.
Optional<String> userName = Optional.ofNullable("sa");
Optional<String> password = Optional.ofNullable("sa");
boolean isValid = userName.flatMap(u -> {
    return password.map(p -> {
        return u.equals("sa") && p.equals("sa");
    });
}).orElse(false);

if(isValid)
    System.out.println("true");
else
    System.out.println("false");
// => true</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// exception
// -----------------------------------
// 호출한 곳에서 ParseException, IOException를 캐치
public void createFile() throws ParseException, IOException{
    // 1
    if(...) {
        // 처리
    } else {
        throw new IOException("실패");
    }
    // 2
    try {
        // ParseException, IOException를 스로
        
    }catch(Exception e) {
        // 그대로 스로할 경우에는 던질 예외를 throws에 적어줌
        throw e; 
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// try-with-resource
// : try블록내에서 예외발생여부와 관계없이 리소스가 
//   클로즈되는 것을 보장한다.
// : 복수선언가능(클로즈는 선언의 역순으로 실행됨)
// -----------------------------------
// 샘플1 복수선언시 ";" 으로 구분
try(InputStream in = new FileInputStream("test.txt");
        OutputStream out = new FileOutputStream("test2.txt")){
    // InputStream의 내용을 OutputStream에 씀
}
// 샘플2
// catch, try블록은 try-with-resource문 처리후 실행됨
// => 리소스가 클로즈된후 실행됨
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e) {
    e.printStackTrace();
}finally {
    System.out.println("처리종료");
}
// 샘플3
// try블록과 리소스클로즈중에 예외가 발생하면
// try블록에서 발생항 예외만 throw된다. 후자는 무시됨.
// 정보는 이하로 취득
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e){
    for(Throwable t : e.getSuppressed()) {
        t.printStackTrace();
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 스택트레이스 정보 취득
// Throwable#printStackTrace()
// : 스택트레이스를 스트림에 출력만 가능.
// Thread#getStackTrace();
// -----------------------------------
try {
    int t = 3/0;
}catch(Exception e){
    e.printStackTrace();
    System.out.println("------------------------");
    for(StackTraceElement elem : e.getStackTrace()) {
        String str = new StringBuffer()
        .append(elem.getClassName()).append(" - ")
        .append(elem.getMethodName()).append(" - ")
        .append(elem.getFileName()).append(" - ")
        .append(elem.getLineNumber()).toString();
        System.out.println(str);
    }
}
//	java.lang.ArithmeticException: / by zero
//	at old.Src001.main(Src001.java:13)
//	------------------------
//	old.Src001 - main - Src001.java - 13
// -----------------------------------
StackTraceElement[] list = Thread.currentThread().getStackTrace();
for(StackTraceElement elem : list) {
    // ...
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// *람다식
// 1) 함수의 처리를 1행으로 기술할 경우
//    식의 결과가 람다식의 반환값이 된다.
//    (인수리스트) -> 식
// 2) 복수행으로 기술할 경우
//    람다식을 {}으로 묶을때는 return문이 필요.
//    (인수리스트) -> {
//      함수처리
//      return 값;
//    }
//
// *용도
// 1) 익명클래스 대신 사용
// 2) 컬렉션 요소에 대해 사용
// -----------------------------------
// *함수형 인터페이스
// 구현해야하는 메소드가 1개의 인터페이스인 경우.
// (예 Comparator인터페이스)
// 이 함수형인터페이스를 구현한 클래스대신에 람다식을 사용 가능.
// -----------------------------------
// 기존의 익명클래스
List<String> list = Arrays.asList("Java123","Scala","Groovy");
System.out.println("1 : " + list);
list.sort(new Comparator<String>(){
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});
System.out.println("2 : " + list);
// 람다식으로 구현
list.sort((String s1, String s2) -> s2.length() - s1.length());
System.out.println("3 : " + list);
// -----------------------------------
// 1 : [Java123, Scala, Groovy]
// 2 : [Scala, Groovy, Java123]
// 3 : [Java123, Groovy, Scala]
// -----------------------------------
// *람다식의 인수가 명백한 경우에는 형생략이 가능
list.sort((s1, s2) -> s2.length() - s1.length());
// *인수가 1개인 경우에는 인수리스트의 ()생략가능
list.forEach(s -> System.out.println(s));
// Java123
// Groovy
// Scala
// -----------------------------------
// 컬렉션 요소의 조작
list.forEach(s -> System.out.println(s));
// -----------------------------------
// *람다식에서 사용가능한 외부변수
//  람다식 내부에서는 값을 변경하지 않는 외부변수는 final 취급을
//  하기때문에 참조가능 
public void outer(String message) {
    Runnable r = () -> {
        // 람다식 내부에서 outer()의 인수 참조가능
        System.out.println(message);
    }
    
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            // java8이후부터 outer()의 인수가 final이 아니라도 참조가능
            System.out.println(message);
        }
    };
}
// -----------------------------------
// 외부변수 참조 불가능한 경우
public void outer(String message) {
    Runnable run = () -> {
        // 람다식 내부에서 outer()의 인수 참조
        System.out.println(message);
    }
    // 인수에 값을 대입하면 컴파일 에러
    message = "hoge";
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// java.util.function패키지
// : 범용함수인터페이스가 준비되어있다.
// 1개 혹은 2개의 인수를 받아 처리하는 람다식이라면 이 인터페이스가 사용가능.
// 패키지내 함수인터페이스
// 인터페이스명 메소드명 설명
// 1) Function<T, R> R apply(T) 1개의 인수를 받아 결과를 반환하는 함수
// 2) BiFunction<T, U, R> R apply(T, U) 2개의 인수를 받아 결과를 반환하는 함수
// 3) UnaryOperator<T> T apply(T) 단항연산자
// 4) BinaryOperator<T> T apply(T, T) 이항연산자
// 5) Predicate<T> boolean test(T) 1개의 인수를 받는 조건식
// 6) BiPredicate<T, U> boolean test(T, U) 2개의 인수를 받는 조건식
// 7) Supplier<T> T get() 인수를 받지않고 공급만 하는 함수
// 8) Consumer<T> void accept(T) 1개의 인수를 받아 처리하는 함수(반환값없음)
// 9) BiConsumer<T, U> void accept(T, U) 2개의 인수를 받아 처리하는 함수(반환값없음)
// -----------------------------------
Function<String, Date> toDate = s -> {
    try {
        return new SimpleDateFormat("yyyy/MM/dd").parse(s);
    } catch (ParseException ex) {
        return null;
    }
};
// 함수를 직접 호출할때는 apply()를 사용
System.out.println(toDate.apply("2013/09/28"));
// -----------------------------------
// 문자열을 대문자로 변환하는 함수
UnaryOperator<String> toUpper = s -> s.toUpperCase();
String s = toUpper.apply("java");
System.out.println(s); // JAVA
// -----------------------------------
Consumer<Date> print = date -> {
    String s2 = new SimpleDateFormat("yyyy/MM/dd").format(date);
    System.out.println(s2);
};
print.accept(new Date()); // 2022/01/30
// -----------------------------------
// 문자열이 "Java"로 시작하는가 아닌가를 조사하는 함수
Predicate<String> condition = s3 -> s3.startsWith("Java");
boolean result = condition.test("JavaScript");
System.out.println(result); // true
 // -----------------------------------
// 독자적인 함수형인터페이스를 정의
// @FunctionalInterface // <= 함수형 인터페이스임을 지정
// public interface TriFunction {
// public int apply(int a, int b, int c);
// }
// 사용
TriFunction func = (a,b,c) -> a + b+ c;
System.out.println(func.apply(1,2,3)); // 6
// -----------------------------------
// 메소드의 인수로 함수형 인터페이스를 수취
// 함수형IF를 수취하는 메소드
// public DBManager {
// 	public static void exceute(Consumer<Connection> consumer) throws SQLException{
// 		try(Connection conn = getConnection()){
// 			try {
// 				consumer.accept(con); // 함수형IF호출
// 				conn.commit();
// 			}catch(Exception ex) {
// 				conn.rollback();
// 				throw ex;
// 			}
// 		}
// 	}
// }
// 호출
// DBManager.execute((conn) -> {
// 	// ... 처리
// });
// -----------------------------------
// 람다식 대신 메소드를 건네기
// 인수와 반환값의 형이 같다면, 람다식대신에 메소드참조를 쓸수 있다.
// - 메소드참조
//   1) static메소드의 경우
//      클래스명::static메소드명
//   2) 인스턴스메소드의 경우
//      인스턴스명::인스턴스메소드명
// - 컬렉션의 요소에 대한 조작을 람다식과 메소드참조를 써서 기술하면 아래와 같다.
List<String> list = Arrays.asList("java", "scala", "groovy");
// 람다식을 이용해 기술
list.forEach((a1) -> System.out.println(a1));
// 메소드참조를 이용해 기술
list.forEach(System.out::println);
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 문자열 연결
// "+"연결은 새로운 String생성
// => 컴파일시 1개의 문자열로 최적화되기때문에 효율이 나쁘다고만 볼수없다.
//    주의) 변수+리터럴, 변수간의 +.
// StringBuffer, StringBuilder의 차이
// => StringBuilder는 스레드동기화 처리가 되지 않는 대신에 StringBuffer보다 고속으로 처리됨
//    복수의 스레드에서 조작될 가능성이 있는 경우에는 StringBuilder대신에 StringBuffer를 쓴다.
// String#join()
// => 배열(가변인수도 가능)이나 리스트의 요소를 지정된 문자로 연결가능
// 가변장인수	
String str1 = String.join("-","java","recipe", "is", "Great");
System.out.println(str1); // java-recipe-is-Great
// 리스트
List<String> list2 = Arrays.asList("Java", "8", "is", "Great!");
String str2 = String.join(" ", list2);
System.out.println(str2); // Java 8 is Great!
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 문자열의 길이
// Unicode에는 서로게이트페어라는 2바이트 이상의 바이트수로
// 1글자를 표시하는 문자가 존재한다.
String str = "丈";
int len1 = str.length();
// 서로레이트글자가 포함되어있을경울 아래 메소드를 사용.
int len2 = str.codePointCount(0, str.length());
System.out.println(len1); // 1
System.out.println(len2); // 1
// 문자열의 바이트 길이를 조사
// => 일단 바이트배열로 변환후, 배열의 길이를 조사
String str2 = "こんにちは、世界";
// 문자열의 바이트길이(Windows-31J의 경우)
int sjisLen = str2.getBytes(Charset.forName("Windows-31J")).length;
// 문자열의 바이트길이(UTF-8의 경우)
int utf8Len = str2.getBytes(StandardCharsets.UTF_8).length;
System.out.println(sjisLen); // 16
System.out.println(utf8Len); // 24
// -----------------------------------
// 문자열 일부 추출
String abc1 = "ABCDEFGH";
System.out.println(abc1.substring(5)); // FGH
System.out.println(abc1.substring(2, 5)); // CDE
// -----------------------------------
// 문자열 분할
// 2번째인수는 분할수
String abc2 = "A,B,C,";
// 콤마분할
String[] result1 = abc2.split(","); // [A][B][C]
// 위와 같다
String[] result4 = abc2.split(",", 0); // [A][B][C]
// 콤마로 2개로 분할
String[] result2 = abc2.split(",", 2); // [A][B,C,]
// 콤마로 4개로 분할
String[] result3 = abc2.split(",", 4); // [A][B][C][]
// 분할수 제한없음(어미의 공백문자를 포함)
String[] result5 = abc2.split(",", -1); // [A][B][C][]
// -----------------------------------
// 문자열 비교
String src1 = "Hello";
System.out.println(src1.equals("Hello")); // true
System.out.println(src1.equalsIgnoreCase("hello")); // true
// -----------------------------------
// 문자열 치환
String src2 = "Hello World";
System.out.println(src2.replace("World", "Univ")); // Hello Univ
System.out.println(src2.replace('o', 'F')); // HellF WFrld
// -----------------------------------
// 문자열 조사
System.out.println(src2.startsWith("Hello")); // true
System.out.println(src2.startsWith("World")); // false
System.out.println(src2.endsWith("World")); // true
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 문자열 포함확인
String str1 = "Hello World. World is Wonderful.";
// "World" 최초 등장 인덱스
System.out.println(str1.indexOf("World")); // 6
// "World" 8문자 이후 등장 인덱스
System.out.println(str1.indexOf("World", 7)); // 13
// 검색결과 없음
System.out.println(str1.indexOf("Java")); // -1
// 뒤에서 처음 검색
System.out.println(str1.lastIndexOf("World")); // 13
// 12문자 전에 마지막에 등장하는 인덱스
System.out.println(str1.lastIndexOf("World", 12)); // 6
// -----------------------------------
// 대/소문자 변환
System.out.println(str1.toUpperCase());
// => HELLO WORLD. WORLD IS WONDERFUL.
System.out.println(str1.toLowerCase());
// => hello world. world is wonderful.
// -----------------------------------
// String#trim()
String str2 = "   World  . ";
System.out.println(str2.trim()); // [World .]
// -----------------------------------
// String#format()
// 서식----분류-------설명
// b/B 진리값 boolean형을 지정
// h/H 16진수 16진수를 지정
// s/S 문자열 문자열을 지정
// c/C 문자 문자를 지정
// d 정수 10진정수
// o 정수 8진정수
// x/X 정수 16진정수
// e/E 부동소수점 부동소수점 10진정수
// f 부동소수점 10진정수
// g/G 부동소수점 사사오입후 설정
// a/A 부동소수점 지수
// t/T 일시/시각 문자앞에 지정
// B 날짜 로케일고유의 월이름(January)
// A 날짜 로케일고유의 요일이름(Sunday)
// Y 날짜 년
// m 날짜 월
// d 날짜 일
// k 시각 24시간의 시
// l 시각 12시간의 시
// M 시각 분
// S 시각 초
// % 퍼센트 퍼센트표시
// n 개행 개행문자를 표시
// -----------------------------------
String str3 = "String";
boolean b = true;
int i = 127;
Date now = new Date();
System.out.println(String.format("서식:%s", str3));
// => 서식:String
System.out.println(String.format("서식:%B", b));
// => 서식:TRUE
System.out.println(String.format("서식:%d %o %x %05d", i, i, i, i));
// => 서식:127 177 7f 00127
System.out.println(String.format("서식:%4$e %3$f %2$g %1$a", 127.01, 127.02, 127.03, 127.04));
// => 서식:1.270400e+02 127.030000 127.020 0x1.fc0a3d70a3d71p6
System.out.println(String.format("서식:%tY년 %<tB %<td일 %<tk시 %<tM분 %<tS초", now));
// => 서식:2022년 2월 06일 17시 18분 27초
// -----------------------------------
// 문자코드 변환
// 변화하려면 바이트배열로 변화할 필요가 있다.
// 이때 문자코드를 지정하는 하거나,
// Charset오브젝트로 지정하는 2가지 방법이 있다.
// 명칭-----------설명
// UTF-8         8비트 유니코드
// UTF-16        16비트 유니코드
// UTF-16BE      16비트 유니코드 빅엔디언
// UTF-16LE      16비트 유니코드 리틀엔디언
// Shift_JIS     일본어 문자 인코드
// windows-31j   윈도우계 OS의 표준문자 인코드 
// EUC-JP        유닉스/리눅스에서 많이 쓰이는 일본어 문자인코드
// ISO-2022-JP   인터넷, 이메일등에서 많이 쓰이는 일본어 문자인코드
try {
    // 문자코드 지정
    byte[] b1 = "こんにちわ、世界".getBytes("UTF8");
} catch(UnsupportedEncodingException e) {
    e.printStackTrace();
}
// Charset이용
Charset cs = Charset.forName("UTF-8");
byte[] b2 = "こんにちわ、世界".getBytes(cs);
// StandardCharsets문자코드를 지정
byte[] b3 = "こんにちわ、世界".getBytes(StandardCharsets.UTF_8);
// -----------------------------------
// 문자열을 수치로 변환
// Integer#parseInt()
// Long#parseLong()
// Double#parseDouble()
// => 변화안되는 문자일경우 , NumberFormatException 발생
// 수치를 문자열로 변환
// String#valueOf()
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">		// -----------------------------------
// java.util.regex.Pattern
// => 정규표현을 문자열로 지정하고, 정규표현자체를 나타내는 클래스
// java.util.regex.Matcher
// => 컴파일후의 Pattern오브젝트를 받아, 검색결과를 받는 클래스
// *Pattern클래스는 compile()로 생성.
// compile()의 두번째 인수
// => CASE_INSENSITIVE
// :대/소문자 구별하지 않는 매칭
// => UNICODE_CASE
// :Unicode준거한 대소문자 구별하지않는 매칭
// => MULTILINE
// :복수행모드
// => DOTALL
// :.은 행말기호를 포함하는 임의의 문자에 매칭
// => UNIX_LINES
// :Unix라인모드
// => COMMENTS
// :패턴내에 공백과 코멘트를 사용가능하도록 함.
// *문자열이 정규표현과 일치하는지 조사는 Matcher#matches().
// 정규표현
Pattern pattern = Pattern.compile(".*many.*");
// Matcher오브젝트를 취득
Matcher matcher = pattern.matcher("Java Recipe has many Recipes!!");
// 일치하는지 조사
boolean result = matcher.matches();
System.out.println(result); // true
// ------------
// 이스케이프
// [INFO]로 시작하는지 조사
String  str1 = "[INFO]info message";
Pattern ptn1 = Pattern.compile("^\\[INFO\\]");
Matcher mat1 = ptn1.matcher(str1);
boolean ret1 = mat1.find();
System.out.println(ret1); // true
Pattern ptn2 = Pattern.compile("^\\Q[INFO\\E]");
Matcher mat2 = ptn2.matcher(str1);
boolean ret2 = mat2.find();
System.out.println(ret2); // true	
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">/////////////////////////////////////////////////////////////////////////////
// Matcher#find()
// Matcher#group()
/////////////////////////////////////////////////////////////////////////////
// 正規表現で文字列を検索する。
/////////////////////////////////////////////////////////////////////////////
{
	Pattern pattern = Pattern.compile("Recipe.");
	// "Java Recipe has many Recipes!!"を検索
	Matcher matcher = pattern.matcher("Java Recipe has many Recipes!!");
	// 正規表現にヒットした単語の取り出し
	// find()メソッドがfalseを返却するまでループ ★
	while (matcher.find()) {
		// group()メソッドを呼び出して、正規表現にヒットした文字列を取り出す
		String group = matcher.group();
		System.out.println(group); // => 一度目は"Recipe ", 二度目は"Recipes"
	}
}
/////////////////////////////////////////////////////////////////////////////
// マッチした文字列の一部を取得
// ( )로 감싸서 그룹화가 가능.
// Matcher#group(int) => 특정그룹에 매칭되는 부분을 추출.
/////////////////////////////////////////////////////////////////////////////
{
	// 2つのグループを含む正規表現
	Pattern pattern = Pattern.compile("(.*):(.*)");
	// "Java Recipe : many Recipes!!"を検索
	Matcher matcher = pattern.matcher("Java Recipe : many Recipes!!");
	// 正規表現にヒットした単語の取り出し
	if (matcher.find()) {
		// group()メソッドに0を渡すと全体を取得 ★
		System.out.println(matcher.group(0)); // => "Java Recipe : many Recipes!!"
		// 1つ目のグループにマッチした部分を取得
		System.out.println(matcher.group(1)); // => "Java Recipe "
		// 2つ目のグループにマッチした部分を取得
		System.out.println(matcher.group(2)); // => " many Recipes!!"
	}
}
/////////////////////////////////////////////////////////////////////////////
// MULTILINEオプションを指定したときの行頭行末、全体の先頭、末尾の違い
// Pattern.MULTILINE를 넣으면 행단위로 매칭함.
// 문자열전체를 선두, 선미에 매칭시키려면 \A 또는 \z를 사용.
/////////////////////////////////////////////////////////////////////////////
{
	// 正規表現
	Pattern pattern2 = Pattern.compile("^many.*");
	// Matcherオブジェクトを取得、対象文字列は改行あり
	Matcher matcher2 = pattern2.matcher("Java Recipe has \nmany Recipes!!");
	System.out.println(matcher2.find()); // -> false
	// 正規表現 ★
	Pattern pattern = Pattern.compile("^many.*", Pattern.MULTILINE);
	// Matcherオブジェクトを取得、対象文字列は改行あり
	Matcher matcher = pattern.matcher("Java Recipe has \nmany Recipes!!");
	System.out.println(matcher.find()); // -> true
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">/////////////////////////////////////////////////////////////////////////////
// 正規表現で文字列を検索する。
/////////////////////////////////////////////////////////////////////////////
{
	// 置換後の文字列
	String replaceString = "レシピ ";
	// Patternをコンパイル
	Pattern pattern = Pattern.compile("Recipe.");
	// 検索結果をMatcherに格納
	Matcher matcher = pattern.matcher("Java Recipe has many Recipes!!");
	// 最初にヒットした文字列だけを置換 ★
	String result1 = matcher.replaceFirst(replaceString);
	System.out.println(result1); // => "Java レシピ has many Recipes!!"
	// 移動したmatcherのシーケンスをリセット ★
	matcher.reset ( );
	// ヒットした文字列すべてを置換 ★
	String result2 = matcher.replaceAll(replaceString);
	System.out.println(result2); // => "Java レシピ has many レシピ !!"
	// 移動したmatcherのシーケンスをリセット
	matcher.reset();
	// ヒットするごとに処理を実施
	StringBuffer replacedString = new StringBuffer();
	while (matcher.find()) {
		// ヒットした対象を置換 ★
		matcher.appendReplacement(replacedString, replaceString);
	}
	// 検索に最後にヒットした部分以降の検索対象文字列を結合 ★
	StringBuffer result3 = matcher.appendTail(replacedString);
	System.out.println(result3); // => "Java レシピ has many レシピ !!"
}
/////////////////////////////////////////////////////////////////////////////
// Stringクラスだけで正規表現を使う。
/////////////////////////////////////////////////////////////////////////////
{
	String target = "Java Recipe has many Recipes!!";
	// replaceAll()メソッドですべて置換
	String result = target.replaceAll("Recipe.", "レシピ ");
	System.out.println(result); // => "Java レシピ has many レシピ !!"
	// replaceFirst()メソッドで最初にヒットしたときだけ置換
	String result2 = target.replaceFirst("Recipe.", "レシピ ");
	System.out.println(result2); // => "Java レシピ has many Recipes!!"
	// $0を指定するとヒットしたもの全体を置換
	String result3 = target.replaceAll("Recipe", "$0 is Great ");
	System.out.println(result3); // => Java Recipe is Great has many Recipe is Great s!!
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">/////////////////////////////////////////////////////////////////////////////
// 수치처리
/////////////////////////////////////////////////////////////////////////////
// 絶対値を計算する
/////////////////////////////////////////////////////////////////////////////
{
	int result1 = Math.abs(-12); // =>12
	double result2 = Math.abs(-12.34); // =>12.34
}
/////////////////////////////////////////////////////////////////////////////
// 三角関数を計算する
/////////////////////////////////////////////////////////////////////////////
{
	double result1 = Math.sin(45);
	double result2 = Math.cos(30);
	double result3 = Math.tan(75);
}
/////////////////////////////////////////////////////////////////////////////
// 平方根を求める
/////////////////////////////////////////////////////////////////////////////
{
	double result = Math.sqrt(9); // =>3.0
}
/////////////////////////////////////////////////////////////////////////////
// 累乗を求める
/////////////////////////////////////////////////////////////////////////////
{
	double result = Math.pow(2, 3); // =>8.0
}
/////////////////////////////////////////////////////////////////////////////
// 最大・最少値を求める。
/////////////////////////////////////////////////////////////////////////////
{
	int result1 = Math.max(5, 3); // =>5
	int result2 = Math.min(5, 3); // =>3
}
/////////////////////////////////////////////////////////////////////////////
// 四捨五入する
/////////////////////////////////////////////////////////////////////////////
{
	double result1 = Math.round(0.49); // => 0.0
	double result2 = Math.round(0.51); // => 1.0
}
/////////////////////////////////////////////////////////////////////////////
// 切り上げ・切り上げする
/////////////////////////////////////////////////////////////////////////////
{
	double result1 = Math.ceil(1.09); // => 2.0
	double result2 = Math.floor(1.09); // => 1.0
}
/////////////////////////////////////////////////////////////////////////////
// オーバーフローが予想される場合の四則演算
/////////////////////////////////////////////////////////////////////////////
{
	try {
		// オーバーフローが予想される場合に加算する
		int result1 = Math.addExact(Integer.MAX_VALUE, 1);// => ArithmeticException: integer overflowがスロー
		
		// オーバーフローが予想される場合にlongをintに変換
		int result2 = Math.toIntExact(Long.MAX_VALUE); // => ArithmeticException: integer overflowがスロー
	} catch (ArithmeticException e) {
		e.printStackTrace();
	}
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">/////////////////////////////////////////////////////////////////////////////
// 수치처리
/////////////////////////////////////////////////////////////////////////////
// 絶対値を計算する
/////////////////////////////////////////////////////////////////////////////
{
	int result1 = Math.abs(-12); // =>12
	double result2 = Math.abs(-12.34); // =>12.34
}
/////////////////////////////////////////////////////////////////////////////
// 三角関数を計算する
/////////////////////////////////////////////////////////////////////////////
{
	double result1 = Math.sin(45);
	double result2 = Math.cos(30);
	double result3 = Math.tan(75);
}
/////////////////////////////////////////////////////////////////////////////
// 平方根を求める
/////////////////////////////////////////////////////////////////////////////
{
	double result = Math.sqrt(9); // =>3.0
}
/////////////////////////////////////////////////////////////////////////////
// 累乗を求める
/////////////////////////////////////////////////////////////////////////////
{
	double result = Math.pow(2, 3); // =>8.0
}
/////////////////////////////////////////////////////////////////////////////
// 最大・最少値を求める。
/////////////////////////////////////////////////////////////////////////////
{
	int result1 = Math.max(5, 3); // =>5
	int result2 = Math.min(5, 3); // =>3
}
/////////////////////////////////////////////////////////////////////////////
// 四捨五入する
/////////////////////////////////////////////////////////////////////////////
{
	double result1 = Math.round(0.49); // => 0.0
	double result2 = Math.round(0.51); // => 1.0
}
/////////////////////////////////////////////////////////////////////////////
// 切り上げ・切り上げする
/////////////////////////////////////////////////////////////////////////////
{
	double result1 = Math.ceil(1.09); // => 2.0
	double result2 = Math.floor(1.09); // => 1.0
}
/////////////////////////////////////////////////////////////////////////////
// オーバーフローが予想される場合の四則演算
// addExact()       => 지정된 수를 가산하고. 오버플로우가 발생하면 ArithmeticException을 throw.
// substractExact() => 지정된 수를 감산하고. 오버플로우가 발생하면 ArithmeticException을 throw.
// multiplyExact()  => 지정된 수를 곱하고. 오버플로우가 발생하면 ArithmeticException을 throw.
// toIntExact()     => 지정된 수를 int로 변환하고. 오버플로우가 발생하면 ArithmeticException을 throw.
/////////////////////////////////////////////////////////////////////////////
{
	try {
		// オーバーフローが予想される場合に加算する
		int result1 = Math.addExact(Integer.MAX_VALUE, 1);// => ArithmeticException: integer overflowがスロー
		
		// オーバーフローが予想される場合にlongをintに変換
		int result2 = Math.toIntExact(Long.MAX_VALUE); // => ArithmeticException: integer overflowがスロー
		
	} catch (ArithmeticException e) {
		e.printStackTrace();
	}
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">/////////////////////////////////////////////////////////////////////////////
// 수치를 임의의 형식으로 변환. 2가지방법.
// 1. NumberFormat  => 통화등 일반적인 변형.
// 2. DecimalFormat => 보다 유연한 변형.
// ///////////////////////////////////////////////////////////////////////////
// NumberFormatで整形する
// getInstance() : 범용수치포맷
/////////////////////////////////////////////////////////////////////////////
{
	// 整数値をフォーマット
	String result1 = NumberFormat.getIntegerInstance().format(1000000); // => "1,000,000"
	// 通貨形式にフォーマット
	String result2 = NumberFormat.getCurrencyInstance().format(1000000); // => " ¥1,000,000"
	// パーセント形式にフォーマット
	String result3 = NumberFormat.getPercentInstance().format(0.8); // => "80%"
}
/////////////////////////////////////////////////////////////////////////////
// ロケールを指定して整形する
/////////////////////////////////////////////////////////////////////////////
{
	// USロケールを指定
	Locale locale = Locale.US;
	String result = NumberFormat.getCurrencyInstance(locale).format(1000000); // => "$1,000,000"
}
/////////////////////////////////////////////////////////////////////////////
// DecimalFormatで整形する
/////////////////////////////////////////////////////////////////////////////
{
	// 6桁のゼロで埋めるフォーマット
	DecimalFormat zeroDF = new DecimalFormat("000,000");
	String result1 = zeroDF.format(1234); // => "001,234"
	// 負の数に▲をつけてフォーマット
	DecimalFormat negativeDF = new DecimalFormat("###,###; ▲###,###");
	String result2 = negativeDF.format(-1234); // => "▲1,234"
}</code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
</body>

</html>