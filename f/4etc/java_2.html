<!DOCTYPE html>

<head>
    <title></title>
    <!-- START -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="../../etc/androidstudio.css">
    <link rel="stylesheet" type="text/css" href="../../etc/custom.css">
    <script type="text/javascript" src="../../etc/highlight.min.js"></script>
    <script type="text/javascript" src="../../etc/highlightjs-line-numbers.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>hljs.initLineNumbersOnLoad();</script>
    <!-- E N D -->
</head>

<body>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
//
// Java 逆引きレシピ 第２版
// - 基本
//
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// static멤버를 임포트
// -----------------------------------
// 임포트 안함
double a     = 3.214;
double r     = 1.23;
long   value = Math.round(a);
double area  = r * r * Math.PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23
// 임포트 함
// import static java.lang.Math.round;
// import static java.lang.Math.PI;
double a     = 3.214;
double r     = 1.23;
long   value = round(a);
double area  = r * r * PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 리터럴
// -----------------------------------
int  oct = 040;
int  hex = 0x20;
int  bin = 0b0100000;
int    a = 100_000_000; // 수치 리터럴(7이후)
float  b = 3.14f;
double c = 3.14;  // f가 없으면 디폴트로 double
double d = 3.14d;

System.out.println("oct : " + oct); // oct:32
System.out.println("hex : " + hex); // hex:32
System.out.println("bin : " + bin); // bin:32
System.out.println("a   : " + a);   // a:100000000
System.out.println("b   : " + b);   // b:3.14
System.out.println("c   : " + c);   // c:3.14
System.out.println("d   : " + d);   // d:3.14</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 비트연산
// 비트연산/시프트연산의 결과는 반드시 int가 된다.
// 좌변, 우변중 한쪽이 long일 경우에는 결과도 long이 된다.
// -----------------------------------
// 2진수표기로 int형 생성
int a = Integer.parseInt("000000000000000000000000000100", 2);
int b = Integer.parseInt("000000000000000000000000000101", 2);
System.out.println(Integer.toBinaryString(a));   // 100
System.out.println(Integer.toBinaryString(b));   // 101
int and = a & b;
System.out.println(Integer.toBinaryString(and)); // 100
int or  = a | b;
System.out.println(Integer.toBinaryString(or));  // 101
int xor = a ^ b;
System.out.println(Integer.toBinaryString(xor)); // 1
int not = ~a;
System.out.println(Integer.toBinaryString(not));
// 11111111111111111111111111111011
// 시프트연산자
// >>  왼쪽은 시프트전의 최위비트로 채운다.
// >>> 왼쪽은 0으로 채운다.
int left1 = a << 1;
System.out.println(Integer.toBinaryString(left1));  // 1000
int left2 = a << 2;
System.out.println(Integer.toBinaryString(left2));  // 10000
int right1 = b >> 1;
System.out.println(Integer.toBinaryString(right1)); // 10
int right2 = b >>> 1;
System.out.println(Integer.toBinaryString(right2)); // 10
int right3 = b >> 2;
System.out.println(Integer.toBinaryString(right3)); // 1</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 오브젝트의 형을 조사
// instanceof 연산자
// -----------------------------------
Object obj1 = "abc";
Object obj2 = new ArrayList<>();;
Object obj3 = null;

if(obj1 instanceof String) {
    String str = (String)obj1;
    System.out.println(str);
}

// ArrayList는 List의 実装클래스이기때문에 true
if(obj2 instanceof List)
    System.out.println("List");

// obj3는 null이기때문에 false를 반환
if(obj3 instanceof Object)
    System.out.println("Object");

// -----------------------------------
// 결과:
// abc
// List
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 캐스트
// - 업캐스트 : 보다 추상적인 형으로 변환
// - 다운캐스트: 보다 구체적인 형으로 변환
// 괄호필요, 실패시 ClassCastException
// -----------------------------------
// 업캐스트
ArrayList<String> aList = new ArrayList<>();
// ArrayList는 List인터페이스를 구현하고 있기때문에 OK
List<String> bList = aList;
// ---------------
// 다운캐스트
List<String> a = new ArrayList<>();
ArrayList<String> b = (ArrayList<String>) a;
// LinkedList<String> c = (LinkedList<String>)a; // 예외발생
// ---------------
// 클래스오브젝트의 cast()로 다운캐스트
Object obj = Integer.valueOf(1);
Integer i = Integer.class.cast(obj);</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 래퍼클래스
// 컬렉션에는 오브젝트만 넣을수 있다. 기본형은 안됨
// 오토박싱:기본형에서 래퍼클래스로의 자동변환
// 언박싱 :래퍼클래스에서 기본형으로의 자동변환
// -----------------------------------
List<Integer> list = new ArrayList<>();
int i = 0;
list.add(i);         // 오토박싱
int j = list.get(0); // 언박싱
// ---------------
// * 주의 ( remove()등 )
list.remove(0); // 0번째 요소 삭제
list.remove(Integer.valueOf(0)); // 값이 0인 요소를 삭제</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// Optional
// - java8에서 도입된 콘테이너클래스
// - 존재하는지 아닌지 알수없는 값을 표현하기 위함.
// - 값이 존재하지 않는 가능성이 있음을 명시되고, 에러방지가 가능
// - 기본형의 Optional이 존재
// OptionalInt, OptionalLong, OptionalDouble
// 래퍼형으로의 변환을 피할수 있기때문에 Optional보다 효율적이다.
// -----------------------------------
// 값을 갖는 Optional오브젝트
// of()에 null을 건네면 예외가 throw된다.
Optional<String> exist = Optional.of("123");
// 값을 가지지 않는 빈 Optional오브젝트
Optional<String> empty = Optional.empty();
// 값이 null이 아닐 경우에는 값을 갖는 Optional
// 값이 null일 경우에는 빈 Optional을 생성
String valEmpty = "";
String valNull  = null;
String valStr   = "Test String";
Optional<String> optionalEmpty = Optional.ofNullable(valEmpty);
Optional<String> optionalNull  = Optional.ofNullable(valNull);
Optional<String> optionalStr   = Optional.ofNullable(valStr);
System.out.println(exist); // Optional[123]
System.out.println(empty); // Optional.empty
System.out.println(optionalEmpty); // Optional[]
System.out.println(optionalNull);  // Optional.empty
System.out.println(optionalStr);   // Optional[Test String]
// -----------------------------------
// Optional에서는 get()로 값 취득 가능
// 값이 존재하지 않으면 NoSuchElementException발생
// 그래서, 값의 존재여부를 알수 없을때는
// orElse()이나 orElseGet()로 값이 존재하지 않을경우 디폴트값을 지정하거나
// orElseThrow()로 임의의 예외를 throw가능
// -----------------------------------
try {
    String val = optionalEmpty.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 X
try {
    String val = optionalNull.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// No value present
// 값이 존재하지 않을때, 문자열을 반환
String val1 = optionalEmpty.orElse("A");
String val2 = optionalNull.orElse("B");
String val3 = optionalStr.orElse("C");
System.out.println("[" + val1 + "]"); // []
System.out.println("[" + val2 + "]"); // [B]
System.out.println("[" + val3 + "]"); // [Test String]
// 값이 존재하지 않을때, 람다식결과를 반환
String val4 = optionalNull.orElseGet(() -> {
    return new SimpleDateFormat("yyyyMMdd").format(new Date());
});
System.out.println("[" + val4 + "]"); // [20220110]
// 값이 존재하지 않을때, 예외발생
try {
    String val5 = optionalNull.orElseThrow(() -> new Exception("값이 없다"));
    System.out.println("예외발생 X");
} catch (Exception e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// 값이 없다
// -----------------------------------
// 값이 있을 경우에만 처리함
// 값의 존재 체크후 처리
if (optionalEmpty.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 있음 : []
if (optionalNull.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 없음
// 값이 있을때만 람디식처리
optionalEmpty.ifPresent(s -> {
    System.out.println("처리[" + s + "]");
}); // 처리[]
optionalNull.ifPresent(s -> {
    System.out.println("처리[" + s + "]"); // 출력안됨
});
// -----------------------------------
// filter()
// Optional의 값이 지정한 조건을 만족하지 않는 경우,
// 빈Optional로 변환한다.
// => Optional의 값이 특정조건을 만족하는 경우에만 처리.
// -----------------------------------
// Optional 생성
String val6 = "1234567890";
Optional<String> opt6 = Optional.ofNullable(val6);
// 값이 10자 이생일 경우에만 처리함.
opt6.filter(s -> s.length() >= 10).ifPresent(s -> {
    System.out.println("처리:[" + s + "]");
});
// => 처리:[1234567890]
// -----------------------------------
// map()
// Optional의 값을 변환한, 새로운 Optional오브젝트를 생성.
// 인수의 람다식이 null일경우, 빈Optional을 반환
String val7 = "abcde";
Optional<String> opt7 = Optional.ofNullable(val7);
// 값을 대문자로 변환
Optional<String> map7 = opt7.map(s -> s.toUpperCase());
System.out.println(map7); // Optional[ABCDE]
System.out.println(map7.get()); // ABCDE
// -----------------------------------
// flatMap()
// 인수로 건네는 람다식은 Optional을 반환
// 빈Optional에대한 flatMap()은 map()과 같이 람다식을 실행하지 않고
// 빈Optional을 반환.
Optional<String> userName = Optional.ofNullable("sa");
Optional<String> password = Optional.ofNullable("sa");
boolean isValid = userName.flatMap(u -> {
    return password.map(p -> {
        return u.equals("sa") && p.equals("sa");
    });
}).orElse(false);

if(isValid)
    System.out.println("true");
else
    System.out.println("false");
// => true</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// exception
// -----------------------------------
// 호출한 곳에서 ParseException, IOException를 캐치
public void createFile() throws ParseException, IOException{
    // 1
    if(...) {
        // 처리
    } else {
        throw new IOException("실패");
    }
    // 2
    try {
        // ParseException, IOException를 스로
        
    }catch(Exception e) {
        // 그대로 스로할 경우에는 던질 예외를 throws에 적어줌
        throw e; 
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// try-with-resource
// : try블록내에서 예외발생여부와 관계없이 리소스가 
//   클로즈되는 것을 보장한다.
// : 복수선언가능(클로즈는 선언의 역순으로 실행됨)
// -----------------------------------
// 샘플1 복수선언시 ";" 으로 구분
try(InputStream in = new FileInputStream("test.txt");
        OutputStream out = new FileOutputStream("test2.txt")){
    // InputStream의 내용을 OutputStream에 씀
}
// 샘플2
// catch, try블록은 try-with-resource문 처리후 실행됨
// => 리소스가 클로즈된후 실행됨
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e) {
    e.printStackTrace();
}finally {
    System.out.println("처리종료");
}
// 샘플3
// try블록과 리소스클로즈중에 예외가 발생하면
// try블록에서 발생항 예외만 throw된다. 후자는 무시됨.
// 정보는 이하로 취득
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e){
    for(Throwable t : e.getSuppressed()) {
        t.printStackTrace();
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 스택트레이스 정보 취득
// Throwable#printStackTrace()
// : 스택트레이스를 스트림에 출력만 가능.
// Thread#getStackTrace();
// -----------------------------------
try {
    int t = 3/0;
}catch(Exception e){
    e.printStackTrace();
    System.out.println("------------------------");
    for(StackTraceElement elem : e.getStackTrace()) {
        String str = new StringBuffer()
        .append(elem.getClassName()).append(" - ")
        .append(elem.getMethodName()).append(" - ")
        .append(elem.getFileName()).append(" - ")
        .append(elem.getLineNumber()).toString();
        System.out.println(str);
    }
}
//	java.lang.ArithmeticException: / by zero
//	at old.Src001.main(Src001.java:13)
//	------------------------
//	old.Src001 - main - Src001.java - 13
// -----------------------------------
StackTraceElement[] list = Thread.currentThread().getStackTrace();
for(StackTraceElement elem : list) {
    // ...
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// *람다식
// 1) 함수의 처리를 1행으로 기술할 경우
//    식의 결과가 람다식의 반환값이 된다.
//    (인수리스트) -> 식
// 2) 복수행으로 기술할 경우
//    람다식을 {}으로 묶을때는 return문이 필요.
//    (인수리스트) -> {
//      함수처리
//      return 값;
//    }
//
// *용도
// 1) 익명클래스 대신 사용
// 2) 컬렉션 요소에 대해 사용
// -----------------------------------
// *함수형 인터페이스
// 구현해야하는 메소드가 1개의 인터페이스인 경우.
// (예 Comparator인터페이스)
// 이 함수형인터페이스를 구현한 클래스대신에 람다식을 사용 가능.
// -----------------------------------
// 기존의 익명클래스
List<String> list = Arrays.asList("Java123","Scala","Groovy");
System.out.println("1 : " + list);
list.sort(new Comparator<String>(){
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});
System.out.println("2 : " + list);
// 람다식으로 구현
list.sort((String s1, String s2) -> s2.length() - s1.length());
System.out.println("3 : " + list);
// -----------------------------------
// 1 : [Java123, Scala, Groovy]
// 2 : [Scala, Groovy, Java123]
// 3 : [Java123, Groovy, Scala]
// -----------------------------------
// *람다식의 인수가 명백한 경우에는 형생략이 가능
list.sort((s1, s2) -> s2.length() - s1.length());
// *인수가 1개인 경우에는 인수리스트의 ()생략가능
list.forEach(s -> System.out.println(s));
// Java123
// Groovy
// Scala
// -----------------------------------
// 컬렉션 요소의 조작
list.forEach(s -> System.out.println(s));
// -----------------------------------
// *람다식에서 사용가능한 외부변수
//  람다식 내부에서는 값을 변경하지 않는 외부변수는 final 취급을
//  하기때문에 참조가능 
public void outer(String message) {
    Runnable r = () -> {
        // 람다식 내부에서 outer()의 인수 참조가능
        System.out.println(message);
    }
    
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            // java8이후부터 outer()의 인수가 final이 아니라도 참조가능
            System.out.println(message);
        }
    };
}
// -----------------------------------
// 외부변수 참조 불가능한 경우
public void outer(String message) {
    Runnable run = () -> {
        // 람다식 내부에서 outer()의 인수 참조
        System.out.println(message);
    }
    // 인수에 값을 대입하면 컴파일 에러
    message = "hoge";
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ----------------------------
// 문자열
// ----------------------------
// 길이
console.log("string".length); // 6
console.log(Array.from('string2').length); // 7
// ----------------------------
// 문자열양끝 공백, 탭, 개행 제거
console.log(" str ing ".trim()); // "str ing"
// ----------------------------
// 문자열 검색(검색결과없으면 -1을 반환)
// 대소문자 구분함, 인덱스를 반환
// - 대상문자열.indexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.lastIndexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.search(정규표현)
const str = 'Javascript를 배우자.';
const s1 = str.search(/Javascript/);
const s2 = str.search(/HTML/);
console.log(s1); // 0 : hit
console.log(s2); // -1 : no hit
// ----------------------------
// 문자열이 포함되어 있는가. (참/거짓을 리턴)
// - 대상문자열.includes(검색할 문자열, [검색개시 인덱스])
// 문자열로 시작하는가, 끝나는가
// - 대상문자열.startsWith(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.endsWith(검색할 문자열, [검색개시 인덱스])
const a1 = str.includes("script");
const a2 = str.startsWith("javascript");
const a3 = str.endsWith("배우자.");
console.log(a1); // true
console.log(a2); // false
console.log(a3); // true
// ----------------------------
// 문자추출
// 문자열.charAt(인덱스)
console.log("string".charAt(3)); // i
console.log("string".charAt());  // s
// 문자열.slice(시작인덱스, [종료인덱스])
// 문자열.substring(시작인덱스, [종료인덱스])
// 종료인덱스를 생략하면 문자열끝까지
// slice()음수지정가능(뒤에서부터 추출)
// slice()와 substring()은 시작idx가 종료idx보다 
// 클경우의 처리가 다름. (시작idx, 종료idx를 바꿔서 처리)
const str2 = "kwak no1";
console.log(str2.slice(2,4));       // ak
console.log(str2.substring(2,4));   // ak
console.log(str2.slice(0));         // kwak no1
console.log(str2.substring(0));     // kwak no1
console.log(str2.slice(1, -1));     // wak no
console.log(str2.substring(1, -1)); // k
console.log(str2.slice(3, 1));      // <empty string>
console.log(str2.substring(3, 1));  // wa
// ----------------------------
// 문자열.substr(시작인덱스, [취득문자수])
// @deprecated
console.log(str2.substr(1, 3));  // wak
// ----------------------------
// 문자열치환
// 문자열1/정규펴현을 문자열2로 바꿈
// 대상문자열.replace(문자열1, 문자열2)
// 대상문자열.replace(정규표현, 문자열2)
const phone = '111-2222-3333';
console.log(phone.replace(/-/g, '')); // 11122223333
// ----------------------------
// * 버튼의 디폴트 이벤트 무효화
// document.querySelector('#submitBtn')
//        .addEventListener('click'
//        , (event)=>{ event.defaultPrevented(); });
// ----------------------------
// 문자열분할
// 문자열.split([구분문자], [분할수])
// 문자열.split([정규표현], [분할수])
// 빈문자로 분할하면 한글자씩 들어간 배열이 리턴
// 인수를 생략하면 하나의 전체문자열이 들어간 배열 리턴
// ----------------------------
// 문자열결합
// 문자열1+문자열2+문자열3
// `${문자열1}${문자열2}${문자열3}`
// ----------------------------
// 문자열변환
// 대 - 소문자
// 문자열.toLowerCase()
// 문자열.toUpperCase()
// ----------------------------
// 정규표현
// "/패턴/"형식으로 사용
// -----------
// 패턴     의미
// x        x라는 1문자    
// xyx      xyz라는 문자열
// [xyz]    xyz중 1문자
// [a-z]    a~z중 1문자
// [^xyz]   xyz이외의 1문자
// [^a-z]   a~z이외의 1문자
// abc|xyz  abc 또는 xyz라는 문자열
// {숫자}   반복횟수
// ^x       첫문자가 x
// x$       마지막 문자가 x
// .        개행문자를 제외한 1문자
// x*       x가 0개 이상 반복
// \        다음문자를 이스케이프함
// \d       숫자     => [0~9]
// \D       숫자이외 => [^0~9]
// \w       영문자, 언더스코어 => [A-Za-z0-9_]
// \s       스페이스, 탭, 개행문자등의 공백문자
// \S       공백이외의 문자 => [^\s]
// \t       수평탭
// \n       개행문자
// -----------
// 조건에 매치하는 문자열 검색
// /패턴/.test(문자열)
console.log(/J/.test('Javasscript'));     // true
console.log(/^iP/.test('iPhone'));        // true
console.log(/iP$/.test('iPhone'));        // false
// 숫자포함
console.log(/\d/.test('iPh4one'));        // true
// a가 0회 이상 반복
console.log(/java.*/.test('javascript'));  // true
console.log(/java.*/.test('javasscript')); // true
console.log(/\d+-\d+-\d+/.test('090-1234-5678'));    // true
// 0에서 시작해서 10혹은 11자의 숫자인가 확인
console.log(/^[0][0-9]{9,10}$/.test('01234567890')); // true
// ----------------------------
// 소수점 표현
// 수치.toFixed([문자수]); // 소수점이하를 지정한 문자수로 한다.
// 수치.toPrecision([문자수]); // 지정문자수를 精度로 한다.
console.log((0.3333).toFixed(2)); // 0.33
console.log((0.3353).toFixed(2)); // 0.34
console.log((123.456).toFixed(3)); // 123.456
// ------------
console.log((0.3333).toPrecision(2)); // 0.33
console.log((0.3353).toPrecision(2)); // 0.34
console.log((123.456).toPrecision(3)); // 123
// 精度4에 의해 0이 매꿔짐
console.log((10).toPrecision(4)); // 10.00
// ----------------------------
const sndElem  = document.querySelector('.second');
// 3초후가 골
const goalTime = new Date().getTime() + 3 * 1000;
update();
function update(){
    // 현재시작
    const currentTime = new Date().getTime();
    // 남은시간
    const leftTime = goalTime - currentTime;
    if(leftTime < 0) return;
    // 초를 표시.소수점(미리초는 2자만)
    sndElem.innerText = (leftTime/1000).toFixed(2);
    // ★ 다음 프레임에서 다시 update를 실행
    requestAnimationFrame(update);
}
// ----------------------------
// 문자열 반복
// 문자열.padStart(반복할 길이, [추가할 문자열])
// 문자열.padEnd(반복할 길이, [추가할 문자열])
console.log('5'.padStart(2, '0'));  //  05
console.log('ff'.padEnd(6, '0'));   //  ff0000
console.log('ff'.padEnd(6));        // "ff    "
console.log('123'.padStart(3,'0')); // 123
function zeroPadding(num){
    return String(num).padStart(2, '0');
}
// ----------------------------
// 문자열을 URI인코드
// encodeURIComponent()는 다음 문자도 이스케이프함
// / ? & = + : @ $ ; , #
var uri1 = encodeURI('http://www.한글.com/주소.html');
console.log(uri1);
// http://www.%ED%95%9C%EA%B8%80.com/%EC%A3%BC%EC%86%8C.html
var uri2 = encodeURIComponent('http://www.한글.com/주소.html');
console.log(uri2);
// http%3A%2F%2Fwww.%ED%95%9C%EA%B8%80.com%2F%EC%A3%BC%EC%86%8C.html
// 디코드
console.log(decodeURI(uri1));
// http://www.한글.com/주소.html
console.log(decodeURIComponent(uri2));
// http://www.한글.com/주소.html
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
<pre><code class="java"></code></pre>
<!-- ############################################# -->
</body>

</html>