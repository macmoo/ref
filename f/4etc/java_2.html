<!DOCTYPE html>

<head>
    <title></title>
    <!-- START -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- <link rel="stylesheet" type="text/css" href="../../etc/androidstudio.css"> -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/monokai-sublime.min.css">
    <link rel="stylesheet" type="text/css" href="../../etc/custom.css">
    <script type="text/javascript" src="../../etc/highlight.min.js"></script>
    <script type="text/javascript" src="../../etc/highlightjs-line-numbers.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>hljs.initLineNumbersOnLoad();</script>
    <!-- E N D -->
</head>

<body>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
//
// Java 逆引きレシピ 第２版
// - 基本
//
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// static멤버를 임포트
// -----------------------------------
// 임포트 안함
double a     = 3.214;
double r     = 1.23;
long   value = Math.round(a);
double area  = r * r * Math.PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23
// 임포트 함
// import static java.lang.Math.round;
// import static java.lang.Math.PI;
double a     = 3.214;
double r     = 1.23;
long   value = round(a);
double area  = r * r * PI;
System.out.println("a:"+ a); // a:3.214
System.out.println("r:"+ r); // r:1.23</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 리터럴
// -----------------------------------
int  oct = 040;
int  hex = 0x20;
int  bin = 0b0100000;
int    a = 100_000_000; // 수치 리터럴(7이후)
float  b = 3.14f;
double c = 3.14;  // f가 없으면 디폴트로 double
double d = 3.14d;

System.out.println("oct : " + oct); // oct:32
System.out.println("hex : " + hex); // hex:32
System.out.println("bin : " + bin); // bin:32
System.out.println("a   : " + a);   // a:100000000
System.out.println("b   : " + b);   // b:3.14
System.out.println("c   : " + c);   // c:3.14
System.out.println("d   : " + d);   // d:3.14</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 비트연산
// 비트연산/시프트연산의 결과는 반드시 int가 된다.
// 좌변, 우변중 한쪽이 long일 경우에는 결과도 long이 된다.
// -----------------------------------
// 2진수표기로 int형 생성
int a = Integer.parseInt("000000000000000000000000000100", 2);
int b = Integer.parseInt("000000000000000000000000000101", 2);
System.out.println(Integer.toBinaryString(a));   // 100
System.out.println(Integer.toBinaryString(b));   // 101
int and = a & b;
System.out.println(Integer.toBinaryString(and)); // 100
int or  = a | b;
System.out.println(Integer.toBinaryString(or));  // 101
int xor = a ^ b;
System.out.println(Integer.toBinaryString(xor)); // 1
int not = ~a;
System.out.println(Integer.toBinaryString(not));
// 11111111111111111111111111111011
// 시프트연산자
// >>  왼쪽은 시프트전의 최위비트로 채운다.
// >>> 왼쪽은 0으로 채운다.
int left1 = a << 1;
System.out.println(Integer.toBinaryString(left1));  // 1000
int left2 = a << 2;
System.out.println(Integer.toBinaryString(left2));  // 10000
int right1 = b >> 1;
System.out.println(Integer.toBinaryString(right1)); // 10
int right2 = b >>> 1;
System.out.println(Integer.toBinaryString(right2)); // 10
int right3 = b >> 2;
System.out.println(Integer.toBinaryString(right3)); // 1</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 오브젝트의 형을 조사
// instanceof 연산자
// -----------------------------------
Object obj1 = "abc";
Object obj2 = new ArrayList<>();;
Object obj3 = null;

if(obj1 instanceof String) {
    String str = (String)obj1;
    System.out.println(str);
}

// ArrayList는 List의 実装클래스이기때문에 true
if(obj2 instanceof List)
    System.out.println("List");

// obj3는 null이기때문에 false를 반환
if(obj3 instanceof Object)
    System.out.println("Object");

// -----------------------------------
// 결과:
// abc
// List
// -----------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 캐스트
// - 업캐스트 : 보다 추상적인 형으로 변환
// - 다운캐스트: 보다 구체적인 형으로 변환
// 괄호필요, 실패시 ClassCastException
// -----------------------------------
// 업캐스트
ArrayList<String> aList = new ArrayList<>();
// ArrayList는 List인터페이스를 구현하고 있기때문에 OK
List<String> bList = aList;
// ---------------
// 다운캐스트
List<String> a = new ArrayList<>();
ArrayList<String> b = (ArrayList<String>) a;
// LinkedList<String> c = (LinkedList<String>)a; // 예외발생
// ---------------
// 클래스오브젝트의 cast()로 다운캐스트
Object obj = Integer.valueOf(1);
Integer i = Integer.class.cast(obj);</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 래퍼클래스
// 컬렉션에는 오브젝트만 넣을수 있다. 기본형은 안됨
// 오토박싱:기본형에서 래퍼클래스로의 자동변환
// 언박싱 :래퍼클래스에서 기본형으로의 자동변환
// -----------------------------------
List<Integer> list = new ArrayList<>();
int i = 0;
list.add(i);         // 오토박싱
int j = list.get(0); // 언박싱
// ---------------
// * 주의 ( remove()등 )
list.remove(0); // 0번째 요소 삭제
list.remove(Integer.valueOf(0)); // 값이 0인 요소를 삭제</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// Optional
// - java8에서 도입된 콘테이너클래스
// - 존재하는지 아닌지 알수없는 값을 표현하기 위함.
// - 값이 존재하지 않는 가능성이 있음을 명시되고, 에러방지가 가능
// - 기본형의 Optional이 존재
// OptionalInt, OptionalLong, OptionalDouble
// 래퍼형으로의 변환을 피할수 있기때문에 Optional보다 효율적이다.
// -----------------------------------
// 값을 갖는 Optional오브젝트
// of()에 null을 건네면 예외가 throw된다.
Optional<String> exist = Optional.of("123");
// 값을 가지지 않는 빈 Optional오브젝트
Optional<String> empty = Optional.empty();
// 값이 null이 아닐 경우에는 값을 갖는 Optional
// 값이 null일 경우에는 빈 Optional을 생성
String valEmpty = "";
String valNull  = null;
String valStr   = "Test String";
Optional<String> optionalEmpty = Optional.ofNullable(valEmpty);
Optional<String> optionalNull  = Optional.ofNullable(valNull);
Optional<String> optionalStr   = Optional.ofNullable(valStr);
System.out.println(exist); // Optional[123]
System.out.println(empty); // Optional.empty
System.out.println(optionalEmpty); // Optional[]
System.out.println(optionalNull);  // Optional.empty
System.out.println(optionalStr);   // Optional[Test String]
// -----------------------------------
// Optional에서는 get()로 값 취득 가능
// 값이 존재하지 않으면 NoSuchElementException발생
// 그래서, 값의 존재여부를 알수 없을때는
// orElse()이나 orElseGet()로 값이 존재하지 않을경우 디폴트값을 지정하거나
// orElseThrow()로 임의의 예외를 throw가능
// -----------------------------------
try {
    String val = optionalEmpty.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 X
try {
    String val = optionalNull.get();
    System.out.println("예외발생 X");
} catch (NoSuchElementException e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// No value present
// 값이 존재하지 않을때, 문자열을 반환
String val1 = optionalEmpty.orElse("A");
String val2 = optionalNull.orElse("B");
String val3 = optionalStr.orElse("C");
System.out.println("[" + val1 + "]"); // []
System.out.println("[" + val2 + "]"); // [B]
System.out.println("[" + val3 + "]"); // [Test String]
// 값이 존재하지 않을때, 람다식결과를 반환
String val4 = optionalNull.orElseGet(() -> {
    return new SimpleDateFormat("yyyyMMdd").format(new Date());
});
System.out.println("[" + val4 + "]"); // [20220110]
// 값이 존재하지 않을때, 예외발생
try {
    String val5 = optionalNull.orElseThrow(() -> new Exception("값이 없다"));
    System.out.println("예외발생 X");
} catch (Exception e) {
    System.out.println("예외발생 O");
    System.out.println(e.getMessage());
}
// => 예외발생 O
// 값이 없다
// -----------------------------------
// 값이 있을 경우에만 처리함
// 값의 존재 체크후 처리
if (optionalEmpty.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 있음 : []
if (optionalNull.isPresent()) {
    System.out.println("값 있음 : [" + optionalEmpty.get() + "]");
} else {
    System.out.println("값 없음");
}
// => 값 없음
// 값이 있을때만 람디식처리
optionalEmpty.ifPresent(s -> {
    System.out.println("처리[" + s + "]");
}); // 처리[]
optionalNull.ifPresent(s -> {
    System.out.println("처리[" + s + "]"); // 출력안됨
});
// -----------------------------------
// filter()
// Optional의 값이 지정한 조건을 만족하지 않는 경우,
// 빈Optional로 변환한다.
// => Optional의 값이 특정조건을 만족하는 경우에만 처리.
// -----------------------------------
// Optional 생성
String val6 = "1234567890";
Optional<String> opt6 = Optional.ofNullable(val6);
// 값이 10자 이생일 경우에만 처리함.
opt6.filter(s -> s.length() >= 10).ifPresent(s -> {
    System.out.println("처리:[" + s + "]");
});
// => 처리:[1234567890]
// -----------------------------------
// map()
// Optional의 값을 변환한, 새로운 Optional오브젝트를 생성.
// 인수의 람다식이 null일경우, 빈Optional을 반환
String val7 = "abcde";
Optional<String> opt7 = Optional.ofNullable(val7);
// 값을 대문자로 변환
Optional<String> map7 = opt7.map(s -> s.toUpperCase());
System.out.println(map7); // Optional[ABCDE]
System.out.println(map7.get()); // ABCDE
// -----------------------------------
// flatMap()
// 인수로 건네는 람다식은 Optional을 반환
// 빈Optional에대한 flatMap()은 map()과 같이 람다식을 실행하지 않고
// 빈Optional을 반환.
Optional<String> userName = Optional.ofNullable("sa");
Optional<String> password = Optional.ofNullable("sa");
boolean isValid = userName.flatMap(u -> {
    return password.map(p -> {
        return u.equals("sa") && p.equals("sa");
    });
}).orElse(false);

if(isValid)
    System.out.println("true");
else
    System.out.println("false");
// => true</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// exception
// -----------------------------------
// 호출한 곳에서 ParseException, IOException를 캐치
public void createFile() throws ParseException, IOException{
    // 1
    if(...) {
        // 처리
    } else {
        throw new IOException("실패");
    }
    // 2
    try {
        // ParseException, IOException를 스로
        
    }catch(Exception e) {
        // 그대로 스로할 경우에는 던질 예외를 throws에 적어줌
        throw e; 
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// try-with-resource
// : try블록내에서 예외발생여부와 관계없이 리소스가 
//   클로즈되는 것을 보장한다.
// : 복수선언가능(클로즈는 선언의 역순으로 실행됨)
// -----------------------------------
// 샘플1 복수선언시 ";" 으로 구분
try(InputStream in = new FileInputStream("test.txt");
        OutputStream out = new FileOutputStream("test2.txt")){
    // InputStream의 내용을 OutputStream에 씀
}
// 샘플2
// catch, try블록은 try-with-resource문 처리후 실행됨
// => 리소스가 클로즈된후 실행됨
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e) {
    e.printStackTrace();
}finally {
    System.out.println("처리종료");
}
// 샘플3
// try블록과 리소스클로즈중에 예외가 발생하면
// try블록에서 발생항 예외만 throw된다. 후자는 무시됨.
// 정보는 이하로 취득
try(InputStream in = new FileInputStream("test.txt")){
    // ...
}catch(IOException e){
    for(Throwable t : e.getSuppressed()) {
        t.printStackTrace();
    }
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 스택트레이스 정보 취득
// Throwable#printStackTrace()
// : 스택트레이스를 스트림에 출력만 가능.
// Thread#getStackTrace();
// -----------------------------------
try {
    int t = 3/0;
}catch(Exception e){
    e.printStackTrace();
    System.out.println("------------------------");
    for(StackTraceElement elem : e.getStackTrace()) {
        String str = new StringBuffer()
        .append(elem.getClassName()).append(" - ")
        .append(elem.getMethodName()).append(" - ")
        .append(elem.getFileName()).append(" - ")
        .append(elem.getLineNumber()).toString();
        System.out.println(str);
    }
}
//	java.lang.ArithmeticException: / by zero
//	at old.Src001.main(Src001.java:13)
//	------------------------
//	old.Src001 - main - Src001.java - 13
// -----------------------------------
StackTraceElement[] list = Thread.currentThread().getStackTrace();
for(StackTraceElement elem : list) {
    // ...
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// *람다식
// 1) 함수의 처리를 1행으로 기술할 경우
//    식의 결과가 람다식의 반환값이 된다.
//    (인수리스트) -> 식
// 2) 복수행으로 기술할 경우
//    람다식을 {}으로 묶을때는 return문이 필요.
//    (인수리스트) -> {
//      함수처리
//      return 값;
//    }
//
// *용도
// 1) 익명클래스 대신 사용
// 2) 컬렉션 요소에 대해 사용
// -----------------------------------
// *함수형 인터페이스
// 구현해야하는 메소드가 1개의 인터페이스인 경우.
// (예 Comparator인터페이스)
// 이 함수형인터페이스를 구현한 클래스대신에 람다식을 사용 가능.
// -----------------------------------
// 기존의 익명클래스
List<String> list = Arrays.asList("Java123","Scala","Groovy");
System.out.println("1 : " + list);
list.sort(new Comparator<String>(){
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});
System.out.println("2 : " + list);
// 람다식으로 구현
list.sort((String s1, String s2) -> s2.length() - s1.length());
System.out.println("3 : " + list);
// -----------------------------------
// 1 : [Java123, Scala, Groovy]
// 2 : [Scala, Groovy, Java123]
// 3 : [Java123, Groovy, Scala]
// -----------------------------------
// *람다식의 인수가 명백한 경우에는 형생략이 가능
list.sort((s1, s2) -> s2.length() - s1.length());
// *인수가 1개인 경우에는 인수리스트의 ()생략가능
list.forEach(s -> System.out.println(s));
// Java123
// Groovy
// Scala
// -----------------------------------
// 컬렉션 요소의 조작
list.forEach(s -> System.out.println(s));
// -----------------------------------
// *람다식에서 사용가능한 외부변수
//  람다식 내부에서는 값을 변경하지 않는 외부변수는 final 취급을
//  하기때문에 참조가능 
public void outer(String message) {
    Runnable r = () -> {
        // 람다식 내부에서 outer()의 인수 참조가능
        System.out.println(message);
    }
    
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            // java8이후부터 outer()의 인수가 final이 아니라도 참조가능
            System.out.println(message);
        }
    };
}
// -----------------------------------
// 외부변수 참조 불가능한 경우
public void outer(String message) {
    Runnable run = () -> {
        // 람다식 내부에서 outer()의 인수 참조
        System.out.println(message);
    }
    // 인수에 값을 대입하면 컴파일 에러
    message = "hoge";
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// java.util.function패키지
// : 범용함수인터페이스가 준비되어있다.
// 1개 혹은 2개의 인수를 받아 처리하는 람다식이라면 이 인터페이스가 사용가능.
// 패키지내 함수인터페이스
// 인터페이스명 메소드명 설명
// 1) Function<T, R> R apply(T) 1개의 인수를 받아 결과를 반환하는 함수
// 2) BiFunction<T, U, R> R apply(T, U) 2개의 인수를 받아 결과를 반환하는 함수
// 3) UnaryOperator<T> T apply(T) 단항연산자
// 4) BinaryOperator<T> T apply(T, T) 이항연산자
// 5) Predicate<T> boolean test(T) 1개의 인수를 받는 조건식
// 6) BiPredicate<T, U> boolean test(T, U) 2개의 인수를 받는 조건식
// 7) Supplier<T> T get() 인수를 받지않고 공급만 하는 함수
// 8) Consumer<T> void accept(T) 1개의 인수를 받아 처리하는 함수(반환값없음)
// 9) BiConsumer<T, U> void accept(T, U) 2개의 인수를 받아 처리하는 함수(반환값없음)
// -----------------------------------
Function<String, Date> toDate = s -> {
    try {
        return new SimpleDateFormat("yyyy/MM/dd").parse(s);
    } catch (ParseException ex) {
        return null;
    }
};
// 함수를 직접 호출할때는 apply()를 사용
System.out.println(toDate.apply("2013/09/28"));
// -----------------------------------
// 문자열을 대문자로 변환하는 함수
UnaryOperator<String> toUpper = s -> s.toUpperCase();
String s = toUpper.apply("java");
System.out.println(s); // JAVA
// -----------------------------------
Consumer<Date> print = date -> {
    String s2 = new SimpleDateFormat("yyyy/MM/dd").format(date);
    System.out.println(s2);
};
print.accept(new Date()); // 2022/01/30
// -----------------------------------
// 문자열이 "Java"로 시작하는가 아닌가를 조사하는 함수
Predicate<String> condition = s3 -> s3.startsWith("Java");
boolean result = condition.test("JavaScript");
System.out.println(result); // true
 // -----------------------------------
// 독자적인 함수형인터페이스를 정의
// @FunctionalInterface // <= 함수형 인터페이스임을 지정
// public interface TriFunction {
// public int apply(int a, int b, int c);
// }
// 사용
TriFunction func = (a,b,c) -> a + b+ c;
System.out.println(func.apply(1,2,3)); // 6
// -----------------------------------
// 메소드의 인수로 함수형 인터페이스를 수취
// 함수형IF를 수취하는 메소드
// public DBManager {
// 	public static void exceute(Consumer<Connection> consumer) throws SQLException{
// 		try(Connection conn = getConnection()){
// 			try {
// 				consumer.accept(con); // 함수형IF호출
// 				conn.commit();
// 			}catch(Exception ex) {
// 				conn.rollback();
// 				throw ex;
// 			}
// 		}
// 	}
// }
// 호출
// DBManager.execute((conn) -> {
// 	// ... 처리
// });
// -----------------------------------
// 람다식 대신 메소드를 건네기
// 인수와 반환값의 형이 같다면, 람다식대신에 메소드참조를 쓸수 있다.
// - 메소드참조
//   1) static메소드의 경우
//      클래스명::static메소드명
//   2) 인스턴스메소드의 경우
//      인스턴스명::인스턴스메소드명
// - 컬렉션의 요소에 대한 조작을 람다식과 메소드참조를 써서 기술하면 아래와 같다.
List<String> list = Arrays.asList("java", "scala", "groovy");
// 람다식을 이용해 기술
list.forEach((a1) -> System.out.println(a1));
// 메소드참조를 이용해 기술
list.forEach(System.out::println);
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 문자열 연결
// "+"연결은 새로운 String생성
// => 컴파일시 1개의 문자열로 최적화되기때문에 효율이 나쁘다고만 볼수없다.
//    주의) 변수+리터럴, 변수간의 +.
// StringBuffer, StringBuilder의 차이
// => StringBuilder는 스레드동기화 처리가 되지 않는 대신에 StringBuffer보다 고속으로 처리됨
//    복수의 스레드에서 조작될 가능성이 있는 경우에는 StringBuilder대신에 StringBuffer를 쓴다.
// String#join()
// => 배열(가변인수도 가능)이나 리스트의 요소를 지정된 문자로 연결가능
// 가변장인수	
String str1 = String.join("-","java","recipe", "is", "Great");
System.out.println(str1); // java-recipe-is-Great
// 리스트
List<String> list2 = Arrays.asList("Java", "8", "is", "Great!");
String str2 = String.join(" ", list2);
System.out.println(str2); // Java 8 is Great!
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 문자열의 길이
// Unicode에는 서로게이트페어라는 2바이트 이상의 바이트수로
// 1글자를 표시하는 문자가 존재한다.
String str = "丈";
int len1 = str.length();
// 서로레이트글자가 포함되어있을경울 아래 메소드를 사용.
int len2 = str.codePointCount(0, str.length());
System.out.println(len1); // 1
System.out.println(len2); // 1
// 문자열의 바이트 길이를 조사
// => 일단 바이트배열로 변환후, 배열의 길이를 조사
String str2 = "こんにちは、世界";
// 문자열의 바이트길이(Windows-31J의 경우)
int sjisLen = str2.getBytes(Charset.forName("Windows-31J")).length;
// 문자열의 바이트길이(UTF-8의 경우)
int utf8Len = str2.getBytes(StandardCharsets.UTF_8).length;
System.out.println(sjisLen); // 16
System.out.println(utf8Len); // 24
// -----------------------------------
// 문자열 일부 추출
String abc1 = "ABCDEFGH";
System.out.println(abc1.substring(5)); // FGH
System.out.println(abc1.substring(2, 5)); // CDE
// -----------------------------------
// 문자열 분할
// 2번째인수는 분할수
String abc2 = "A,B,C,";
// 콤마분할
String[] result1 = abc2.split(","); // [A][B][C]
// 위와 같다
String[] result4 = abc2.split(",", 0); // [A][B][C]
// 콤마로 2개로 분할
String[] result2 = abc2.split(",", 2); // [A][B,C,]
// 콤마로 4개로 분할
String[] result3 = abc2.split(",", 4); // [A][B][C][]
// 분할수 제한없음(어미의 공백문자를 포함)
String[] result5 = abc2.split(",", -1); // [A][B][C][]
// -----------------------------------
// 문자열 비교
String src1 = "Hello";
System.out.println(src1.equals("Hello")); // true
System.out.println(src1.equalsIgnoreCase("hello")); // true
// -----------------------------------
// 문자열 치환
String src2 = "Hello World";
System.out.println(src2.replace("World", "Univ")); // Hello Univ
System.out.println(src2.replace('o', 'F')); // HellF WFrld
// -----------------------------------
// 문자열 조사
System.out.println(src2.startsWith("Hello")); // true
System.out.println(src2.startsWith("World")); // false
System.out.println(src2.endsWith("World")); // true
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// -----------------------------------
// 문자열 포함확인
String str1 = "Hello World. World is Wonderful.";
// "World" 최초 등장 인덱스
System.out.println(str1.indexOf("World")); // 6
// "World" 8문자 이후 등장 인덱스
System.out.println(str1.indexOf("World", 7)); // 13
// 검색결과 없음
System.out.println(str1.indexOf("Java")); // -1
// 뒤에서 처음 검색
System.out.println(str1.lastIndexOf("World")); // 13
// 12문자 전에 마지막에 등장하는 인덱스
System.out.println(str1.lastIndexOf("World", 12)); // 6
// -----------------------------------
// 대/소문자 변환
System.out.println(str1.toUpperCase());
// => HELLO WORLD. WORLD IS WONDERFUL.
System.out.println(str1.toLowerCase());
// => hello world. world is wonderful.
// -----------------------------------
// String#trim()
String str2 = "   World  . ";
System.out.println(str2.trim()); // [World .]
// -----------------------------------
// String#format()
// 서식----분류-------설명
// b/B 진리값 boolean형을 지정
// h/H 16진수 16진수를 지정
// s/S 문자열 문자열을 지정
// c/C 문자 문자를 지정
// d 정수 10진정수
// o 정수 8진정수
// x/X 정수 16진정수
// e/E 부동소수점 부동소수점 10진정수
// f 부동소수점 10진정수
// g/G 부동소수점 사사오입후 설정
// a/A 부동소수점 지수
// t/T 일시/시각 문자앞에 지정
// B 날짜 로케일고유의 월이름(January)
// A 날짜 로케일고유의 요일이름(Sunday)
// Y 날짜 년
// m 날짜 월
// d 날짜 일
// k 시각 24시간의 시
// l 시각 12시간의 시
// M 시각 분
// S 시각 초
// % 퍼센트 퍼센트표시
// n 개행 개행문자를 표시
// -----------------------------------
String str3 = "String";
boolean b = true;
int i = 127;
Date now = new Date();
System.out.println(String.format("서식:%s", str3));
// => 서식:String
System.out.println(String.format("서식:%B", b));
// => 서식:TRUE
System.out.println(String.format("서식:%d %o %x %05d", i, i, i, i));
// => 서식:127 177 7f 00127
System.out.println(String.format("서식:%4$e %3$f %2$g %1$a", 127.01, 127.02, 127.03, 127.04));
// => 서식:1.270400e+02 127.030000 127.020 0x1.fc0a3d70a3d71p6
System.out.println(String.format("서식:%tY년 %<tB %<td일 %<tk시 %<tM분 %<tS초", now));
// => 서식:2022년 2월 06일 17시 18분 27초
// -----------------------------------
// 문자코드 변환
// 변화하려면 바이트배열로 변화할 필요가 있다.
// 이때 문자코드를 지정하는 하거나,
// Charset오브젝트로 지정하는 2가지 방법이 있다.
// 명칭-----------설명
// UTF-8         8비트 유니코드
// UTF-16        16비트 유니코드
// UTF-16BE      16비트 유니코드 빅엔디언
// UTF-16LE      16비트 유니코드 리틀엔디언
// Shift_JIS     일본어 문자 인코드
// windows-31j   윈도우계 OS의 표준문자 인코드 
// EUC-JP        유닉스/리눅스에서 많이 쓰이는 일본어 문자인코드
// ISO-2022-JP   인터넷, 이메일등에서 많이 쓰이는 일본어 문자인코드
try {
    // 문자코드 지정
    byte[] b1 = "こんにちわ、世界".getBytes("UTF8");
} catch(UnsupportedEncodingException e) {
    e.printStackTrace();
}
// Charset이용
Charset cs = Charset.forName("UTF-8");
byte[] b2 = "こんにちわ、世界".getBytes(cs);
// StandardCharsets문자코드를 지정
byte[] b3 = "こんにちわ、世界".getBytes(StandardCharsets.UTF_8);
// -----------------------------------
// 문자열을 수치로 변환
// Integer#parseInt()
// Long#parseLong()
// Double#parseDouble()
// => 변화안되는 문자일경우 , NumberFormatException 발생
// 수치를 문자열로 변환
// String#valueOf()
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">		// -----------------------------------
// java.util.regex.Pattern
// => 정규표현을 문자열로 지정하고, 정규표현자체를 나타내는 클래스
// java.util.regex.Matcher
// => 컴파일후의 Pattern오브젝트를 받아, 검색결과를 받는 클래스
// *Pattern클래스는 compile()로 생성.
// compile()의 두번째 인수
// => CASE_INSENSITIVE
// :대/소문자 구별하지 않는 매칭
// => UNICODE_CASE
// :Unicode준거한 대소문자 구별하지않는 매칭
// => MULTILINE
// :복수행모드
// => DOTALL
// :.은 행말기호를 포함하는 임의의 문자에 매칭
// => UNIX_LINES
// :Unix라인모드
// => COMMENTS
// :패턴내에 공백과 코멘트를 사용가능하도록 함.
// *문자열이 정규표현과 일치하는지 조사는 Matcher#matches().
// 정규표현
Pattern pattern = Pattern.compile(".*many.*");
// Matcher오브젝트를 취득
Matcher matcher = pattern.matcher("Java Recipe has many Recipes!!");
// 일치하는지 조사
boolean result = matcher.matches();
System.out.println(result); // true
// ------------
// 이스케이프
// [INFO]로 시작하는지 조사
String  str1 = "[INFO]info message";
Pattern ptn1 = Pattern.compile("^\\[INFO\\]");
Matcher mat1 = ptn1.matcher(str1);
boolean ret1 = mat1.find();
System.out.println(ret1); // true
Pattern ptn2 = Pattern.compile("^\\Q[INFO\\E]");
Matcher mat2 = ptn2.matcher(str1);
boolean ret2 = mat2.find();
System.out.println(ret2); // true	
// -----------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// Matcher#find()
// Matcher#group()
// ---------------------------------
// 正規表現で文字列を検索する。
// ---------------------------------
{
	Pattern pattern = Pattern.compile("Recipe.");
	// "Java Recipe has many Recipes!!"を検索
	Matcher matcher = pattern.matcher("Java Recipe has many Recipes!!");
	// 正規表現にヒットした単語の取り出し
	// find()メソッドがfalseを返却するまでループ ★
	while (matcher.find()) {
		// group()メソッドを呼び出して、正規表現にヒットした文字列を取り出す
		String group = matcher.group();
		System.out.println(group); // => 一度目は"Recipe ", 二度目は"Recipes"
	}
}
// ---------------------------------
// マッチした文字列の一部を取得
// ( )로 감싸서 그룹화가 가능.
// Matcher#group(int) => 특정그룹에 매칭되는 부분을 추출.
// ---------------------------------
{
	// 2つのグループを含む正規表現
	Pattern pattern = Pattern.compile("(.*):(.*)");
	// "Java Recipe : many Recipes!!"を検索
	Matcher matcher = pattern.matcher("Java Recipe : many Recipes!!");
	// 正規表現にヒットした単語の取り出し
	if (matcher.find()) {
		// group()メソッドに0を渡すと全体を取得 ★
		System.out.println(matcher.group(0)); // => "Java Recipe : many Recipes!!"
		// 1つ目のグループにマッチした部分を取得
		System.out.println(matcher.group(1)); // => "Java Recipe "
		// 2つ目のグループにマッチした部分を取得
		System.out.println(matcher.group(2)); // => " many Recipes!!"
	}
}
// ---------------------------------
// MULTILINEオプションを指定したときの行頭行末、全体の先頭、末尾の違い
// Pattern.MULTILINE를 넣으면 행단위로 매칭함.
// 문자열전체를 선두, 선미에 매칭시키려면 \A 또는 \z를 사용.
// ---------------------------------
{
	// 正規表現
	Pattern pattern2 = Pattern.compile("^many.*");
	// Matcherオブジェクトを取得、対象文字列は改行あり
	Matcher matcher2 = pattern2.matcher("Java Recipe has \nmany Recipes!!");
	System.out.println(matcher2.find()); // -> false
	// 正規表現 ★
	Pattern pattern = Pattern.compile("^many.*", Pattern.MULTILINE);
	// Matcherオブジェクトを取得、対象文字列は改行あり
	Matcher matcher = pattern.matcher("Java Recipe has \nmany Recipes!!");
	System.out.println(matcher.find()); // -> true
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 正規表現で文字列を検索する。
// ---------------------------------
{
	// 置換後の文字列
	String replaceString = "レシピ ";
	// Patternをコンパイル
	Pattern pattern = Pattern.compile("Recipe.");
	// 検索結果をMatcherに格納
	Matcher matcher = pattern.matcher("Java Recipe has many Recipes!!");
	// 最初にヒットした文字列だけを置換 ★
	String result1 = matcher.replaceFirst(replaceString);
	System.out.println(result1); // => "Java レシピ has many Recipes!!"
	// 移動したmatcherのシーケンスをリセット ★
	matcher.reset ( );
	// ヒットした文字列すべてを置換 ★
	String result2 = matcher.replaceAll(replaceString);
	System.out.println(result2); // => "Java レシピ has many レシピ !!"
	// 移動したmatcherのシーケンスをリセット
	matcher.reset();
	// ヒットするごとに処理を実施
	StringBuffer replacedString = new StringBuffer();
	while (matcher.find()) {
		// ヒットした対象を置換 ★
		matcher.appendReplacement(replacedString, replaceString);
	}
	// 検索に最後にヒットした部分以降の検索対象文字列を結合 ★
	StringBuffer result3 = matcher.appendTail(replacedString);
	System.out.println(result3); // => "Java レシピ has many レシピ !!"
}
// ---------------------------------
// Stringクラスだけで正規表現を使う。
// ---------------------------------
{
	String target = "Java Recipe has many Recipes!!";
	// replaceAll()メソッドですべて置換
	String result = target.replaceAll("Recipe.", "レシピ ");
	System.out.println(result); // => "Java レシピ has many レシピ !!"
	// replaceFirst()メソッドで最初にヒットしたときだけ置換
	String result2 = target.replaceFirst("Recipe.", "レシピ ");
	System.out.println(result2); // => "Java レシピ has many Recipes!!"
	// $0を指定するとヒットしたもの全体を置換
	String result3 = target.replaceAll("Recipe", "$0 is Great ");
	System.out.println(result3); // => Java Recipe is Great has many Recipe is Great s!!
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 수치처리
// ---------------------------------
// 絶対値を計算する
// ---------------------------------
{
	int result1 = Math.abs(-12); // =>12
	double result2 = Math.abs(-12.34); // =>12.34
}
// ---------------------------------
// 三角関数を計算する
// ---------------------------------
{
	double result1 = Math.sin(45);
	double result2 = Math.cos(30);
	double result3 = Math.tan(75);
}
// ---------------------------------
// 平方根を求める
// ---------------------------------
{
	double result = Math.sqrt(9); // =>3.0
}
// ---------------------------------
// 累乗を求める
// ---------------------------------
{
	double result = Math.pow(2, 3); // =>8.0
}
// ---------------------------------
// 最大・最少値を求める。
// ---------------------------------
{
	int result1 = Math.max(5, 3); // =>5
	int result2 = Math.min(5, 3); // =>3
}
// ---------------------------------
// 四捨五入する
// ---------------------------------
{
	double result1 = Math.round(0.49); // => 0.0
	double result2 = Math.round(0.51); // => 1.0
}
// ---------------------------------
// 切り上げ・切り上げする
// ---------------------------------
{
	double result1 = Math.ceil(1.09); // => 2.0
	double result2 = Math.floor(1.09); // => 1.0
}
// ---------------------------------
// オーバーフローが予想される場合の四則演算
// ---------------------------------
{
	try {
		// オーバーフローが予想される場合に加算する
		int result1 = Math.addExact(Integer.MAX_VALUE, 1);// => ArithmeticException: integer overflowがスロー
		
		// オーバーフローが予想される場合にlongをintに変換
		int result2 = Math.toIntExact(Long.MAX_VALUE); // => ArithmeticException: integer overflowがスロー
	} catch (ArithmeticException e) {
		e.printStackTrace();
	}
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 수치처리
// ---------------------------------
// 絶対値を計算する
// ---------------------------------
{
	int result1 = Math.abs(-12); // =>12
	double result2 = Math.abs(-12.34); // =>12.34
}
// ---------------------------------
// 三角関数を計算する
// ---------------------------------
{
	double result1 = Math.sin(45);
	double result2 = Math.cos(30);
	double result3 = Math.tan(75);
}
// ---------------------------------
// 平方根を求める
// ---------------------------------
{
	double result = Math.sqrt(9); // =>3.0
}
// ---------------------------------
// 累乗を求める
// ---------------------------------
{
	double result = Math.pow(2, 3); // =>8.0
}
// ---------------------------------
// 最大・最少値を求める。
// ---------------------------------
{
	int result1 = Math.max(5, 3); // =>5
	int result2 = Math.min(5, 3); // =>3
}
// ---------------------------------
// 四捨五入する
// ---------------------------------
{
	double result1 = Math.round(0.49); // => 0.0
	double result2 = Math.round(0.51); // => 1.0
}
// ---------------------------------
// 切り上げ・切り上げする
// ---------------------------------
{
	double result1 = Math.ceil(1.09); // => 2.0
	double result2 = Math.floor(1.09); // => 1.0
}
// ---------------------------------
// オーバーフローが予想される場合の四則演算
// addExact()       => 지정된 수를 가산하고. 오버플로우가 발생하면 ArithmeticException을 throw.
// substractExact() => 지정된 수를 감산하고. 오버플로우가 발생하면 ArithmeticException을 throw.
// multiplyExact()  => 지정된 수를 곱하고. 오버플로우가 발생하면 ArithmeticException을 throw.
// toIntExact()     => 지정된 수를 int로 변환하고. 오버플로우가 발생하면 ArithmeticException을 throw.
// ---------------------------------
{
	try {
		// オーバーフローが予想される場合に加算する
		int result1 = Math.addExact(Integer.MAX_VALUE, 1);// => ArithmeticException: integer overflowがスロー
		
		// オーバーフローが予想される場合にlongをintに変換
		int result2 = Math.toIntExact(Long.MAX_VALUE); // => ArithmeticException: integer overflowがスロー
		
	} catch (ArithmeticException e) {
		e.printStackTrace();
	}
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 수치를 임의의 형식으로 변환. 2가지방법.
// 1. NumberFormat  => 통화등 일반적인 변형.
// 2. DecimalFormat => 보다 유연한 변형.
// ///////////////////////////////////////////////////////////////////////////
// NumberFormatで整形する
// getInstance() : 범용수치포맷
// ---------------------------------
{
	// 整数値をフォーマット
	String result1 = NumberFormat.getIntegerInstance().format(1000000); // => "1,000,000"
	// 通貨形式にフォーマット
	String result2 = NumberFormat.getCurrencyInstance().format(1000000); // => " ¥1,000,000"
	// パーセント形式にフォーマット
	String result3 = NumberFormat.getPercentInstance().format(0.8); // => "80%"
}
// ---------------------------------
// ロケールを指定して整形する
// ---------------------------------
{
	// USロケールを指定
	Locale locale = Locale.US;
	String result = NumberFormat.getCurrencyInstance(locale).format(1000000); // => "$1,000,000"
}
// ---------------------------------
// DecimalFormatで整形する
// ---------------------------------
{
	// 6桁のゼロで埋めるフォーマット
	DecimalFormat zeroDF = new DecimalFormat("000,000");
	String result1 = zeroDF.format(1234); // => "001,234"
	// 負の数に▲をつけてフォーマット
    // 0 => 수치
    // # => 수치, 0의 경우 표시안함.
    // , => 수치의 구분문자
    // - => 마이너스
    // ; => 각기 정수와 음수의 경우.
    // ` => 특수문자를 인용부로 구분한다. 
	DecimalFormat negativeDF = new DecimalFormat("###,###; ▲###,###");
	String result2 = negativeDF.format(-1234); // => "▲1,234"
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 난수생성
// ---------------------------------
// Math#randomメソッドを使った乱数生成
// 처음random()가 호출되면 의사난수 제너레이터가 생성되어,그 다음 random()호출에 사용되어진다.
// ---------------------------------
{
	// 乱数が発生するため、実行ごとに結果は異なる
	double result1 = Math.random();
	System.out.println(result1);
	double result2 = Math.random();
	System.out.println(result2);
}
// ---------------------------------
// SecureRandomを使ったセキュアな乱数生成
// ---------------------------------
{
	// nextInt()メソッドでランダムな整数を取得
	Random r1 = new SecureRandom();
	int value1 = r1.nextInt();
	System.out.println(value1);
	int value2 = r1.nextInt();
	System.out.println(value2);

	Random r2 = SecureRandom.getInstance("SHA1PRNG");
	// アルゴリズムとシードを指定して乱数を生成
	int value3 = r2.nextInt();
	System.out.println(value3);
	int value4 = r2.nextInt();
	System.out.println(value4);

	// java8부터는 가장안전한 알고리즘을 자동으로 선택가능.
	Random r3 = SecureRandom.getInstanceStrong();
	int value5 = r3.nextInt();
	System.out.println(value5);
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
    // 丸め誤差가 발생하지 않는 계산
    // BigDecimal클래스 사용.
    // BigDecimal은 float이나 double보다 처리 시간이 길다.
    // ---------------------------------
    // doubleで計算すると丸め誤差が発生する
    double result = 1.1 + 2.2; // => 3.3000000000000003
    
    // BigDecimalのインスタンスを生成
    BigDecimal bd = new BigDecimal("1.1");
    // BigDecimalの足し算、引き算、乗算
    BigDecimal bdAdd = new BigDecimal("2.2").add(bd); // => 3.3
    BigDecimal bdSubtract = new BigDecimal("2.2").subtract(bd); // => 1.1
    BigDecimal bdMultiply = new BigDecimal("2.2").multiply(bd); // => 2.42
    // 割り算は小数第5位で四捨五入
    BigDecimal bdDivide = new BigDecimal("2.2").divide(bd, 4, RoundingMode.HALF_UP); // => 2.0000
    // RoundingMode.CEILING     : 양의 무한대에 가깝게 반올림
    // RoundingMode.DOWN        : 0에 가깝게 반올림
    // RoundingMode.FLOOR       : 음의 무한대에 가깝게 반올림
    // RoundingMode.HALF_UP     : 반올림을 하지 않음.
    // RoundingMode.UNNECESSARY : 반올림을 하지 않음. 필요가 있으면 ArithmeticException을 throw
    // RoundingMode.UP          : 0에 멀어지게 반올림
    }</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// IntやLongを符号なし整数として扱う
// ---------------------------------
{
	// intの最大値(2147483647)に対して加算する
	int a = Integer.MAX_VALUE + 1;

	// そのまま表示すると桁あふれを起こし負の数として表示される
	System.out.println(a); // => -2147483648

	// Integer#toUnsignedString()で符号なし整数として表示すると正しい結果が表示される
	System.out.println(Integer.toUnsignedString(a)); // => 2147483648

	// longの最大値(9223372036854775807)に対して加算する
	long b = Long.MAX_VALUE + 1;
	// そのまま表示すると桁あふれを起こし負の数として表示される
	System.out.println(b); // => -9223372036854775808
	
	// Long#toUnsignedString()で符号なし整数として表示すると正しい結果が表示される
	System.out.println(Long.toUnsignedString(b)); // => 9223372036854775808

	// 符号なしIntegerの除算
	int c = Integer.divideUnsigned(a, 2);
	System.out.println(c); // 1073741824
	
	// 符号なしIntegerの剰余
	int d = Integer.remainderUnsigned(a, Integer.MAX_VALUE);
	System.out.println(d); // 1
}
// ---------------------------------
// 文字列を符号なし整数に変換
// ---------------------------------
{
	// 文字列を符号なし整数としてintに変換
	// Integer.parseInt("2147483648");はNumberFormatException
	int a = Integer.parseUnsignedInt("2147483648");
	System.out.println(a); // -2147483648

	// 文字列を符号なし整数としてlongに変換
	long b = Long.parseUnsignedLong("9999999999999999999");
	System.out.println(b); // -8446744073709551617

	// 負の数を示す文字列を与えると例外が発生する
	try {
		int c = Integer.parseUnsignedInt("-100"); // => NumberFormatException
		System.out.println(c);
	} catch (NumberFormatException e) {
		e.printStackTrace();
	}
}</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 클래스에 final => 상속 안됨
// 메소드에 final => 오버라이드 안됨.
// 변수에   final => 값 변경 안됨.
// 인터페이스는 복수개의 interface파일을 extends 가능.
// 인터페이스의 구현도 복수개의 interface파일을 implements 가능.
// ---------------------------------
// 인터페이스는 기본 추상메소드만 존재
// java8이후부터는 default키워드로 디폴트의 정의가 가능.
// 구현클래스에서 메소드를 구현할 필요없음.
// 구현클래스에서 디폴트 메소드를 오버라이드 가능.()
public interface HelloWorld {
	// メソッドにデフォルト実装を定義する
	default public String hello(String name) {
		return "Hello " + name;
	}
}
public class HelloWorldImpl implements HelloWorld {
	// デフォルト実装をオーバーライド
	@Override
	public String hello(String name) {
		// superを使ってデフォルト実装を呼び出す
		return String.format("*** %s ***", HelloWorld.super.hello(name));
	}
}
// ---------------------------------
// 実行したいデフォルト実装を指定する
// ---------------------------------
static interface A {
	default void method() {
		System.out.println("Aのデフォルト実装メソッド");
	}
}
static interface B {
	default void method() {
		System.out.println("Bのデフォルト実装メソッド");
	}
}
static class C implements A, B {
	@Override	
	public void method() {
		// Aのデフォルト実装を呼び出す
		A.super.method();
	}
}
// ---------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// - 66장
// ■ 중첩클래스 
// static인가 아닌가에 따라 특징이 다르다.
// - inner class : static가 안붙음. 외부클래스의 필드나 메소드에 직접 접근가능.
// - static nest class : static붙음. 외부클래스의 필드나 메소드에 직접 접근안됨.
//                       통상의 클래스와 같다.
// ■ 클래스내부에 인터페이스나 열거형의 정의가능.
// - 암묵적으로 static이 된다.생략해도.
// ---------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// ■ 익명클래스
// - 처리가 간단하고, 후에 재이용 가능성이 없는경우에 한해서 사용.
// - 제한
//   생성자 정의 안됨.
//   슈퍼클래스가 될수 없음.
//   익명클래스에서 외부의 메소드의 로컬변수는 final일 경우에만 참조가능.(java8이후 삭제됨)
// ---------------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// ■ 상속
// - 다중상속 안됨.
// - final클래스는 상속 안됨.
// ■ 추상클래스 (chap69)
// - 통상의 메스드와 추상메소드 정의 가능.
// - 직접인스턴스화는 불가능.
// - 사용하기 위해서는 상속하는 서브클래스를 작성.
// ■ 오버라이드, 오버로드
// - 부모클래스의 메소드를 자식클래스에서 덮어씀 => 오버라이드
//   서브클래스내에서 같은 이름, 인수로 정의.
//   final메소드는 오버라이드 안됨.
// - 같은 클래스내에서 같은 이름, 다른 인수(시그니처)의 메소드 정의 => 오버로드
//   억세스제한자, 반환형, throws는 자유롭게 지정가능.
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// ■ initializer
// - static initializer
//   클래스가 로드될때 (인스턴스가 최초로 생성될 때. static메소드, static필드에 최초로 접근할때.) 
//	   => 한번만 실행시키고 싶은 처리를 기술
//   예외를 던질수 없다.
// - instance initializer
//   그 클래스가 인스턴스화 될 때. 생성자보다 먼저 실행된다.
//   대개 생성자에서 처리.
//   익명 클래스는 생성자의 정의가 안되기 때문에, 초기화 처리가 필요한 경우에 사용.
// - 
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 75장
// ■ 열거형
//
// - 기본
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe075">link</a>
// 
// - 정수별로 메소드 오버라이드
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe076">link</a>
// 
// - 열거형에 효율이 좋은 컬렉션
<a href="https://www.github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe077">link</a>
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 78장
// ■ 제너릭스
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe078">link</a>
// - 상속제한
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe080">link</a>
// - 와일드카드 &lt;?&gt;
// &lt;? extends MyClass&gt;
// => MyClass 또는 그 서브클래스를 대입가능.
// &lt;? super MyClass&gt;
// => MyClass 또는 그 부모클래스를 대입가능.
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe081">link</a>
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 82장 
// ■ 가변인수
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe082">link</a>
// ---------------------------------
// 83장 
// - annotation
//   @SuppressWarnings => 컴파일러가 발생시키는 경고를 억제
//     : 복수지정가능, eclipse에서 [ctrl + 1] 로 선택.
//       @SuppressWarnings({"unchecked","varargs"})
//   @SageVarargs => 제네릭스를 지정한 가변인수의 경고를 억제
//   @FunctionalInterface => 함수형인터페이스임을 나타냄
// ---------------------------------
// - 독자annotation
//   : @interface키워드로 정의
//   : 종류
//     1. marker 어노테이션 => 속성이 없는 어노테이션, 표시용.
//        사용예 : @Check
//        public @interface Check {}
//     2. full 어노테이션   => 속성이 있는 어노테이션.
//        사용예 : @Check(id= 1, value = "message")
//        public @interface Check { String value(); int id(); }
//     3. single 어노테이션 => value라는 이름의 속성이 1개만 정의된 어노테이션.
//        사용예 : @Check("message")  
//                 단일어노테이션은 이용시 속성명 생략가능. 
//                 속성명이 value인 경우에는 생략불가능.
//        public @interface Check { String value();}
//    : 어노테이션의 속성에 디폴트값을 설정.
//      "@Check"같이 값을 생략하면 기본값이 사용됨. 
//      그외에는 "@Check(false)"와 같이 사용.
//      public @interface Check { 
//			boolean value() default true;
//		}
//    : 메타어노테이션
//      메타정로보써 어노테이션을 부여가 가능하고,
//      어노테이션 부여가능한 곳과 실행시에 리플렉션으로 읽기가능한지 아닌지를 지정가능.
//      메타어노테이션은 [java.lang.annotation.*]에 정의되어 있다.
// 		@Documented
// 		@Inherited
// 		@Target({TYPE, METHOD})	// クラスやインターフェースや列挙型、メソッドに付与できる
// 		@Retention(RUNTIME)		// コンパイル時に保存し、実行時にJava VM上にも保持
// 			public @interface Check {
// 		}
// ---------------------------------
// - 메타어노테이션
<a href="www.is.gd/1mAWCJ">link</a>
// meta-annotation 은 다른 annation 에서도 사용되는 annotation 의 경우를 말하며 
// custom-annotation 을 생성할 때 주로 사용됩니다.
// ----------
// @Target
// @Target 은 Java compiler 가 annotation 이 어디에 적용될지 결정하기 위해 사용합니다.
// 예를 들어 위에서 사용한 @Service 의 ElementType.TYPE 은 해당 Annotation 은 
// 타입 선언 시 사용한다는 의미입니다.
// - 종류
// ElementType.PACKAGE         : 패키지 선언(package-info.java파일에만 부여가능)
// ElementType.TYPE            : 타입 선언
// ElementType.ANNOTATION_TYPE : 어노테이션 타입 선언
// ElementType.CONSTRUCTOR     : 생성자 선언
// ElementType.FIELD           : 멤버 변수 선언
// ElementType.LOCAL_VARIABLE  : 지역 변수 선언
// ElementType.METHOD          : 메서드 선언
// ElementType.PARAMETER       : 전달인자 선언
// ElementType.TYPE_PARAMETER  : 전달인자 타입 선언
// ElementType.TYPE_USE        : 타입 선언(형을 사용하는 곳은 어디든지 지정가능)
// ----------
// @Retention
// @Retetion 은 Annotation 이 실제로 적용되고 유지되는 범위를 의미합니다.
// Policy 에 관련된 Annotation 으로 컴파일 이후에도 JVM 에서 참조가 가능한 RUNTIME 으로 지정합니다.
// - 종류
// RetentionPolicy.RUNTIME
// => 컴파일 이후에도 JVM 에 의해서 계속 참조가 가능합니다. 주로 리플렉션이나 로깅에 많이 사용됩니다.
// RetentionPolicy.CLASS
// => 컴파일러가 클래스를 참조할 때가지 유효합니다.
// RetentionPolicy.SOURCE
// => 컴파일 전까지만 유효합니다. 즉, 컴파일 이후에는 사라지게
// ----------
// @Inherited
// 해당 어노테이션이 상속됨을 나타냄
// @Documented
// 문서에 어노테이션 정보가 표기됩니다.
// // ----------
// @Repeatable
// java8부터 지원하며, 동일한 선언에 annotation을 두번 이상 적용할 수 있도록 합니다.
// ---------------------------------
// - 어노테이션이란
// Anntation은 JDK 1.5부터 도입된 것으로 자바 소스 코드에 추가하여 사용할 수 
// 있는 메타데이터의 일종입니다.
// 대부분이 많이 봤을 만한 @Override, @Deprecated 가 Annotation 예로 
// Annotation의 구현된 정보에 따라 연결되는 방향이 결정됩니다.
// 즉, 전체적인 소스코드의 로직을 바꾸진 않지만 Annotation의 타겟을 
// 연결 방법이나 소스코드의 구조를 변경할 수 있습니다. Annotation의 기능을 잘 
// 활용한다면 비즈니스 로직과 별도의 시스템 설정은 Annotation에게 위임함으로써 
// 개발자들은 로직 구현에만 집중할 수 있습니다. 따라서 Annotation을 통해 
// AOP(Aspect Object Programming)을 구성할 수 있습니다.
//
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe084">link</a>
//
<a href="https://github.com/macmoo/ref/blob/master/f/9src/005javarecipe/chap03/recipe084/target/AnnotationSample.java">link</a>
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 85장
// ■ Class인스턴스를 취득
// - 취득 : 클래스명.class
Class<Exception> e = Exception.class </Exception>
// ----------
// - 인스턴스에서 클래스인스턴스를 취득 : getClass()
Exception instance = new Exception();
Class<? extends Exception> e = instance.getClass();
// - 클래스명의 문자열로부터 취득
Class<?> e = Ckass.forName("java.lang.Exception");
// ----------
// - 취득한 Class인스턴스로 정보취득
<a href="https://github.com/macmoo/ref/blob/master/f/9src/005javarecipe/chap03/recipe086/ClassSample.java">link</a>
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// ■ 리플렉션
//   Class오브젝트로부터 필드나 메소드 등의 정보를 취득하고, 
//   더 나아가 그 필드나 메소드를 동적으로 호출하는 것이 가능하게 하는것.
// 예)
// Class 오브젝트취득
Class<?> clazz = obj.getClass();
// 메소드명과 인수의 형을 지정해서 Method오브젝트를 취득
Method method = clazz.getMethod("setName", String.class);
// setName메소드를 호출
method.invoke(obj, "Naoki");
// ----------
// - 리플렉션으로 클래스의 멤버정보를 취득
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe086/MemberSample.java">link</a>
// ----------
// - 리플렉션으로 인수명을 취득
<a href="https://github.com/macmoo/ref/blob/master/f/9src/005javarecipe/chap03/recipe086/ParameterNamesSample.java">link</a>
// ----------
// - 리플렉션으로 인스턴스를 생성
//   Constructor#newInstance()
<a href="https://github.com/macmoo/ref/blob/master/f/9src/005javarecipe/chap03/recipe087/NewInstanceSample.java">link</a>
// ----------
// - 리플렉션으로 메소드나 필드를 호출
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe088">link</a>
// ----------
// - 리플렉션으로 제네릭 정보 취득
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe089">link</a>
// ----------
// - 리플렉션으로 어노테이션 정보 취득
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe090">link</a>
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 91장
// ■ 인스턴스를 시리얼라이즈, 디시리얼라이즈
// - 시리얼라이즈
//   : 오브젝트를 데이터로써 보전가능한 형태로 변환하는것. 
//     java.io.ObjectOutputStream 을 사용
// - 디시리얼라이즈
//   : 변환된 데이터에서 오브젝트를 복원하는것.
//     java.io.ObjectInputStream 을 사용
// - java.io.Serializable인터페이스를 구현할 필요가 있다.
//   Serializable인터페이스는 시리얼라이즈가 가능함을 나타내는 marker인터페이스이지,
//   구현할 메소드가 아니다.
// - serialVersionUID
//   : 디시리얼라이즈를 할때, 클래스의 구조에 변경이 없음을 식별하기 위한 번호.
//     시리얼라이즈->디시리얼라이즈시에 이 번호가 서로 다르면 디시리얼라이즈가 안됨.
//     생략하면 간단한 수정에도 컴파일러가 번호를 다시 생성하기 때문에 디시리얼라이즈 안될수도 있다.
// - 시리얼라이즈할 클래스의 모든 필드가 반드시 시리얼라이즈 대상이 아니다.
//   : 이하의 필드는 대상에서 재외됨.
//     transient키워드의 필드
//     static필드
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe091">link</a>
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 92장
// ■ 독자 시리얼/디시리얼라이즈
// - writeExternal()
//   readExternal()
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap03/recipe092">link</a>
// ----------
// - XML형식으로 시리얼라이즈
<a href="https://github.com/macmoo/ref/blob/master/f/9src/005javarecipe/chap03/recipe092/XMLSerializeSample.java">link</a>
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 93장
// ■ 컬렉션
// - java의 기본라이브러리에는 컬렉션을 취급하기 위한 컬렉션프레임워크가 포함되어있다.
//   컬렉션FW에는 다음의 3가지 IF가 포함되어 있다.
//   1. java.util.List => 구현 java.util.ArrayList
//   2. java.util.Set  => 구현 java.util.HashSet
//      요소의 중복허용안함. 순서성도 없다.
//   3. java.util.Map  => 구현 java.util.HashMap
// - 스레드 세이프한 컬렉션클래스
//   복수의 스레드에서 컬렉션클래스를 조작할 경우 사용.1
//   1. java.util.concurrent.CopyOnWriteArrayList
//   2. java.util.concurrent.CopyOnWriteArraySet
//   3. java.util.concurrent.ConcurrentHashMap
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// ■ 배열
//   : 한번 작성한 배열의 사이즈는 변경불가.
//     기본형의 배열을 선언하는 것이 가능.
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap04/recipe094">link1</a>
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap04/recipe095">link2</a>
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap04/recipe096">link3</a>
// ----------
// - 배열복사
//   : Arrays#copyOf()
//     Arrays#copyRangeOf()
//     => 둘다 내부적으로는 System#arraycopy()를 사용.
//   : Arrays#copyOf(), System#arraycopy()는 얕은 복사
//   : 얕은 복사 => 복사대상이 갖고있는 참조를 복사해서 새로운 오브젝트를 생성.
//     깊은 복사 => 복사대상이 갖고있는 참조형변수의 내용을 포함해서 모두 복사하는 것을 가리킴.
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap04/recipe097">link</a>
// ----------
// - 배열소트
//   : Arrays#sort()
//     인수로 java.util.Comparator오브젝트를 넘기는 것으로 소트방법을 커스터마이즈 가능.
//   : Comparator IF에는 compare()가 정의되어 있어 다음과 같이 2개의 값을 비교함.
//     인수1 > 인수2 => 양수를 반환
//     인수1 = 인수2 => 0을 반환
//     인수1 < 인수2 => 음수를 반환
//   : Arrays#parallelSort()
//     => 배열을 병렬로 소트. Fork/Join Framework를 사용해 구현되어 고속으로 소트가 가능.
<a href="https://github.com/macmoo/ref/tree/master/f/9src/005javarecipe/chap04/recipe098">link</a>

// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 장
// ■ 
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 장
// ■ 
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 장
// ■ 
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 장
// ■ 
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 장
// ■ 
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// ---------------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="java">// ---------------------------------
// 장
// ■ 
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// -
<a href="">link</a>
// ----------
// ---------------------------------</code></pre>
<!-- ############################################# -->
</body>
<a href="">link</a>
<a href="">link</a>
<a href="">link</a>
<a href="">link</a>
<a href="">link</a>
<a href="">link</a>

</html>