<!DOCTYPE html>

<head>
    <title></title>
    <!-- START -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- <link rel="stylesheet" type="text/css" href="../../etc/androidstudio.css"> -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/monokai-sublime.min.css">
    <link rel="stylesheet" type="text/css" href="../../etc/custom.css">
    <script type="text/javascript" src="../../etc/highlight.min.js"></script>
    <script type="text/javascript" src="../../etc/highlightjs-line-numbers.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>hljs.initLineNumbersOnLoad();</script>
    <!-- E N D -->
</head>

<body>
<!-- ############################################# -->
<pre><code class="javascript">// const로 정수를
// let로   변수를 취급
let   myName1 = "이름1";
const myName2 = "이름2";

// myName2 = "이름3"; // 에러

alert(myName1);
alert(myName2);
// ----------------------------
let currentDate = new Date();
let myFunc = () => console.log('함수다');

alert(currentDate);
myFunc();

let myVar;    // 초기값 미설정
alert(myVar); // undefined
// ----------------------------
// const
// 초기값의 생략이 불가능
// 값의 재설정이 불가능으로, 값의 변경이 불가능한 것은 아님
// 배열이나 오브젝트의 변경을 막으려면 Object#freeze()를 이용
const myArr = ['문','홍','안'];
console.log(myArr); // Array(3) [ "문", "홍", "안" ]

myArr[0] = '이';
console.log(myArr); // Array(3) [ "이", "홍", "안" ]

const myObj = {id:20, name:'한국'};
console.log(myObj); // Object { id: 20, name: "한국" }

myObj.name = '캐나다';
console.log(myObj); // Object { id: 20, name: "캐나다" }
// ----------------------------
// == 와 === 의 차이
// ==  : 형이 달라도 같은 것으로 판단
// === : 형이 다르면 다른 것으로 판단
// != , !== 도 같다
console.log(10 ==  '10'); // true
console.log(10 === '10'); // false</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 애로우함수 (=>)
// (인수) => { 처리내용 }
// 장점
// 1. 함수를 간결하게 작성가능
// 2. this를 속박가능
// ----------------------------
// 함수의 정의
const calcSum = (a,b,c) => {
    const result = a + b + c;
    return result;
};
console.log(calcSum(10,20,30)); // 60
// ----------------------------
// 인수가 1개일 경우, ()생략가능
// 인수가 0개이거나 2개 이상일 경우, ()생략불가
// ----------------------------
const myFunc1 = (a) => {
    return a + 2;
};
const myFunc2 = a => {
    return a + 3;    
};
console.log(myFunc1(10)); // 12
console.log(myFunc2(10)); // 13
// 애로우함수내의 처리가 1행일 경우,
// {}와 return을 생략가능
const myFunc3 = (a) => a + 4;
console.log(myFunc3(10)); // 14</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 함수의 인수에 초기값 설정
// 1. function myFunc(인수1, 인수2=초기값2, 인수3=초기값3){}
// 2. (인수1, 인수2=초기값2, 인수3=초기값3) => {}
// 초기값이 설정된 인수를 생략가능
// ----------------------------
function myFunc1(price, tax = 0.08){
    const result = price + price * tax;
    return result;
}
console.log(myFunc1(100));       // 108
console.log(myFunc1(100, 0.02)); // 102
// ----------------------------
// 함수에 임의의 개수의 인수를 건넴
// "...인수" 残余引数（rest parameters）
// 건네진 인수는 배열로 저장됨
// 1. function 함수명(...인수){}
// 2. (...인수) => {}
// 3. 인수[인덱스]
// ----------------------------
function calcSum(...prices){
    console.log(prices[0]); // 10, 5
    let result = 0;
    for(const value of prices)
        result += value;
    return result;
}
console.log(calcSum(10,20));    // 30
console.log(calcSum(5,10,20));  // 35</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// iphone인지 확인
const isIOS = navigator.userAgent.includes('iPhone');
console.log(isIOS); // false or true
// ----------------------------
// 문자열에 'vas'가 포함되는지 아닌지 확인
const flg = 'Javascript'.includes('vas');
console.log(flg);   // true</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 수치
// NaN : 수치이 아님.  부정한 계산결과
// ----------------------------
// 1.7976931348623157e+308
console.log(Number.MAX_VALUE);
// 5e-324
console.log(Number.MIN_VALUE);
// 9007199254740991
console.log(Number.MAX_SAFE_INTEGER);
// -9007199254740991
console.log(Number.MIN_SAFE_INTEGER);
// Infinity  (양의 무한의 값)
console.log(Number.POSITIVE_INFINITY);
// -Infinity (음의 무한의 값)
console.log(Number.NEGATIVE_INFINITY);</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 장방향 그라데이션
const rectangle = document.querySelector('.rectangle');

// 버튼이벤트
document.querySelector('.button').addEventListener('click', onClickButton);

function onClickButton(){
    // 0~359랜덤숫자 생성
    const randomHue        = Math.trunc(Math.random() * 360);

    // 그라데이션 시작, 종료 색 설정
    const randomColorStart = `hsl(${randomHue     }, 100%, 50%)`;
    const randomColorEnd   = `hsl(${randomHue + 40}, 100%, 50%)`;

    // 장방형의 그라데이션용 변수(--start, --end)을 변경
    rectangle.style.setProperty('--start', randomColorStart);
    rectangle.style.setProperty('--end'  , randomColorEnd);
}
// ----------------------------
// css
.rectangle {
    width :300px;
    height:300px;
    /* height:calc(100% - 50px); */
    --start: hsl(0  , 100%, 50%);
    --end  : hsl(322, 100%, 50%);
    background-image: linear-gradient(-135deg, var(--start), VAR(--end));
}</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 안전한 난수
// crypto.getRandomValues(형붙인 배열); // 리턴:난수배열
// ----------------------------
//랜덤정수(부호없는16비트)가 10개들어간 배열을 생성
const randomArr = crypto.getRandomValues(new Uint16Array(10));
console.log(randomArr);
// Uint16Array(10) [ 30106, 64439, 30547, 1975, 9450, 62468, 27533, 27756, 63786, 36283 ]
// 배열을 이어 난수를 생성
const random16 = randomArr.join('');
console.log(random16);
// 301066443930547197594506246827533277566378636283
// ----------------------------
// 부호없는 32비트 난수생성
const random32 = crypto.getRandomValues(new Uint32Array(10)).join('');
console.log(random32);
// 382979343515709866573468246670218395933328989172757469039542220903590269873746935950855881383786406
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 수학 계산
// ----------------------------
Math.abs(수치);  // 절대값
Math.pow(수치A, 수치B);  // 수치A의 수치B승
Math.sign(수치); // 수치부호를 계산
Math.sqrt(수치); // 평방근(루트2)
Math.log(수치);  // 자연대수를 계산
Math.exp(수치);  // 지수함수를 계산
Math.E           // 자연대수의 밑
Math.PI          // 원주율
Math.cos(수치);  // 코사인
Math.sin(수치);  // 사이
Math.tan(수치);  // 탄젠트
Math.acos(수치); // 아크코사인
Math.asin(수치); // 아크사인
Math.atan(수치); // 아크탄젠트
Math.atan2(y좌표, x좌표); // (x,y)의 좌표의 각도</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 문자열
// ----------------------------
// 길이
console.log("string".length); // 6
console.log(Array.from('string2').length); // 7
// ----------------------------
// 문자열양끝 공백, 탭, 개행 제거
console.log(" str ing ".trim()); // "str ing"
// ----------------------------
// 문자열 검색(검색결과없으면 -1을 반환)
// 대소문자 구분함, 인덱스를 반환
// - 대상문자열.indexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.lastIndexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.search(정규표현)
const str = 'Javascript를 배우자.';
const s1 = str.search(/Javascript/);
const s2 = str.search(/HTML/);
console.log(s1); // 0 : hit
console.log(s2); // -1 : no hit
// ----------------------------
// 문자열이 포함되어 있는가. (참/거짓을 리턴)
// - 대상문자열.includes(검색할 문자열, [검색개시 인덱스])
// 문자열로 시작하는가, 끝나는가
// - 대상문자열.startsWith(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.endsWith(검색할 문자열, [검색개시 인덱스])
const a1 = str.includes("script");
const a2 = str.startsWith("javascript");
const a3 = str.endsWith("배우자.");
console.log(a1); // true
console.log(a2); // false
console.log(a3); // true
// ----------------------------
// 문자추출
// 문자열.charAt(인덱스)
console.log("string".charAt(3)); // i
console.log("string".charAt());  // s
// 문자열.slice(시작인덱스, [종료인덱스])
// 문자열.substring(시작인덱스, [종료인덱스])
// 종료인덱스를 생략하면 문자열끝까지
// slice()음수지정가능(뒤에서부터 추출)
// slice()와 substring()은 시작idx가 종료idx보다 
// 클경우의 처리가 다름. (시작idx, 종료idx를 바꿔서 처리)
const str2 = "kwak no1";
console.log(str2.slice(2,4));       // ak
console.log(str2.substring(2,4));   // ak
console.log(str2.slice(0));         // kwak no1
console.log(str2.substring(0));     // kwak no1
console.log(str2.slice(1, -1));     // wak no
console.log(str2.substring(1, -1)); // k
console.log(str2.slice(3, 1));      // <empty string>
console.log(str2.substring(3, 1));  // wa
// ----------------------------
// 문자열.substr(시작인덱스, [취득문자수])
// @deprecated
console.log(str2.substr(1, 3));  // wak
// ----------------------------
// 문자열치환
// 문자열1/정규펴현을 문자열2로 바꿈
// 대상문자열.replace(문자열1, 문자열2)
// 대상문자열.replace(정규표현, 문자열2)
const phone = '111-2222-3333';
console.log(phone.replace(/-/g, '')); // 11122223333
// ----------------------------
// * 버튼의 디폴트 이벤트 무효화
// document.querySelector('#submitBtn')
//        .addEventListener('click'
//        , (event)=>{ event.defaultPrevented(); });
// ----------------------------
// 문자열분할
// 문자열.split([구분문자], [분할수])
// 문자열.split([정규표현], [분할수])
// 빈문자로 분할하면 한글자씩 들어간 배열이 리턴
// 인수를 생략하면 하나의 전체문자열이 들어간 배열 리턴
// ----------------------------
// 문자열결합
// 문자열1+문자열2+문자열3
// `${문자열1}${문자열2}${문자열3}`
// ----------------------------
// 문자열변환
// 대 - 소문자
// 문자열.toLowerCase()
// 문자열.toUpperCase()
// ----------------------------
// 정규표현
// "/패턴/"형식으로 사용
// -----------
// 패턴     의미
// x        x라는 1문자    
// xyx      xyz라는 문자열
// [xyz]    xyz중 1문자
// [a-z]    a~z중 1문자
// [^xyz]   xyz이외의 1문자
// [^a-z]   a~z이외의 1문자
// abc|xyz  abc 또는 xyz라는 문자열
// {숫자}   반복횟수
// ^x       첫문자가 x
// x$       마지막 문자가 x
// .        개행문자를 제외한 1문자
// x*       x가 0개 이상 반복
// \        다음문자를 이스케이프함
// \d       숫자     => [0~9]
// \D       숫자이외 => [^0~9]
// \w       영문자, 언더스코어 => [A-Za-z0-9_]
// \s       스페이스, 탭, 개행문자등의 공백문자
// \S       공백이외의 문자 => [^\s]
// \t       수평탭
// \n       개행문자
// -----------
// 조건에 매치하는 문자열 검색
// /패턴/.test(문자열)
console.log(/J/.test('Javasscript'));     // true
console.log(/^iP/.test('iPhone'));        // true
console.log(/iP$/.test('iPhone'));        // false
// 숫자포함
console.log(/\d/.test('iPh4one'));        // true
// a가 0회 이상 반복
console.log(/java.*/.test('javascript'));  // true
console.log(/java.*/.test('javasscript')); // true
console.log(/\d+-\d+-\d+/.test('090-1234-5678'));    // true
// 0에서 시작해서 10혹은 11자의 숫자인가 확인
console.log(/^[0][0-9]{9,10}$/.test('01234567890')); // true
// ----------------------------
// 소수점 표현
// 수치.toFixed([문자수]); // 소수점이하를 지정한 문자수로 한다.
// 수치.toPrecision([문자수]); // 지정문자수를 精度로 한다.
console.log((0.3333).toFixed(2)); // 0.33
console.log((0.3353).toFixed(2)); // 0.34
console.log((123.456).toFixed(3)); // 123.456
// ------------
console.log((0.3333).toPrecision(2)); // 0.33
console.log((0.3353).toPrecision(2)); // 0.34
console.log((123.456).toPrecision(3)); // 123
// 精度4에 의해 0이 매꿔짐
console.log((10).toPrecision(4)); // 10.00
// ----------------------------
const sndElem  = document.querySelector('.second');
// 3초후가 골
const goalTime = new Date().getTime() + 3 * 1000;
update();
function update(){
    // 현재시작
    const currentTime = new Date().getTime();
    // 남은시간
    const leftTime = goalTime - currentTime;
    if(leftTime < 0) return;
    // 초를 표시.소수점(미리초는 2자만)
    sndElem.innerText = (leftTime/1000).toFixed(2);
    // ★ 다음 프레임에서 다시 update를 실행
    requestAnimationFrame(update);
}
// ----------------------------
// 문자열 반복
// 문자열.padStart(반복할 길이, [추가할 문자열])
// 문자열.padEnd(반복할 길이, [추가할 문자열])
console.log('5'.padStart(2, '0'));  //  05
console.log('ff'.padEnd(6, '0'));   //  ff0000
console.log('ff'.padEnd(6));        // "ff    "
console.log('123'.padStart(3,'0')); // 123
function zeroPadding(num){
    return String(num).padStart(2, '0');
}
// ----------------------------
// 문자열을 URI인코드
// encodeURIComponent()는 다음 문자도 이스케이프함
// / ? & = + : @ $ ; , #
var uri1 = encodeURI('http://www.한글.com/주소.html');
console.log(uri1);
// http://www.%ED%95%9C%EA%B8%80.com/%EC%A3%BC%EC%86%8C.html
var uri2 = encodeURIComponent('http://www.한글.com/주소.html');
console.log(uri2);
// http%3A%2F%2Fwww.%ED%95%9C%EA%B8%80.com%2F%EC%A3%BC%EC%86%8C.html
// 디코드
console.log(decodeURI(uri1));
// http://www.한글.com/주소.html
console.log(decodeURIComponent(uri2));
// http://www.한글.com/주소.html
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 배열
// ----------------------------
// [] : 배열을 정의
const arr1 = [];               // 빈배열
const arr2 = [1,2,3];          // 배열 초기화
const arr3 = new Array(4,5,6); // 배열초기화
// 인수가 1개의 수치일 경우에는 지정개수의 배열이 작성됨
const arr4 = new Array(10);    // 10개의 수를 넣을수 있는 배열
// ----------------------------
console.log(arr3.length); // 3
// ----------------------------
// 배열의 각요소에 대해 처리 (1)
// 베열.forEach(콜백함수)
// 인수로 건넨 콜백함수를 써서 요소를 순서대로 처리
// 콜백함수 (* : 생략가능)
// ([요소*], [인덱스*], [元배열*]) => {} 
const arr5 = ['딸기','귤','사과'];
arr5.forEach((value, index) => {
    console.log(index, value);
});
// 0 딸기
// 1 귤
// 2 사과
// -----------
[1,2,3,4,5,6,7]
    .filter( (value) => value % 2 === 0)
    .forEach((value) => {
        console.log(value); // 2 4 6
    });  
// ----------------------------
// 배열의 각요소에 대해 처리 (2)
// for(const 요소 of 배열) {}
for(const val of arr5){
    console.log(val); // 딸기 , 귤 , 사과
}
// ----------------------------
// 배열의 각요소에 대해 처리 (3)
for(let i = 0; i < arr5.length; i++){
    console.log(arr5[i]); // 딸기 , 귤 , 사과
}
// ----------------------------
// 배열에 요소 추가
// 배열.unshift(요소1, 요소2) : 선두에 요소추가
// 배열.push(요소1, 요소2)    : 말미에 요소추가
// ----------------------------
// 배열.shift() : 선두의 요소를 제거
// 배열.pop()   : 마지막 요소를 제거
const arr7 = ['딸기','귤','사과'];
const itemShift = arr7.shift();
console.log(itemShift);      // 딸기
console.log(arr7);           // 귤, 사과
// ------------
const itemPop = arr7.pop();
console.log(itemPop);        // 사과
console.log(arr7);           // 귤
// ----------------------------
// 배열의 요소 일부는 치환
// 배열.splice(추가위치, 추출할 개수, 요소1, 요소2)
const arr8 = ['사과','귤'];
const arr9 = ['사과','귤'];
// ------------
arr8.splice(1, 0, '바나나');        // 1의 위치에 0개를 지우고 바나나를 추가
arr9.splice(1, 1, '바나나','딸기'); // 1의 위치에 1개를 지우고 추가
// ------------
console.log(arr8); // [ "사과", "바나나", "귤" ]
console.log(arr9); // [ "사과", "바나나", "딸기" ]
// ----------------------------
// 배열연결
// 배열1.concat(배열2, 배열3)
// [...배열1, ...배열2, ...배열3]
const a1 = [1,2,3];
const a2 = ['a','b','c'];
const a3 = ['ㄱ','ㄴ'];
const a4 = a1.concat(a2,a3);
const a5 = [...a1, ...a2];
console.log(a4); // [ 1, 2, 3, "a", "b", "c", "ㄱ", "ㄴ" ]
console.log(a5); // [ 1, 2, 3, "a", "b", "c" ]
// ----------------------------
// 배열요소를 문자열로 결합
const a6 = a2.join();
const a7 = a2.join('');
console.log(a6); // a,b,c
console.log(a7); // abc
// ----------------------------
// 요소 검색
// 배열.indexOf(검색하고 싶은 요소, [검색시작위치])
// 배열.lastIndexOf(검색하고 싶은 요소, [검색시작위치])
// 배열.includes(검색하고 싶은 요소, [검색시작위치])
const b1 = [0,2,4,6,4,2,0];
console.log(b1.indexOf(4));     // 2
console.log(b1.lastIndexOf(4)); // 4
console.log(b1.includes(3));    // false
// ----------------------------
// 배열에서 조건 검색
// 배열.find(콜백함수)
// : 콜백함수에 처음 일치하는 요소
// 배열.findIndex(테스트함수)
// : 콜백함수에 처음 일치하는 요소의 인덱스
// 콜백함수
// :  ([요소],[인덱스],[元배열]) => 진리값
const c1 = ['스즈키','다나카','다카하시','고토'];
const targetUser1 = c1.find((elem) => elem == '다나카');
// 위와 동일
const targetUser2 = c1.find((elem) => { return elem == '다나카'; });
const targetUser3 = c1.findIndex((elem) => { return elem == '다나카'; });
console.log(targetUser1); // 다나카
console.log(targetUser2); // 다나카
console.log(targetUser3); // 1
// ----------------------------
// 배열의 역순
// 배열.reverse()
const c2 = [1,3,5];
console.log(c2); // [ 1, 3, 5 ]
c2.reverse();
console.log(c2); // [ 5, 3, 1 ]
// ----------------------------
// 배열을 정렬
// 배열.sort([비교함수])
// : 비교함수의 리턴값의 대소에 따라 정렬
//   0미만   : a, b의 순으로 정렬 
//   0       : a, b순서을 안바꿈
//   0보다큼 : b, a의 순으로 바꿈
// : 비교함수를 생략하면 문자열로 유니코드순으로 정렬
const c3 = [1,2,3,3,4,5];
c3.sort((a,b) => {
    // a가 b보다 작으면, a,b순으로 정렬
    if(a <  b) return  1; 
    if(a == b) return  0;
    if(a >  b) return -1;
});
console.log(c3); // [ 5, 4, 3, 3, 2, 1 ]
// ----------------------------
// 문자열 대소무시하고 비교 정렬
const c4 = ['grape','Orange','apple'];
c4.sort();
console.log(c4); // [ "Orange", "apple", "grape" ]
// ------------
const c5 = ['grape','Orange','apple'];
c5.sort((a,b) => a.localeCompare(b));
console.log(c5); // [ "apple", "grape", "Orange" ]
// ----------------------------
// 배열에서 새 배열 만들기
// 배열.map(콜백함수)
// : 콜백함수에 따라 새로운 배열을 작성
// : ([요소],[인덱스],[元배열]) => 밴경후의 요소
//   요소를 받아, 변경후의 요소를 반환
// map()
// : 어떤 배열을 근거로 새로운 배열을 만듬
//   요소 하나씩하나씩 처리
//   forEach()와 비슷한데 
//   map()는 실행후의 결과를 배열로 반환하는 점이 다름
const idList1  = [4, 10, 20];
const newList1 = idList1.map((value) => `userid_${value}`);
console.log(newList1); // [ "userid_4", "userid_10", "userid_20" ]
// ------------
const idList2  = [3, 8, 12];
const newList2 = idList1.map((value, index) => `userid_${index + 1}_${value}`);
console.log(newList2); // [ "userid_1_4", "userid_2_10", "userid_3_20" ]
// ------------
const idList3 = [
    { id:  2, name:'스즈키'  },
    { id: 10, name:'다나카'  },
    { id:  4, name:'사토'    },
    { id: 29, name:'다카하시'},
    { id:101, name:'오기하라'}
];
const newList3 = idList3.map((value) => value.id);
// 위와 같음
const newList4 = idList3.map((value) => { return value.id });
console.log(newList3); // [ 2, 10, 4, 29, 101 ]
console.log(newList4); // [ 2, 10, 4, 29, 101 ]
// ----------------------------
// 한 배열에서 조건을 만족하는 배열을 작성
// 배열.filter(콜백함수)
// 콜백함수에 일치하는 배열을 생성
// ([요소],[인덱스],[元배열]) => 진리값
const d1 = [10,20,30,40];
const d2 = d1.filter((value) => value >= 30);
const d3 = d1.filter((value) => { return value >= 30 });
const d4 = d1.filter(function (value) { return value >= 30; })
console.log(d2); // [ 30, 40 ]
console.log(d3); // [ 30, 40 ]
console.log(d4); // [ 30, 40 ]
// map과 filter의 
// : 공통점은 기존배열은 건드리지 않으면서 요소들을 순회한 후 
//   새로운 배열을 리턴한다는 것이고, 
// : 차이점은 map은 콜백함수가 적용된 새 요소, 
//   filter는 조건문을 만족한 요소들을 반환한다는 점입니다.
// ----------------------------
// 각 요소들로 부터 단일 값을 만듬
// 배열.reduce(콜백함수, [초기값])
// : 각 요소의 왼쪽에서 오른쪽으로 처리해서 단일값을 만듬
// 배열.reduceRight(콜백함수, [초기값])
// : 각 요소의 오른쪽에서 왼쪽으로 처리해서 단일값을 만듬
// 콜백함수
// ((앞요소, 현재요소, 인덱스, 元배열)) => { /* 처리 */}
const e1   = [100, 500, 900];
const sum1 = e1.reduce((previous, current) => { return previous + current; });
// 위와 같음
const sum2 = e1.reduce((a, b) => a + b );
let   sum3 = 0;
for(const price of e1){
    sum3 += price;
}
console.log(sum1); // 1500
console.log(sum2); // 1500
console.log(sum3); // 1500
// 2차 배열을 1차 배열로 만듬
const e2 = [['바나나','사과','딸기'],['귤','포도']];
const e3 = e2.reduce((a,b) => { return a.concat(b); });
const e4 = e2.reduceRight((a,b) => { return a.concat(b); });
console.log(e3); // [ "바나나", "사과", "딸기", "귤", "포도" ]
console.log(e4); // [ "귤", "포도", "바나나", "사과", "딸기" ]
// ----------------------------
// 배열과 비슷한 오브젝트를 배열로 변환
// [...변환대상]
// "..." (スプレッド연산자)
// : ArrayLike오브젝트를 배열로 변환
// ArrayLike오브젝트
// : length프로퍼티로 길이를 취득가능
//   index가 부여된 요소를 가짐
//   예) NodeListOf오브젝트(배열은 아니기 때문에 filter()사용불가)
const f1 = '안녕하세요';
const f2 = [...f1];
console.log(f1); // 안녕하세요
console.log(f2); // "안", "녕", "하", "세", "요" ]
// ------------
// Array.from(변환대상, [콜백함수])
// 로도 변환가능
// ([요소],[인덱스],[元배열]) => {}
const f3 = Array.from(f1);
const f4 = Array.from(f1, (c) => `${c}!!`);
console.log(f3);
// "안", "녕", "하", "세", "요" ]
console.log(f4);
// [ "안!!", "녕!!", "하!!", "세!!", "요!!" ]
// ----------------------------
// 복수의 값을 한번에 대입 (분할대입)
// [변수1, 변수2, 변수3] = [값1, 값2, 값3]
let a, b, c;
[a, b, c] = [1, 2, 3];
console.log(a, b, c); // 1 2 3
// ------------
// 값 치환
const f5 = ['스즈키','다나카'];
console.log(f5); // [ "스즈키", "다나카" ]
[f5[0], f5[1]] = [f5[1], f5[0]];
console.log(f5); // [ "다나카", "스즈키" ]
// ----------------------------
// 배열 섞기
const g1 = [1,2,3,4,5];
const arrLen = g1.length;
// Fisher-Yates알고리즘
for(let i = arrLen - 1; i >= 0 ; i--){
    const randomIdx = Math.floor(Math.random() * (i+1));
    [g1[i], g1[randomIdx]] = [g1[randomIdx], g1[i]];
}
console.log(g1); // [ 5, 1, 3, 2, 4 ]
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 오브젝트
// : 복수의 프로퍼티를 갖음
// 프로퍼티
// : 키-값 조합
const object = {}; // 빈 오브젝트
// ----------------------------
const person = {
    id:1,
    name:'스즈키',
    age:28
}
console.log(person.id);      // 1
console.log(person[name]);   // undefined
console.log(person['name']); // 스즈키
// ----------------------------
person.id = 99;
console.log(person.id);      // 99
// ----------------------------
const resp = {
    result:true,
    list:[{id:1, name:'다나카', age:26}
        ,{id:2, name:'곽', age:39}]
};
console.log(resp.list[0].name); // 다나카
console.log(resp.list[1].id);   // 2
resp.list[1].id = 98;
console.log(resp.list[1].id);   // 98
// ----------------------------
// 함수도 가능
const myClass = {
    method1 : function(){
        console.log('1실행');
    },
    method2 : function(){
        console.log('2실행');
    }
};
myClass.method2(); // 2실행
// ----------------------------
// 오브젝트 복사
const object1 = {
    result:true,
    members:[
        {id:1, name:'다나카1', age:26},
        {id:2, name:'다나카2', age:27},
        {id:3, name:'다나카3', age:28}
    ]
};
// Object.assign() 사용
const copiedObj1 = Object.assign({}, object1);
// ----------------------------
// ...(스프레드연산자)사용
const copiedObj2 = {...object1};
// Object.assign()/...(스프레드연산자)는 얕은 복사
// 얕은복사:복사元、복사先가 같은 데이터를 참조
// 복사元의 오브젝트의 조작은 복사先에 영향을 끼침
console.log(copiedObj1.result);          // true
console.log(copiedObj2.members[0].name); // 다나카1
object1.result = false;
object1.members[0].name='스즈키';
console.log(copiedObj1.result);          // true
console.log(copiedObj2.members[0].name); // 스즈키
// ----------------------------
// 오브젝트에 프로퍼티의 존재 체크
// 오브젝트.hasOwnProperty('키')
var ret1 = object1.hasOwnProperty('result');
var ret2 = 'members' in object1;
var ret3 = object1.result != null;
var ret4 = object1.no != null;
console.log(ret1); // true
console.log(ret2); // true
console.log(ret3); // true
console.log(ret4); // false
// ----------------------------
// 값에 대해 처리
// Object.keys(오브젝트)
// Object.values(오브젝트)
// Object.entries(오브젝트) // 각 프로퍼티의 배열
const person2 = {
    id2:1,
    name2:'스즈키',
    age2:28
}
console.log(Object.keys(person2));    // [ "id2", "name2", "age2" ]
console.log(Object.values(person2));  // [ 1, "스즈키", 28 ]
console.log(Object.entries(person2));
// 0: Array [ "id", 1 ]
// 1: Array [ "name", "스즈키" ]
// 2: Array [ "age", 28 ]
// ----------------------------
// 복수의 변수에 값을 한번에 대입
// 변수명 일치 필요
const {id2, name2, age3} = person2;
console.log(name2); // 스즈키
console.log(age3);  // undefined
// 별명은 가능
const {name2:yourName} = person2;
console.log(yourName); // 스즈키
// ----------------------------
// 오브젝트를 편집불가로 변경
// Object.freeze(오브젝트)
// Object.isFrozen(오브젝트)
// 오브젝트는 const여도 프로퍼티의 추가/삭제/변경이 가능
const object2 = {id:10, name:'다나카'};
console.log(object2); // { id: 10, name: "다나카" }
object2.id = 12;
object2.address = '서울';
console.log(object2); // { id: 12, name: "다나카", address: "서울" }
// "'use strict';" => 선두에 선언 에러감지를 유효화
Object.freeze(object2);
object2.id = 99; // "'use strict';" 없으면 에러는 안남
object2.mail = 'a@gmail.com';
console.log(object2); // { id: 12, name: "다나카", address: "서울" }
// ----------------------------
const arr1 = [1,2,3];
Object.freeze(arr1);
console.log(arr1);
// arr1.push(99); // "'use strict';" 없어도 에러남
console.log(Object.isFrozen(arr1)); // true
// ----------------------------
// 다른 방법
// - Object.seal() : 프로퍼티의 추가/삭제만 금지, 변경은 가능.
// - Object.preventExtensions() : 프러퍼티의 추가만 금지, 삭제/변경가능.
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// * 데이터형
// 1) 기본형
//    - Boolean, String, Number
//      Undefined : 값이 미정을 나타내는 형 
//      Null      : 값이 존재하지 않음을 나타내는 형
//      Symbol    : 심볼형
//    - immutable
//    - call by value
// 2) 오브젝트형
//    - Object : 오브젝트형(기본형이외의 모든형(Array, Object, Date등))
//    - mutable
//    - call by ref
// ----------------------------
// * 데이터형 조사
// typeof 값
// ----------------------------
// * 인스턴스조사
// 값 instanceof 오브젝트
// ----------------------------
// * 형변환
// Boolean(값)
// String(값)
// Number(값)
// parseInt(문자열)
// parseFloat(문자열)
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
const date    = new Date();
const year    = date.getFullYear();
const month   = date.getMonth() + 1;
const day     = date.getDate();
const h       = date.getHours();
const m       = date.getMinutes();
const s       = date.getSeconds();
const dayList = ['일','월','화','수','목','금','통'];
const week    = dayList[date.getDay()];
// ----------------------------
document.querySelector(".log1").innerHTML = 
    `지금은 ${year}년 ${month}월 ${day}일 ${week}요일 `
    + `${h}시 ${m}분 ${s} 초이다.`;
// 지금은 2022년 2월 14일 월요일 21시 16분 57 초이다.
// ----------------------------
const locale    = date.toLocaleString();
const localDate = date.toLocaleDateString();
const localTime = date.toLocaleTimeString();
// ----------------------------
document.querySelector(".log2").innerHTML = 
    `${locale}<br/>`
    + `${localDate}<br/>`
    + `${localTime}`;
// 2022. 2. 14. 오후 9:16:57
// 2022. 2. 14.
// 오후 9:16:57
// ----------------------------
const num1 = Date.parse('2022/02/14');
console.log(num1);           // 1644764400000
console.log(date.getTime()); // 1644841858431
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
const date1 = new Date('2022/02/15 01:02:03');
const date2 = new Date('Tue Feb 15 2022 01:02:03');
const date3 = new Date(2022, 02, 15, 01, 02, 03);
console.log(date1); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
console.log(date2); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
console.log(date3); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
// ----------------------------
const date4 = new Date('2022/02/15 01:02:03');
date4.setMonth(date4.getMonth() -1); // 한달전
console.log(date4.toLocaleDateString()); // 2022. 1. 15.
date4.setDate(date4.getDate() + 5);  // 5일 뒤
console.log(date4.toLocaleDateString()); // 2022. 1. 20.
// ----------------------------
const dateA = new Date('2022/02/15');
const dateB = new Date('2022/03/15');
const diffM = dateB.getTime() - dateA.getTime();
const diffD = diffM / (24 * 60 * 60 * 1000);
console.log(`차이 : ${diffD}일`); // 차이 : 28일
// ----------------------------
const dateC = new Date('2022/02/15 01:02:03');
const dateD = new Date('2022/02/15 03:02:03');
const diffM2 = dateD.getTime() - dateC.getTime();
const diffD2 = diffM2 / (60 * 60 * 1000); // 60 * 1000 => 분
console.log(`차이 : ${diffD2}시간`); // 차이 : 2시간
// ----------------------------
// - setInterval() : 일정한 시간 간격으로 작업을 수행하기 위해서 사용합니다.
//   clearInterval 함수를 사용하여 중지할 수 있습니다. 주의할 점은 일정한 시간 
//   간격으로 실행되는 작업이 그 시간 간격보다 오래걸릴 경우 문제가 발생할 수 있습니다.
// - setTimeout()  : 일정한 시간 후에 작업을 한번 실행합니다. 보통 재귀적 호출을 
//   사용하여 작업을 반복합니다. 기본적으로 setInterval 과는 달리 지정된 시간을 
//   기다린후 작업을 수행하고, 다시 일정한 시간을 기다린후 작업을 수행하는 방식입니다.
//   지정된 시간 사이에 작업 시간이 추가 되는 것입니다. clearTimeout() 을 사용해서 
//   작업을 중지합니다.
// - clearInterval(), clearTimeout() : 이 실행중인 작업을 중지시키는 것은 아닙니다. 
//   지정된 작업은 모두 실행되고 다음 작업 스케쥴이 중지 되는 것입니다.
// ----------------------------
const oldT = Date.now();
setInterval(() => {
    const curT = Date.now();
    const diff = curT - oldT;
    const sec  = Math.floor(diff / 1000);
    document.querySelector(".sec1").innerHTML = `${sec}초경과`;
}, 1000);
// ----------------------------
// 카운트다운
const totalT  = 10000;
const oldT2   = Date.now();
const timerId = setInterval(() => {
    const curT = Date.now();
    const diff = curT - oldT2;
    const remainMSec = totalT - diff;
    const remainSec  = Math.ceil(remainMSec/ 1000);

    let label = `남은시간 : ${remainSec}`;

    // 남은시간이 0이하면
    if(remainMSec <= 0){
        // 타이머 종료
        clearInterval(timerId);
        // 타이머 종료 메시지
        label = '종료';
    }
    // 화면에 표시
    document.querySelector('.sec2').innerHTML = label;
}, 1000);
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 아날로그 시계
// ----------------------------
setInterval(()=>{
    const now = new Date();
    const h = now.getHours();   // 시간 0 ~ 23
    const m = now.getMinutes(); // 분   0 ~ 59
    const s = now.getSeconds(); // 초   0 ~ 59

    // 단침 : 단침은 시간뿐만 아니라 분도 각도에 고려해야함
    const degH = h * ( 360 / 12 ) + m * ( 360 / 12 / 60);
    // 분침
    const degM = m * ( 360 / 60 );
    // 초침
    const degS = s * ( 360 / 60 );

    const elemH = document.querySelector('.lineHour');
    const elemM = document.querySelector('.lineMin');
    const elemS = document.querySelector('.lineSec');

    elemH.style.transform = `rotate(${degH}deg)`;
    elemM.style.transform = `rotate(${degM}deg)`;
    elemS.style.transform = `rotate(${degS}deg)`;
}, 50);
// ----------------------------
// HTML
&lt;div class="clock"&gt;
    &lt;div class="lineHour"&gt;&lt;/div&gt;
    &lt;div class="lineMin" &gt;&lt;/div&gt;
    &lt;div class="lineSec" &gt;&lt;/div&gt;
&lt;/div&gt;
// ----------------------------
&lt;style&gt;
    .clock{
        border-radius: 50%;
        border : 3px solid red;
        width : 400px;
        height : 400px;
        background-color : rgba(255, 255, 255, 0.1);
        position : relative;
    }
    .lineHour {
        width : 10px;
        height : 150px;
        background: blue;
        position: absolute;
        top: calc(50% - 150px);
        left: calc(50% - 5px);
        transform-origin: bottom;
    }
    .lineMin{
        width: 4px;
        height: 200px;
        background: black;
        position: absolute;
        top: calc(50% - 200px);
        left: calc(50% - 2px);
        transform-origin: bottom;
    }
    .lineSec{
        width: 2px;
        height: 200px;
        background:  #cccccc;
        position: absolute;
        top: calc(50% -200px);
        left: calc(50% - 1px);
        transform-origin: bottom;
    }
&lt;/style&gt;
// ----------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>




</body>

</html>