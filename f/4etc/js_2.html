<!DOCTYPE html>

<head>
    <title></title>
    <!-- START -->
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!-- <link rel="stylesheet" type="text/css" href="../../etc/androidstudio.css"> -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/monokai-sublime.min.css">
    <link rel="stylesheet" type="text/css" href="../../etc/custom.css">
    <script type="text/javascript" src="../../etc/highlight.min.js"></script>
    <script type="text/javascript" src="../../etc/highlightjs-line-numbers.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>hljs.initLineNumbersOnLoad();</script>
    <!-- E N D -->
</head>

<body>
<!-- ############################################# -->
<pre><code class="javascript">// const로 정수를
// let로   변수를 취급
let   myName1 = "이름1";
const myName2 = "이름2";

// myName2 = "이름3"; // 에러

alert(myName1);
alert(myName2);
// ----------------------------
let currentDate = new Date();
let myFunc = () => console.log('함수다');

alert(currentDate);
myFunc();

let myVar;    // 초기값 미설정
alert(myVar); // undefined
// ----------------------------
// const
// 초기값의 생략이 불가능
// 값의 재설정이 불가능으로, 값의 변경이 불가능한 것은 아님
// 배열이나 오브젝트의 변경을 막으려면 Object#freeze()를 이용
const myArr = ['문','홍','안'];
console.log(myArr); // Array(3) [ "문", "홍", "안" ]

myArr[0] = '이';
console.log(myArr); // Array(3) [ "이", "홍", "안" ]

const myObj = {id:20, name:'한국'};
console.log(myObj); // Object { id: 20, name: "한국" }

myObj.name = '캐나다';
console.log(myObj); // Object { id: 20, name: "캐나다" }
// ----------------------------
// == 와 === 의 차이
// ==  : 형이 달라도 같은 것으로 판단
// === : 형이 다르면 다른 것으로 판단
// != , !== 도 같다
console.log(10 ==  '10'); // true
console.log(10 === '10'); // false</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 애로우함수 (=>)
// (인수) => { 처리내용 }
// 장점
// 1. 함수를 간결하게 작성가능
// 2. this를 속박가능
// ----------------------------
// 함수의 정의
const calcSum = (a,b,c) => {
    const result = a + b + c;
    return result;
};
console.log(calcSum(10,20,30)); // 60
// ----------------------------
// 인수가 1개일 경우, ()생략가능
// 인수가 0개이거나 2개 이상일 경우, ()생략불가
// ----------------------------
const myFunc1 = (a) => {
    return a + 2;
};
const myFunc2 = a => {
    return a + 3;    
};
console.log(myFunc1(10)); // 12
console.log(myFunc2(10)); // 13
// 애로우함수내의 처리가 1행일 경우,
// {}와 return을 생략가능
const myFunc3 = (a) => a + 4;
console.log(myFunc3(10)); // 14</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 함수의 인수에 초기값 설정
// 1. function myFunc(인수1, 인수2=초기값2, 인수3=초기값3){}
// 2. (인수1, 인수2=초기값2, 인수3=초기값3) => {}
// 초기값이 설정된 인수를 생략가능
// ----------------------------
function myFunc1(price, tax = 0.08){
    const result = price + price * tax;
    return result;
}
console.log(myFunc1(100));       // 108
console.log(myFunc1(100, 0.02)); // 102
// ----------------------------
// 함수에 임의의 개수의 인수를 건넴
// "...인수" 残余引数（rest parameters）
// 건네진 인수는 배열로 저장됨
// 1. function 함수명(...인수){}
// 2. (...인수) => {}
// 3. 인수[인덱스]
// ----------------------------
function calcSum(...prices){
    console.log(prices[0]); // 10, 5
    let result = 0;
    for(const value of prices)
        result += value;
    return result;
}
console.log(calcSum(10,20));    // 30
console.log(calcSum(5,10,20));  // 35</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// iphone인지 확인
const isIOS = navigator.userAgent.includes('iPhone');
console.log(isIOS); // false or true
// ----------------------------
// 문자열에 'vas'가 포함되는지 아닌지 확인
const flg = 'Javascript'.includes('vas');
console.log(flg);   // true</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 수치
// NaN : 수치이 아님.  부정한 계산결과
// ----------------------------
// 1.7976931348623157e+308
console.log(Number.MAX_VALUE);
// 5e-324
console.log(Number.MIN_VALUE);
// 9007199254740991
console.log(Number.MAX_SAFE_INTEGER);
// -9007199254740991
console.log(Number.MIN_SAFE_INTEGER);
// Infinity  (양의 무한의 값)
console.log(Number.POSITIVE_INFINITY);
// -Infinity (음의 무한의 값)
console.log(Number.NEGATIVE_INFINITY);</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 장방향 그라데이션
const rectangle = document.querySelector('.rectangle');

// 버튼이벤트
document.querySelector('.button').addEventListener('click', onClickButton);

function onClickButton(){
    // 0~359랜덤숫자 생성
    const randomHue        = Math.trunc(Math.random() * 360);

    // 그라데이션 시작, 종료 색 설정
    const randomColorStart = `hsl(${randomHue     }, 100%, 50%)`;
    const randomColorEnd   = `hsl(${randomHue + 40}, 100%, 50%)`;

    // 장방형의 그라데이션용 변수(--start, --end)을 변경
    rectangle.style.setProperty('--start', randomColorStart);
    rectangle.style.setProperty('--end'  , randomColorEnd);
}
// ----------------------------
// css
.rectangle {
    width :300px;
    height:300px;
    /* height:calc(100% - 50px); */
    --start: hsl(0  , 100%, 50%);
    --end  : hsl(322, 100%, 50%);
    background-image: linear-gradient(-135deg, var(--start), VAR(--end));
}</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 안전한 난수
// crypto.getRandomValues(형붙인 배열); // 리턴:난수배열
// ----------------------------
//랜덤정수(부호없는16비트)가 10개들어간 배열을 생성
const randomArr = crypto.getRandomValues(new Uint16Array(10));
console.log(randomArr);
// Uint16Array(10) [ 30106, 64439, 30547, 1975, 9450, 62468, 27533, 27756, 63786, 36283 ]
// 배열을 이어 난수를 생성
const random16 = randomArr.join('');
console.log(random16);
// 301066443930547197594506246827533277566378636283
// ----------------------------
// 부호없는 32비트 난수생성
const random32 = crypto.getRandomValues(new Uint32Array(10)).join('');
console.log(random32);
// 382979343515709866573468246670218395933328989172757469039542220903590269873746935950855881383786406
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 수학 계산
// ----------------------------
Math.abs(수치);  // 절대값
Math.pow(수치A, 수치B);  // 수치A의 수치B승
Math.sign(수치); // 수치부호를 계산
Math.sqrt(수치); // 평방근(루트2)
Math.log(수치);  // 자연대수를 계산
Math.exp(수치);  // 지수함수를 계산
Math.E           // 자연대수의 밑
Math.PI          // 원주율
Math.cos(수치);  // 코사인
Math.sin(수치);  // 사이
Math.tan(수치);  // 탄젠트
Math.acos(수치); // 아크코사인
Math.asin(수치); // 아크사인
Math.atan(수치); // 아크탄젠트
Math.atan2(y좌표, x좌표); // (x,y)의 좌표의 각도</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 문자열
// ----------------------------
// 길이
console.log("string".length); // 6
console.log(Array.from('string2').length); // 7
// ----------------------------
// 문자열양끝 공백, 탭, 개행 제거
console.log(" str ing ".trim()); // "str ing"
// ----------------------------
// 문자열 검색(검색결과없으면 -1을 반환)
// 대소문자 구분함, 인덱스를 반환
// - 대상문자열.indexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.lastIndexOf(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.search(정규표현)
const str = 'Javascript를 배우자.';
const s1 = str.search(/Javascript/);
const s2 = str.search(/HTML/);
console.log(s1); // 0 : hit
console.log(s2); // -1 : no hit
// ----------------------------
// 문자열이 포함되어 있는가. (참/거짓을 리턴)
// - 대상문자열.includes(검색할 문자열, [검색개시 인덱스])
// 문자열로 시작하는가, 끝나는가
// - 대상문자열.startsWith(검색할 문자열, [검색개시 인덱스])
// - 대상문자열.endsWith(검색할 문자열, [검색개시 인덱스])
const a1 = str.includes("script");
const a2 = str.startsWith("javascript");
const a3 = str.endsWith("배우자.");
console.log(a1); // true
console.log(a2); // false
console.log(a3); // true
// ----------------------------
// 문자추출
// 문자열.charAt(인덱스)
console.log("string".charAt(3)); // i
console.log("string".charAt());  // s
// 문자열.slice(시작인덱스, [종료인덱스])
// 문자열.substring(시작인덱스, [종료인덱스])
// 종료인덱스를 생략하면 문자열끝까지
// slice()음수지정가능(뒤에서부터 추출)
// slice()와 substring()은 시작idx가 종료idx보다 
// 클경우의 처리가 다름. (시작idx, 종료idx를 바꿔서 처리)
const str2 = "kwak no1";
console.log(str2.slice(2,4));       // ak
console.log(str2.substring(2,4));   // ak
console.log(str2.slice(0));         // kwak no1
console.log(str2.substring(0));     // kwak no1
console.log(str2.slice(1, -1));     // wak no
console.log(str2.substring(1, -1)); // k
console.log(str2.slice(3, 1));      // <empty string>
console.log(str2.substring(3, 1));  // wa
// ----------------------------
// 문자열.substr(시작인덱스, [취득문자수])
// @deprecated
console.log(str2.substr(1, 3));  // wak
// ----------------------------
// 문자열치환
// 문자열1/정규펴현을 문자열2로 바꿈
// 대상문자열.replace(문자열1, 문자열2)
// 대상문자열.replace(정규표현, 문자열2)
const phone = '111-2222-3333';
console.log(phone.replace(/-/g, '')); // 11122223333
// ----------------------------
// * 버튼의 디폴트 이벤트 무효화
// document.querySelector('#submitBtn')
//        .addEventListener('click'
//        , (event)=>{ event.defaultPrevented(); });
// ----------------------------
// 문자열분할
// 문자열.split([구분문자], [분할수])
// 문자열.split([정규표현], [분할수])
// 빈문자로 분할하면 한글자씩 들어간 배열이 리턴
// 인수를 생략하면 하나의 전체문자열이 들어간 배열 리턴
// ----------------------------
// 문자열결합
// 문자열1+문자열2+문자열3
// `${문자열1}${문자열2}${문자열3}`
// ----------------------------
// 문자열변환
// 대 - 소문자
// 문자열.toLowerCase()
// 문자열.toUpperCase()
// ----------------------------
// 정규표현
// "/패턴/"형식으로 사용
// -----------
// 패턴     의미
// x        x라는 1문자    
// xyx      xyz라는 문자열
// [xyz]    xyz중 1문자
// [a-z]    a~z중 1문자
// [^xyz]   xyz이외의 1문자
// [^a-z]   a~z이외의 1문자
// abc|xyz  abc 또는 xyz라는 문자열
// {숫자}   반복횟수
// ^x       첫문자가 x
// x$       마지막 문자가 x
// .        개행문자를 제외한 1문자
// x*       x가 0개 이상 반복
// \        다음문자를 이스케이프함
// \d       숫자     => [0~9]
// \D       숫자이외 => [^0~9]
// \w       영문자, 언더스코어 => [A-Za-z0-9_]
// \s       스페이스, 탭, 개행문자등의 공백문자
// \S       공백이외의 문자 => [^\s]
// \t       수평탭
// \n       개행문자
// -----------
// 조건에 매치하는 문자열 검색
// /패턴/.test(문자열)
console.log(/J/.test('Javasscript'));     // true
console.log(/^iP/.test('iPhone'));        // true
console.log(/iP$/.test('iPhone'));        // false
// 숫자포함
console.log(/\d/.test('iPh4one'));        // true
// a가 0회 이상 반복
console.log(/java.*/.test('javascript'));  // true
console.log(/java.*/.test('javasscript')); // true
console.log(/\d+-\d+-\d+/.test('090-1234-5678'));    // true
// 0에서 시작해서 10혹은 11자의 숫자인가 확인
console.log(/^[0][0-9]{9,10}$/.test('01234567890')); // true
// ----------------------------
// 소수점 표현
// 수치.toFixed([문자수]); // 소수점이하를 지정한 문자수로 한다.
// 수치.toPrecision([문자수]); // 지정문자수를 精度로 한다.
console.log((0.3333).toFixed(2)); // 0.33
console.log((0.3353).toFixed(2)); // 0.34
console.log((123.456).toFixed(3)); // 123.456
// ------------
console.log((0.3333).toPrecision(2)); // 0.33
console.log((0.3353).toPrecision(2)); // 0.34
console.log((123.456).toPrecision(3)); // 123
// 精度4에 의해 0이 매꿔짐
console.log((10).toPrecision(4)); // 10.00
// ----------------------------
const sndElem  = document.querySelector('.second');
// 3초후가 골
const goalTime = new Date().getTime() + 3 * 1000;
update();
function update(){
    // 현재시작
    const currentTime = new Date().getTime();
    // 남은시간
    const leftTime = goalTime - currentTime;
    if(leftTime < 0) return;
    // 초를 표시.소수점(미리초는 2자만)
    sndElem.innerText = (leftTime/1000).toFixed(2);
    // ★ 다음 프레임에서 다시 update를 실행
    requestAnimationFrame(update);
}
// ----------------------------
// 문자열 반복
// 문자열.padStart(반복할 길이, [추가할 문자열])
// 문자열.padEnd(반복할 길이, [추가할 문자열])
console.log('5'.padStart(2, '0'));  //  05
console.log('ff'.padEnd(6, '0'));   //  ff0000
console.log('ff'.padEnd(6));        // "ff    "
console.log('123'.padStart(3,'0')); // 123
function zeroPadding(num){
    return String(num).padStart(2, '0');
}
// ----------------------------
// 문자열을 URI인코드
// encodeURIComponent()는 다음 문자도 이스케이프함
// / ? & = + : @ $ ; , #
var uri1 = encodeURI('http://www.한글.com/주소.html');
console.log(uri1);
// http://www.%ED%95%9C%EA%B8%80.com/%EC%A3%BC%EC%86%8C.html
var uri2 = encodeURIComponent('http://www.한글.com/주소.html');
console.log(uri2);
// http%3A%2F%2Fwww.%ED%95%9C%EA%B8%80.com%2F%EC%A3%BC%EC%86%8C.html
// 디코드
console.log(decodeURI(uri1));
// http://www.한글.com/주소.html
console.log(decodeURIComponent(uri2));
// http://www.한글.com/주소.html
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 배열
// ----------------------------
// [] : 배열을 정의
const arr1 = [];               // 빈배열
const arr2 = [1,2,3];          // 배열 초기화
const arr3 = new Array(4,5,6); // 배열초기화
// 인수가 1개의 수치일 경우에는 지정개수의 배열이 작성됨
const arr4 = new Array(10);    // 10개의 수를 넣을수 있는 배열
// ----------------------------
console.log(arr3.length); // 3
// ----------------------------
// 배열의 각요소에 대해 처리 (1)
// 베열.forEach(콜백함수)
// 인수로 건넨 콜백함수를 써서 요소를 순서대로 처리
// 콜백함수 (* : 생략가능)
// ([요소*], [인덱스*], [元배열*]) => {} 
const arr5 = ['딸기','귤','사과'];
arr5.forEach((value, index) => {
    console.log(index, value);
});
// 0 딸기
// 1 귤
// 2 사과
// -----------
[1,2,3,4,5,6,7]
    .filter( (value) => value % 2 === 0)
    .forEach((value) => {
        console.log(value); // 2 4 6
    });  
// ----------------------------
// 배열의 각요소에 대해 처리 (2)
// for(const 요소 of 배열) {}
for(const val of arr5){
    console.log(val); // 딸기 , 귤 , 사과
}
// ----------------------------
// 배열의 각요소에 대해 처리 (3)
for(let i = 0; i < arr5.length; i++){
    console.log(arr5[i]); // 딸기 , 귤 , 사과
}
// ----------------------------
// 배열에 요소 추가
// 배열.unshift(요소1, 요소2) : 선두에 요소추가
// 배열.push(요소1, 요소2)    : 말미에 요소추가
// ----------------------------
// 배열.shift() : 선두의 요소를 제거
// 배열.pop()   : 마지막 요소를 제거
const arr7 = ['딸기','귤','사과'];
const itemShift = arr7.shift();
console.log(itemShift);      // 딸기
console.log(arr7);           // 귤, 사과
// ------------
const itemPop = arr7.pop();
console.log(itemPop);        // 사과
console.log(arr7);           // 귤
// ----------------------------
// 배열의 요소 일부는 치환
// 배열.splice(추가위치, 추출할 개수, 요소1, 요소2)
const arr8 = ['사과','귤'];
const arr9 = ['사과','귤'];
// ------------
arr8.splice(1, 0, '바나나');        // 1의 위치에 0개를 지우고 바나나를 추가
arr9.splice(1, 1, '바나나','딸기'); // 1의 위치에 1개를 지우고 추가
// ------------
console.log(arr8); // [ "사과", "바나나", "귤" ]
console.log(arr9); // [ "사과", "바나나", "딸기" ]
// ----------------------------
// 배열연결
// 배열1.concat(배열2, 배열3)
// [...배열1, ...배열2, ...배열3]
const a1 = [1,2,3];
const a2 = ['a','b','c'];
const a3 = ['ㄱ','ㄴ'];
const a4 = a1.concat(a2,a3);
const a5 = [...a1, ...a2];
console.log(a4); // [ 1, 2, 3, "a", "b", "c", "ㄱ", "ㄴ" ]
console.log(a5); // [ 1, 2, 3, "a", "b", "c" ]
// ----------------------------
// 배열요소를 문자열로 결합
const a6 = a2.join();
const a7 = a2.join('');
console.log(a6); // a,b,c
console.log(a7); // abc
// ----------------------------
// 요소 검색
// 배열.indexOf(검색하고 싶은 요소, [검색시작위치])
// 배열.lastIndexOf(검색하고 싶은 요소, [검색시작위치])
// 배열.includes(검색하고 싶은 요소, [검색시작위치])
const b1 = [0,2,4,6,4,2,0];
console.log(b1.indexOf(4));     // 2
console.log(b1.lastIndexOf(4)); // 4
console.log(b1.includes(3));    // false
// ----------------------------
// 배열에서 조건 검색
// 배열.find(콜백함수)
// : 콜백함수에 처음 일치하는 요소
// 배열.findIndex(테스트함수)
// : 콜백함수에 처음 일치하는 요소의 인덱스
// 콜백함수
// :  ([요소],[인덱스],[元배열]) => 진리값
const c1 = ['스즈키','다나카','다카하시','고토'];
const targetUser1 = c1.find((elem) => elem == '다나카');
// 위와 동일
const targetUser2 = c1.find((elem) => { return elem == '다나카'; });
const targetUser3 = c1.findIndex((elem) => { return elem == '다나카'; });
console.log(targetUser1); // 다나카
console.log(targetUser2); // 다나카
console.log(targetUser3); // 1
// ----------------------------
// 배열의 역순
// 배열.reverse()
const c2 = [1,3,5];
console.log(c2); // [ 1, 3, 5 ]
c2.reverse();
console.log(c2); // [ 5, 3, 1 ]
// ----------------------------
// 배열을 정렬
// 배열.sort([비교함수])
// : 비교함수의 리턴값의 대소에 따라 정렬
//   0미만   : a, b의 순으로 정렬 
//   0       : a, b순서을 안바꿈
//   0보다큼 : b, a의 순으로 바꿈
// : 비교함수를 생략하면 문자열로 유니코드순으로 정렬
const c3 = [1,2,3,3,4,5];
c3.sort((a,b) => {
    // a가 b보다 작으면, a,b순으로 정렬
    if(a <  b) return  1; 
    if(a == b) return  0;
    if(a >  b) return -1;
});
console.log(c3); // [ 5, 4, 3, 3, 2, 1 ]
// ----------------------------
// 문자열 대소무시하고 비교 정렬
const c4 = ['grape','Orange','apple'];
c4.sort();
console.log(c4); // [ "Orange", "apple", "grape" ]
// ------------
const c5 = ['grape','Orange','apple'];
c5.sort((a,b) => a.localeCompare(b));
console.log(c5); // [ "apple", "grape", "Orange" ]
// ----------------------------
// 배열에서 새 배열 만들기
// 배열.map(콜백함수)
// : 콜백함수에 따라 새로운 배열을 작성
// : ([요소],[인덱스],[元배열]) => 밴경후의 요소
//   요소를 받아, 변경후의 요소를 반환
// map()
// : 어떤 배열을 근거로 새로운 배열을 만듬
//   요소 하나씩하나씩 처리
//   forEach()와 비슷한데 
//   map()는 실행후의 결과를 배열로 반환하는 점이 다름
const idList1  = [4, 10, 20];
const newList1 = idList1.map((value) => `userid_${value}`);
console.log(newList1); // [ "userid_4", "userid_10", "userid_20" ]
// ------------
const idList2  = [3, 8, 12];
const newList2 = idList1.map((value, index) => `userid_${index + 1}_${value}`);
console.log(newList2); // [ "userid_1_4", "userid_2_10", "userid_3_20" ]
// ------------
const idList3 = [
    { id:  2, name:'스즈키'  },
    { id: 10, name:'다나카'  },
    { id:  4, name:'사토'    },
    { id: 29, name:'다카하시'},
    { id:101, name:'오기하라'}
];
const newList3 = idList3.map((value) => value.id);
// 위와 같음
const newList4 = idList3.map((value) => { return value.id });
console.log(newList3); // [ 2, 10, 4, 29, 101 ]
console.log(newList4); // [ 2, 10, 4, 29, 101 ]
// ----------------------------
// 한 배열에서 조건을 만족하는 배열을 작성
// 배열.filter(콜백함수)
// 콜백함수에 일치하는 배열을 생성
// ([요소],[인덱스],[元배열]) => 진리값
const d1 = [10,20,30,40];
const d2 = d1.filter((value) => value >= 30);
const d3 = d1.filter((value) => { return value >= 30 });
const d4 = d1.filter(function (value) { return value >= 30; })
console.log(d2); // [ 30, 40 ]
console.log(d3); // [ 30, 40 ]
console.log(d4); // [ 30, 40 ]
// map과 filter의 
// : 공통점은 기존배열은 건드리지 않으면서 요소들을 순회한 후 
//   새로운 배열을 리턴한다는 것이고, 
// : 차이점은 map은 콜백함수가 적용된 새 요소, 
//   filter는 조건문을 만족한 요소들을 반환한다는 점입니다.
// ----------------------------
// 각 요소들로 부터 단일 값을 만듬
// 배열.reduce(콜백함수, [초기값])
// : 각 요소의 왼쪽에서 오른쪽으로 처리해서 단일값을 만듬
// 배열.reduceRight(콜백함수, [초기값])
// : 각 요소의 오른쪽에서 왼쪽으로 처리해서 단일값을 만듬
// 콜백함수
// ((앞요소, 현재요소, 인덱스, 元배열)) => { /* 처리 */}
const e1   = [100, 500, 900];
const sum1 = e1.reduce((previous, current) => { return previous + current; });
// 위와 같음
const sum2 = e1.reduce((a, b) => a + b );
let   sum3 = 0;
for(const price of e1){
    sum3 += price;
}
console.log(sum1); // 1500
console.log(sum2); // 1500
console.log(sum3); // 1500
// 2차 배열을 1차 배열로 만듬
const e2 = [['바나나','사과','딸기'],['귤','포도']];
const e3 = e2.reduce((a,b) => { return a.concat(b); });
const e4 = e2.reduceRight((a,b) => { return a.concat(b); });
console.log(e3); // [ "바나나", "사과", "딸기", "귤", "포도" ]
console.log(e4); // [ "귤", "포도", "바나나", "사과", "딸기" ]
// ----------------------------
// 배열과 비슷한 오브젝트를 배열로 변환
// [...변환대상]
// "..." (スプレッド연산자)
// : ArrayLike오브젝트를 배열로 변환
// ArrayLike오브젝트
// : length프로퍼티로 길이를 취득가능
//   index가 부여된 요소를 가짐
//   예) NodeListOf오브젝트(배열은 아니기 때문에 filter()사용불가)
const f1 = '안녕하세요';
const f2 = [...f1];
console.log(f1); // 안녕하세요
console.log(f2); // "안", "녕", "하", "세", "요" ]
// ------------
// Array.from(변환대상, [콜백함수])
// 로도 변환가능
// ([요소],[인덱스],[元배열]) => {}
const f3 = Array.from(f1);
const f4 = Array.from(f1, (c) => `${c}!!`);
console.log(f3);
// "안", "녕", "하", "세", "요" ]
console.log(f4);
// [ "안!!", "녕!!", "하!!", "세!!", "요!!" ]
// ----------------------------
// 복수의 값을 한번에 대입 (분할대입)
// [변수1, 변수2, 변수3] = [값1, 값2, 값3]
let a, b, c;
[a, b, c] = [1, 2, 3];
console.log(a, b, c); // 1 2 3
// ------------
// 값 치환
const f5 = ['스즈키','다나카'];
console.log(f5); // [ "스즈키", "다나카" ]
[f5[0], f5[1]] = [f5[1], f5[0]];
console.log(f5); // [ "다나카", "스즈키" ]
// ----------------------------
// 배열 섞기
const g1 = [1,2,3,4,5];
const arrLen = g1.length;
// Fisher-Yates알고리즘
for(let i = arrLen - 1; i >= 0 ; i--){
    const randomIdx = Math.floor(Math.random() * (i+1));
    [g1[i], g1[randomIdx]] = [g1[randomIdx], g1[i]];
}
console.log(g1); // [ 5, 1, 3, 2, 4 ]
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 오브젝트
// : 복수의 프로퍼티를 갖음
// 프로퍼티
// : 키-값 조합
const object = {}; // 빈 오브젝트
// ----------------------------
const person = {
    id:1,
    name:'스즈키',
    age:28
}
console.log(person.id);      // 1
console.log(person[name]);   // undefined
console.log(person['name']); // 스즈키
// ----------------------------
person.id = 99;
console.log(person.id);      // 99
// ----------------------------
const resp = {
    result:true,
    list:[{id:1, name:'다나카', age:26}
        ,{id:2, name:'곽', age:39}]
};
console.log(resp.list[0].name); // 다나카
console.log(resp.list[1].id);   // 2
resp.list[1].id = 98;
console.log(resp.list[1].id);   // 98
// ----------------------------
// 함수도 가능
const myClass = {
    method1 : function(){
        console.log('1실행');
    },
    method2 : function(){
        console.log('2실행');
    }
};
myClass.method2(); // 2실행
// ----------------------------
// 오브젝트 복사
const object1 = {
    result:true,
    members:[
        {id:1, name:'다나카1', age:26},
        {id:2, name:'다나카2', age:27},
        {id:3, name:'다나카3', age:28}
    ]
};
// Object.assign() 사용
const copiedObj1 = Object.assign({}, object1);
// ----------------------------
// ...(스프레드연산자)사용
const copiedObj2 = {...object1};
// Object.assign()/...(스프레드연산자)는 얕은 복사
// 얕은복사:복사元、복사先가 같은 데이터를 참조
// 복사元의 오브젝트의 조작은 복사先에 영향을 끼침
console.log(copiedObj1.result);          // true
console.log(copiedObj2.members[0].name); // 다나카1
object1.result = false;
object1.members[0].name='스즈키';
console.log(copiedObj1.result);          // true
console.log(copiedObj2.members[0].name); // 스즈키
// ----------------------------
// 오브젝트에 프로퍼티의 존재 체크
// 오브젝트.hasOwnProperty('키')
var ret1 = object1.hasOwnProperty('result');
var ret2 = 'members' in object1;
var ret3 = object1.result != null;
var ret4 = object1.no != null;
console.log(ret1); // true
console.log(ret2); // true
console.log(ret3); // true
console.log(ret4); // false
// ----------------------------
// 값에 대해 처리
// Object.keys(오브젝트)
// Object.values(오브젝트)
// Object.entries(오브젝트) // 각 프로퍼티의 배열
const person2 = {
    id2:1,
    name2:'스즈키',
    age2:28
}
console.log(Object.keys(person2));    // [ "id2", "name2", "age2" ]
console.log(Object.values(person2));  // [ 1, "스즈키", 28 ]
console.log(Object.entries(person2));
// 0: Array [ "id", 1 ]
// 1: Array [ "name", "스즈키" ]
// 2: Array [ "age", 28 ]
// ----------------------------
// 복수의 변수에 값을 한번에 대입
// 변수명 일치 필요
const {id2, name2, age3} = person2;
console.log(name2); // 스즈키
console.log(age3);  // undefined
// 별명은 가능
const {name2:yourName} = person2;
console.log(yourName); // 스즈키
// ----------------------------
// 오브젝트를 편집불가로 변경
// Object.freeze(오브젝트)
// Object.isFrozen(오브젝트)
// 오브젝트는 const여도 프로퍼티의 추가/삭제/변경이 가능
const object2 = {id:10, name:'다나카'};
console.log(object2); // { id: 10, name: "다나카" }
object2.id = 12;
object2.address = '서울';
console.log(object2); // { id: 12, name: "다나카", address: "서울" }
// "'use strict';" => 선두에 선언 에러감지를 유효화
Object.freeze(object2);
object2.id = 99; // "'use strict';" 없으면 에러는 안남
object2.mail = 'a@gmail.com';
console.log(object2); // { id: 12, name: "다나카", address: "서울" }
// ----------------------------
const arr1 = [1,2,3];
Object.freeze(arr1);
console.log(arr1);
// arr1.push(99); // "'use strict';" 없어도 에러남
console.log(Object.isFrozen(arr1)); // true
// ----------------------------
// 다른 방법
// - Object.seal() : 프로퍼티의 추가/삭제만 금지, 변경은 가능.
// - Object.preventExtensions() : 프러퍼티의 추가만 금지, 삭제/변경가능.
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// * 데이터형
// 1) 기본형
//    - Boolean, String, Number
//      Undefined : 값이 미정을 나타내는 형 
//      Null      : 값이 존재하지 않음을 나타내는 형
//      Symbol    : 심볼형
//    - immutable
//    - call by value
// 2) 오브젝트형
//    - Object : 오브젝트형(기본형이외의 모든형(Array, Object, Date등))
//    - mutable
//    - call by ref
// ----------------------------
// * 데이터형 조사
// typeof 값
// ----------------------------
// * 인스턴스조사
// 값 instanceof 오브젝트
// ----------------------------
// * 형변환
// Boolean(값)
// String(값)
// Number(값)
// parseInt(문자열)
// parseFloat(문자열)
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
const date    = new Date();
const year    = date.getFullYear();
const month   = date.getMonth() + 1;
const day     = date.getDate();
const h       = date.getHours();
const m       = date.getMinutes();
const s       = date.getSeconds();
const dayList = ['일','월','화','수','목','금','통'];
const week    = dayList[date.getDay()];
// ----------------------------
document.querySelector(".log1").innerHTML = 
    `지금은 ${year}년 ${month}월 ${day}일 ${week}요일 `
    + `${h}시 ${m}분 ${s} 초이다.`;
// 지금은 2022년 2월 14일 월요일 21시 16분 57 초이다.
// ----------------------------
const locale    = date.toLocaleString();
const localDate = date.toLocaleDateString();
const localTime = date.toLocaleTimeString();
// ----------------------------
document.querySelector(".log2").innerHTML = 
    `${locale}<br/>`
    + `${localDate}<br/>`
    + `${localTime}`;
// 2022. 2. 14. 오후 9:16:57
// 2022. 2. 14.
// 오후 9:16:57
// ----------------------------
const num1 = Date.parse('2022/02/14');
console.log(num1);           // 1644764400000
console.log(date.getTime()); // 1644841858431
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
const date1 = new Date('2022/02/15 01:02:03');
const date2 = new Date('Tue Feb 15 2022 01:02:03');
const date3 = new Date(2022, 02, 15, 01, 02, 03);
console.log(date1); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
console.log(date2); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
console.log(date3); // Tue Mar 15 2022 01:02:03 GMT+0900 (대한민국 표준시)
// ----------------------------
const date4 = new Date('2022/02/15 01:02:03');
date4.setMonth(date4.getMonth() -1); // 한달전
console.log(date4.toLocaleDateString()); // 2022. 1. 15.
date4.setDate(date4.getDate() + 5);  // 5일 뒤
console.log(date4.toLocaleDateString()); // 2022. 1. 20.
// ----------------------------
const dateA = new Date('2022/02/15');
const dateB = new Date('2022/03/15');
const diffM = dateB.getTime() - dateA.getTime();
const diffD = diffM / (24 * 60 * 60 * 1000);
console.log(`차이 : ${diffD}일`); // 차이 : 28일
// ----------------------------
const dateC = new Date('2022/02/15 01:02:03');
const dateD = new Date('2022/02/15 03:02:03');
const diffM2 = dateD.getTime() - dateC.getTime();
const diffD2 = diffM2 / (60 * 60 * 1000); // 60 * 1000 => 분
console.log(`차이 : ${diffD2}시간`); // 차이 : 2시간
// ----------------------------
// - setInterval() : 일정한 시간 간격으로 작업을 수행하기 위해서 사용합니다.
//   clearInterval 함수를 사용하여 중지할 수 있습니다. 주의할 점은 일정한 시간 
//   간격으로 실행되는 작업이 그 시간 간격보다 오래걸릴 경우 문제가 발생할 수 있습니다.
// - setTimeout()  : 일정한 시간 후에 작업을 한번 실행합니다. 보통 재귀적 호출을 
//   사용하여 작업을 반복합니다. 기본적으로 setInterval 과는 달리 지정된 시간을 
//   기다린후 작업을 수행하고, 다시 일정한 시간을 기다린후 작업을 수행하는 방식입니다.
//   지정된 시간 사이에 작업 시간이 추가 되는 것입니다. clearTimeout() 을 사용해서 
//   작업을 중지합니다.
// - clearInterval(), clearTimeout() : 이 실행중인 작업을 중지시키는 것은 아닙니다. 
//   지정된 작업은 모두 실행되고 다음 작업 스케쥴이 중지 되는 것입니다.
// ----------------------------
const oldT = Date.now();
setInterval(() => {
    const curT = Date.now();
    const diff = curT - oldT;
    const sec  = Math.floor(diff / 1000);
    document.querySelector(".sec1").innerHTML = `${sec}초경과`;
}, 1000);
// ----------------------------
// 카운트다운
const totalT  = 10000;
const oldT2   = Date.now();
const timerId = setInterval(() => {
    const curT = Date.now();
    const diff = curT - oldT2;
    const remainMSec = totalT - diff;
    const remainSec  = Math.ceil(remainMSec/ 1000);

    let label = `남은시간 : ${remainSec}`;

    // 남은시간이 0이하면
    if(remainMSec <= 0){
        // 타이머 종료
        clearInterval(timerId);
        // 타이머 종료 메시지
        label = '종료';
    }
    // 화면에 표시
    document.querySelector('.sec2').innerHTML = label;
}, 1000);
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 아날로그 시계
// ----------------------------
setInterval(()=>{
    const now = new Date();
    const h = now.getHours();   // 시간 0 ~ 23
    const m = now.getMinutes(); // 분   0 ~ 59
    const s = now.getSeconds(); // 초   0 ~ 59

    // 단침 : 단침은 시간뿐만 아니라 분도 각도에 고려해야함
    const degH = h * ( 360 / 12 ) + m * ( 360 / 12 / 60);
    // 분침
    const degM = m * ( 360 / 60 );
    // 초침
    const degS = s * ( 360 / 60 );

    const elemH = document.querySelector('.lineHour');
    const elemM = document.querySelector('.lineMin');
    const elemS = document.querySelector('.lineSec');

    elemH.style.transform = `rotate(${degH}deg)`;
    elemM.style.transform = `rotate(${degM}deg)`;
    elemS.style.transform = `rotate(${degS}deg)`;
}, 50);
// ----------------------------
// HTML
// &lt;div class="clock"&gt;
//     &lt;div class="lineHour"&gt;&lt;/div&gt;
//     &lt;div class="lineMin" &gt;&lt;/div&gt;
//     &lt;div class="lineSec" &gt;&lt;/div&gt;
// &lt;/div&gt;
// ----------------------------
// &lt;style&gt;
//     .clock{
//         border-radius: 50%;
//         border : 3px solid red;
//         width : 400px;
//         height : 400px;
//         background-color : rgba(255, 255, 255, 0.1);
//         position : relative;
//     }
//     .lineHour {
//         width : 10px;
//         height : 150px;
//         background: blue;
//         position: absolute;
//         top: calc(50% - 150px);
//         left: calc(50% - 5px);
//         transform-origin: bottom;
//     }
//     .lineMin{
//         width: 4px;
//         height: 200px;
//         background: black;
//         position: absolute;
//         top: calc(50% - 200px);
//         left: calc(50% - 2px);
//         transform-origin: bottom;
//     }
//     .lineSec{
//         width: 2px;
//         height: 200px;
//         background:  #cccccc;
//         position: absolute;
//         top: calc(50% -200px);
//         left: calc(50% - 1px);
//         transform-origin: bottom;
//     }
// &lt;/style&gt;
// ----------------------------
</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// window객체이기때문에 window생략가능
// window.alert('');
// alert('');
// ----------------------------
// confirm() 
// : 확인 다이얼로그, return T/F
// ----------------------------
// 문자입력프롬프트
// prompt(메시지내용, 입력란에 표시할 초기값)
// : return 문자열
// : 닫을 때까지 브라우저 조작안됨
// const str1 = prompt('Q', 'input answer');
// console.log(str1);
// ----------------------------
// 브라우저 사이즈 조사
// : 단위는 px, 읽기전용
// : 변화는 resize이벤트를 참조
const w = window.innerWidth;
const h = window.innerHeight;
console.log(w);
console.log(h);
window.addEventListener('resize', resizeHandler);

function resizeHandler(event){
    const w1 = innerWidth;
    const h1 = innerHeight;
    document.querySelector('.val_w').innerHTML = `너비:${w1}px`;
    document.querySelector('.val_h').innerHTML = `높이:${h1}px`;
}
// ----------------------------
// 디바이스의 pixel비를 초사
const dpr = window.devicePixelRatio;
console.log(dpr); // 1.5
// 캔버스 논리적인 크기
const can_w = 200;
const can_h = 200;
// 캔버스 사이즈 조절
const canvas = document.querySelector('#myCanvas');
canvas.width  = can_w * dpr;
canvas.height = can_h * dpr;
canvas.style.width  = can_w + 'px';
canvas.style.height = can_h + 'px';

const context = canvas.getContext('2d');
// 스케일 설정
context.scale(dpr, dpr);
// 원
context.fillStyle = 'red';
context.arc(can_w / 2, can_h / 2, 100, 0, 2 * Math.PI);
context.fill();

// 로그표시
document.querySelector('.canv_log').innerHTML = `現在のデバイスピクセル比は ${dpr} です`;
// ---------------------------
// 터치 가능 조사
// window.ontouchstart
// : 터치시작이벤트
// navigator.pointerEnabled
// : 포인터 사용가능 조사
// navigator.maxTouchPoints
// : 포인터 최대치
const isSupported = !!(
    'ontouchstart' in window || // ios & android
    (navigator.pointerEnabled && navigator.maxTouchPoints > 0) // IE11+
);
console.log(isSupported); // false
// ---------------------------

</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ---------------------------
// 페이지 이동
console.log(location.href); // 현재웹페이지URL
// => file:///D:/200.dev/201.src/_githubIO/ref/_test/js/002.html
location.href = 'http://www.google.com';
// 값을 대입한 타이밍에 페이지 이동
// ---------------------------
// 페이지 리로드
location.reload();     // => 브라우저의 캐시를 사용.
location.reload(true); // => 브라우저의 캐시를 무시.
// ---------------------------
// 브라우저의 '뒤로 돌아가기' 버튼과 같은 동작
history.back();    // 돌아가기
history.forward(); // 진행
history.go(수치);  // 임의의 수만큰 돌아감
history.go(-1) == history.back();
// ---------------------------
// 앵커사용
const hash = location.hash;
console.log(hash);
// ---------------------------
// hash 변경 이벤트
// &lt;a href="#orange"&gt;オレンジのアンカーリンク&lt;/a&gt;
window.addEventListener('hashchange', handleHashChange);
handleHashChange();

function handleHashChange(){
    const hash = location.hash;
    document.querySelector('.log1').innerHTML = `현재의 앵커는 ${hash}`;
}
// ---------------------------
// 새로운 윈도우로 URL열기
const win = window.open('http://www.google.co.kr');
// 뒤에서 열리는 경우도 있기때문에 포커스를 맞춰줌
win.focus();
// ---------------------------
// 윈도우 스크롤양을 조사
const x = window.screenX;
const y = window.screenY;
console.log(x);
console.log(y);
// ---------------------------
// 윈도우를 스크롤 시킴
// window.scrollTo(0, 1000);
// ---------------------------
// 타이틀 변경
// document.title
const title = document.title;
document.querySelector('#btnApple').addEventListener('click', ()=>{
    document.title = 'APPLE';
});
document.querySelector('#btnOrange').addEventListener('click', ()=>{
    document.title = 'ORANGE';
});
// ---------------------------
// 윈도우가 포커스가 되어 있나 조사
window.addEventListener('focus', ()=>{
    document.querySelector('.log1').innerHTML = `Focus 되어 있음`;
});
window.addEventListener('blur', ()=>{
    document.querySelector('.log1').innerHTML = `Focus 되어 있지 않음`;
});
// ---------------------------
// 전체화면 표시
const btn = document.querySelector('#btnFull');
btn.addEventListener('click', ()=>{
    document.body.requestFullscreen();
});
// 전체화면 끄기
const btnE = document.querySelector('#btnExit');
btnE.addEventListener('click', ()=>{
    document.exitFullscreen();
});
// ---------------------------
// 온라인/오프라인 처리 분기
const isOnline = navigator.onLine; // 상태취득
if(isOnline === true){
    console.log('온라인')
}else{
    console.log('오프라인')
}
window.addEventListener('online', ()=>{
    console.log('온라인');
});
window.addEventListener('offline', ()=>{
    console.log('오프라인');
});
// ---------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 이벤트
// 이벤트타겟.addEventListener(이벤트명, 리스너, [옵션])
// : 이벤트리스너는 이벤트타겟에 이벤트가 발생했을 때의 처리를 말함
// ----------------------------
// 방법1
const button = document.querySelector('.clsBtn');
button.addEventListener('click', () => { console.log('1234'); });
// 방법2
button.addEventListener('click', function() { console.log('1234'); });
// 방법3
button.addEventListener('click', funcOnclick);
function funcOnclick() { console.log('1234')}; 
// ----------------------------
// 이벤트 정보참조
button.addEventListener('click', (e) => { 
    console.log(e.target); // 이벤트가 발생한 요소 참조`
    console.log(e.target.outerHTML); 
});
// ----------------------------
// 옵션
// capture : capture phase를 취득할 것인가 => 참/거짓
// once    : 리스너를 한번만 호출할 것인가 => 참/거짓
// passive : 패시브이벤트인가 아닌가 => 참/거짓
const opt = { once : true };
document.querySelector('.clsBtn2')
        .addEventListener('click', () => { console.log('1234'); }, opt);
// ----------------------------
// 이벤트 삭제
// - 함수명을 기재(애로우함수는 불가능)
// - addEventListener()의 인수도 같은 인수를 지정
const button3 = document.querySelector('.clsBtn3');
button3.addEventListener('click', funcOnclick3);
// 10초후 이벤트 리스너 삭제
setTimeout(() => { button3.removeEventListener('click', funcOnclick3);}, 10000);
function funcOnclick3() { console.log('3333')}; 
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 페이지가 표시될 때 처리
// - DOMContentLoaded : HTML문서 해석 완료시
// - load             : 모든 리소스의 읽기 완료시
// js의 DOM요소의 조작은 HTML문서의 읽기와 해석이 완료되 후에 가능
// 이 타이밍에 발생하는 것이 DOMContentLoaded이벤트
window.addEventListener('DOMContentLoaded', () => {
    // .box요소의 개수
    const boxNum = document.querySelectorAll('.box').length;
    console.log(`box의 개수는 ${boxNum}개이다.`);
});
// load이벤트는 페이지내의 모든 리소스의 읽기가 끝난후에 발생.
// 그때문에 DOMContentLoaded보다도 타이밍이 늦다.
// 페이지를 표시할때 요소를 조작하고 싶다면 'DOMContentLoaded"가 적절
// ----------------------------
// js의 defer는 스크립트가 HTML해석종료후에 실행됨.
// 이것은 'DOMContentLoaded'발생전.
// 때문에 'defer'를 설정했다면, 'DOMContentLoaded'는 불필요.
// defer : HTML해석완료후에 js스크립트를 실행-->
// &lt;script src="002.js" defer /&gt;
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 이벤트
// - click
// - mousedown
// - mouseup
// - mousemove
// - mouseenter
// - mouseleave
// - mouseover
// - mouseout
// ----------------------------
document.querySelector('.box').addEventListener('mouseenter', ()=>{
    console.log('.box요소 위에 포인트가 올라갔다.')
});
document.querySelector('.box').addEventListener('mouseleave', ()=>{
    console.log('.box요소 위에 포인트가 떠났다.')
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 키보드 입력
// - keydown
// - keyup
// - keypress : 글자를 생성하는 키를 누름.
document.querySelector('.textarea').addEventListener('keydown', () => {
    console.log('キーが押された');
});
document.querySelector('.textarea').addEventListener('keypress', () => {
    console.log('文字が入力された');
});
document.querySelector('.textarea').addEventListener('keyup', () => {
    console.log('キーが離された');
});
// ----------------------------
// 입력된 키 조사
// - 키보드이벤트.key         : 눌린 버튼의 값
// - 키보드이벤트.code        : 눌린 버튼의 코드
// - 키보드이벤트.altKey      : ALT키가 눌렸나
// - 키보드이벤트.ctrlKey     :
// - 키보드이벤트.shiftKey    :
// - 키보드이벤트.metaKey     : 메타키(윈도우키)가 눌렸나
// - 키보드이벤트.repeat      : 키가 눌린 상태인가
// - 키보드이벤트.isComposing : 입력이 미확정인가
window.addEventListener('keydown', handleKeydown);

function handleKeydown(event){
    const keyCode = event.keyCode;
    // 화살표키
    if(keyCode === 39) console.log('오른쪽 키가 눌림');
    if(keyCode === 37) console.log('왼쪽 키가 눌림');
    if(keyCode === 38) console.log('위쪽 키가 눌림');
    if(keyCode === 40) console.log('아래쪽 키가 눌림');
}
// ----------------------------
// 탭이 백그라운드가 됨
// - visibilitychange
//   : 브라우저의 탭이 표시/비표시 될때 실행
document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        console.log('コンテンツが表示されました');
    return;
    }
    if (document.visibilityState === 'hidden') {
        console.log('コンテンツがバックグラウンドになりました');
    }
});
// ----------------------------
// 화면 사이즈가 변경 되었을 때
// - resize
/** ウインドウの幅を表示する要素 */
const widthLog = document.querySelector('#widthLog');
/** ウインドウの高さを表示する要素 */
const heightLog = document.querySelector('#heightLog');

// ウインドウがリサイズされる度に処理を実行する
window.addEventListener('resize', () => {
    widthLog.innerText = `${window.innerWidth}px`;
    heightLog.innerText = `${window.innerHeight}px`;
});
// ----------------------------
// 화면리사이즈 부하 경감
let resizeTimer;
window.addEventListener('resize', () => {
    if(resizeTimer != null)
        clearTimeout(resizeTimer);
    resizeTimer = setTimeout(() => {
        onResize();
    }, 1000);
});
// 리사이즈 처리
function onResize(){}
// ----------------------------
// 화면사이즈가 브레이크 포인트를 넘었을 때 처리
// - matchMedia(미디어쿼리) : 리턴 MediaQueryList
// - matchMedia(미디어쿼리).addListener(처리) 
//  : 미디어쿼리에 일치했을 때 처리를 실행함
// - matchMedia(미디어쿼리).matches
//  : 미디어쿼리에 일치하는가 어떤가

const rectAngle = document.querySelector('.rectangle');
// メディアクエリ情報
const mediaQueryList = matchMedia('(min-width: 600px)');
// メディアクエリが変更されたタイミングで処理
mediaQueryList.addListener(onMediaQueryChange);
/** メディアクエリが変更された際に実行される関数 */
function onMediaQueryChange(mediaQueryList) {
    if (mediaQueryList.matches === true) {
        rectAngle.classList.add('big-size');
        console.log('ウインドウサイズが600pxを超えました');
    } else {
        rectAngle.classList.remove('big-size');
        console.log('ウインドウサイズが600pxを下回りました');
    }
}
// ページ表示時に一度onMediaQueryChange()を実行しておく
onMediaQueryChange(mediaQueryList);
// CSS
// .rectangle {
//     background-image: linear-gradient(-135deg, #00aaff, #5500ff);
// }
// .rectangle.big-size {
//     background-image: linear-gradient(-135deg, red, #ff00a2);
// }
// .rectangle {
//     width: 100%;
//     height: calc(100% - 50px);
//     transition: 300ms ease-in-out all;
// }
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// 이벤트를 발생시킴
// - 이벤트리스너.dispatchEvent(이벤트)   : 이벤트를 발생시킴
// - new Event('이벤트명', [{detail:값}]) : 이벤트를 생성함
// 프로그램 실행시부터 1초후에 #myBox요소에 클릭 이벤트를 발생시킴
const boxElement = document.querySelector('#myBox');
boxElement.addEventListener('click', () => {
    boxElement.innerHTML = 'クリックされました';
});
setTimeout(() => {
    boxElement.dispatchEvent(new Event('click'));
}, 1000);
// click만 가능
setTimeout(() => {
    boxElement.click();
}, 1000);
// ----------------------------
// 디폴트 이벤트를 캔슬
// - 이벤트.preventDefault()

/** マウスホイールを有効にするかどうか */
let enableMouseWheel = true;
// チェックボックスをクリックしたときの処理
document.querySelector('#mouseWheelToggle')
        .addEventListener('click', (event) => {
    // チェックボックスに値が入っていたら、マウスホイールを無効化する
    enableMouseWheel = event.target.checked === false;
});

// スクロール可能な要素上でマウスホイールしたときの処理
document.querySelector('.scrollable-element')
        .addEventListener('wheel', (event) => {
    // マウスホイールが有効な場合は処理を抜ける
    if (enableMouseWheel === true) {
        return;
    }
    // マウスホイールが無効な場合はevent.preventDefault()を実行
    event.preventDefault();
});
// ----------------------------
// 드래그 앤 드롭
// - dragstart : 요소의 드래그가 시작
// - drag
// - dragend
// - dragenter : 드래그중에 마우스가 요소의 위에 올라감
// - dragover  : 드래그중에 마우스가 요소에 존재함
// - dragleave
// - drop
// - event.dataTransfer.files
//   : 드롭된 파일의 정보, 리턴 FileList오브젝트
// ----------
const character = document.querySelector('.character');

character.addEventListener('dragstart', () => {
    console.log('dragstartイベント');
});

character.addEventListener('drag', () => {
    console.log('dragイベント');
});

character.addEventListener('dragend', () => {
    console.log('dragendイベント');
});

box.addEventListener('dragenter', () => {
    console.log('dragenterイベント');
});

box.addEventListener('dragover', () => {
    console.log('dragoverイベント');
});

box.addEventListener('dragleave', () => {
    console.log('dragleaveイベント');
});

// dragoverイベントの無効化
box.addEventListener('dragover', (event) => {
    event.preventDefault();
});

box.addEventListener('drop', () => {
    console.log('dropイベント');
});
// ---------- 
// 샘플
// ファイルアップロードゾーン
const fileZone = document.querySelector('.file-zone');

// ファイルアップロードゾーンに着脱するクラス
const className = 'on';

// ドラッグした要素が重なったときの処理
fileZone.addEventListener('dragover', (event) => {
    // デフォルトの挙動を停止
    event.preventDefault();
    fileZone.classList.add(className);
});

// ドラッグした要素が離れたときの処理
fileZone.addEventListener('dragleave', () => {
    // デフォルトの挙動を停止
    event.preventDefault();
    fileZone.classList.remove(className);
});

// ドロップした時の処理
fileZone.addEventListener('drop', (event) => {
    // デフォルトの挙動を停止
    event.preventDefault();
    fileZone.classList.remove(className);

    // Fileオブジェクトを参照
    const transferdFiles = event.dataTransfer.files;

    // 画像を表示する
    displayImages(transferdFiles);
});

/** 画像の表示処理 */
function displayImages(transferdFiles) {
    // 画像ファイルの格納配列
    const imageFileList = [];

    // ファイル数
    const fileNum = transferdFiles.length;

    // ファイルが画像のもののみを配列に格納する
    for (let i = 0; i < fileNum; i++) {
        if (transferdFiles[i].type.match('image.*') === false) {
            return;
        }
        imageFileList.push(transferdFiles[i]);
    }

    // 画像表示エリアの参照
    const imagePreviewArea = document.querySelector('.image-list');

    // 各画像ファイルについて処理
    for (const imageFile of imageFileList) {
        // 画像ファイルの読み込み処理
        const fileReader = new FileReader();
        fileReader.readAsDataURL(imageFile);
        fileReader.addEventListener('load', (event) => {
            const image = new Image();
            image.src = event.target.result;
            // 表示エリアの先頭に画像ファイルを表示
            imagePreviewArea.insertBefore(image, imagePreviewArea.firstChild);
        });
    }
}
// ---------- 
// CSS
// body {
//     display: block;
//     overflow: scroll;
// }
// 
// .file-zone {
//     background-color: rgba(0, 0, 0, 0.1);
//     box-sizing: border-box;
//     display: flex;
//     justify-content: center;
//     align-items: center;
//     width: 100%;
//     height: calc(100% - 200px);
//     transition: 100ms all ease-out;
// }
// 
// .file-zone.on {
//     background-color: rgba(97, 131, 209, 0.9);
// }
// 
// .file-preview-area {
//     width: 100%;
//     min-height: 200px;
//     background-color: rgba(0, 0, 0, 0.58);
// }
// 
// .file-preview-area .image-list {
//     display: grid;
//     overflow: scroll;
//     gap: 10px;
//     grid-template-columns: repeat(3, 1fr);
//     grid-auto-rows: 200px;
// }
// 
// .file-preview-area .image-list > img {
//     width: 100%;
//     height: 100%;
//     display: block;
//     object-fit: cover;z
// }
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - HTML상의 각 요소에의 접근구조는 
//   DOM이라는 인터페이스에 정의되어 있다.
//   DOM에서는 HTML문서르 트리구조로 취급함.
// - 트리의 각 구성요소를 노드라고 함.
//   JS의 Node오브젝트로 취급.
// - HTML문서 전체는 document로 취득가능하고 
//   그 자체가 큰 Node오브젝트가된다.
// - 요소노드는 Element오브젝트로 취급함.
//   Element오브젝트는 Node오브젝트를 계승.
// ----------------------------
// - 셀렉터로 요소를 취득
// document.querySelector(셀렉터명)
// #ID명, .클래스명, :nth-child(번호)등으로 지정
// 일치하는 요소가 복수개 있을때는 최초의 요소가 반환.
const logElement = document.querySelector('#log');
logElement.innerHTML = 'こんにちは';
// ----------------------------
// - ID로 요소 취득
//   document.getElementById(ID)
//   인수로 ID만 지정가능.
// ----------------------------
// - 셀렉터명에 해당하는 요소를 한번에 취득
//   document.querySelectorAll(셀렉터명)
//   요소의 배열(Nodelist)를 반환
// 各.box要素に対してループ
document.querySelectorAll('.box').forEach((targetBox) => {
    // .box要素をクリックしたときの処理
    targetBox.addEventListener('click', () => {
        // クリックされた.box要素のテキストを表示
        alert(`${targetBox.textContent}がクリックされました`);
    });
});
// ----------------------------
// - 클래스명과 일치하는 요소 취득
//   document.getElementByClassName(클래스명)
//   요소의 배열(HTML Collection)반환
// ----------------------------
// - &lt;HTML&gt;요소와 &lt;body&gt;요소를 취득
//   document.documentElement : 루트요소(html요소)
//   document.head : head요소
//                   head내에 script태그나 link태그를 삽입등에 사용
//   document.body : body요소
const themeChangeButton =
    document.querySelector('.theme-change-button');

// テーマ変更ボタンをクリックしたときの処理
themeChangeButton.addEventListener('click', () => {
    // body要素のクラスの「theme-dark」を切り替える
    document.body.classList.toggle('theme-dark');
});
// ----------
// CSS 
// body {
//     font-size: 20px;
//     color: #2f3b4c;
//     background-color: #f9f9f9;
//     transition: 300ms all ease-out;
// }
// 
// body.theme-dark {
//     background-color: #1e1e1e;
//     color: #fff;
// }
// 
// body:before {
//     background-image: none;
// }
// 
// .theme-change-button {
//     font-size: 12px;
//     width: auto;
//     color: initial;
//     background-color: white;
//     position: fixed;
//     top: 10px;
//     right: 10px;
//     margin-bottom: 10px;
//     padding: 10px;
//     cursor: pointer;
// }
// 
// body.theme-dark .theme-change-button {
//     background-color: #1e1e1e;
//     color: #fff;
// }
// 
// h1 {
//     font-size: 26px;
//     line-height: 1.5;
//     border-bottom: 1px solid #2f3b4c;
//     text-align: left;
//     transition: 300ms border-bottom-color ease-out;
// }
// 
// body.theme-dark h1 {
//     border-bottom-color: white;
// }
// 
// main {
//     height: auto;
//     background-color: transparent;
//     border-radius: 0;
//     max-width: 900px;
// }
// ----------------------------
// - 자식요소, 전후요소, 부모요소를 취득
//   부모노드.children
//   부모노드.firstElementChild
//   부모노드.lastElementChild   : 맨마지막 자식노드
//   노드.nextFlementSibling     : 다음(동생) 노드
//   노드.previousFlementSibling : 이전(형) 노드
//   자식노드.parentNode         : 부모도느
const parentElement = document.querySelector('#parent');
console.log(parentElement.children);
// ----------------------------
// - 부모요소의 어미에 요소를 추가
//   부모노드.appendChild(자식노드)
const container = document.querySelector('.container');
const myBox = document.querySelector('#myBox');
// 3秒後に#myBox要素を.container要素の末尾に追加する
setTimeout(() => {
    container.appendChild(myBox);
}, 3000);
// ----------------------------
// - 지정요소의 앞에 요소를 추가
//   부모노드.insertBefore(자식노드, 앞요소)
const container = document.querySelector('.container');
const myBox1 = document.querySelector('#myBox1');
const myBox2 = document.querySelector('#myBox2');
const box2 = document.querySelector('#box2');
// 3秒後に#myBox1要素を.containerの先頭に追加する
setTimeout(() => {
    container.insertBefore(myBox1, container.firstElementChild);
}, 3000);
// 4秒後に#myBox2要素を#box2要素の前に追加する
setTimeout(() => {
    container.insertBefore(myBox2, box2);
}, 4000);
// ----------------------------
// - HTML코드를 요소로 삽입
//   부모요소.insertAdjacentHTML(삽입위치, 문자열)
//   : 'beforebegin' => 부모요소의 직전
//   : 'afterbegin'  => 부모요소내의 선두
//   : 'beforeend'   => 부모요소내의 말미
//   : 'afterend'    => 부모요소의 직후
const container = document.querySelector('.container');
// 挿入する.new-box要素
const newBox1 = `<div class="new-box box">.new-box要素 - 1</div>`;
const newBox2 = `<div class="new-box box">.new-box要素 - 2</div>`;
const newBox3 = `<div class="new-box box">.new-box要素 - 3</div>`;
const newBox4 = `<div class="new-box box">.new-box要素 - 4</div>`;

setTimeout(() => {
	// .container要素内先頭に.new-box要素を追加する
	container.insertAdjacentHTML('beforebegin', newBox1);
	container.insertAdjacentHTML('afterbegin', newBox2);
	container.insertAdjacentHTML('beforeend' , newBox3);
	// .container要素の直後に.new-box要素を追加する
		container.insertAdjacentHTML('afterend', newBox4);
}, 3000);
// ----------
// HTML
// &lt;!-- beforebegin --&gt;
// &lt;div class="container"&gt;
// &lt;!-- afterbegin --&gt;
//   &lt;div class="box"&gt;子要素1&lt;/div&gt;
//   &lt;div class="box"&gt;子要素2&lt;/div&gt;
//   &lt;!-- beforeend --&gt;
// &lt;/div&gt;
// &lt;!-- afterend --&gt;
// ----------------------------
// - 요소를 동적으로 삭제
//   부모노드.removeChild(자식노드)
// 3秒後に処理を行う
setTimeout(() => {
    const parentElement = document.querySelector('#parent');
    const childElement = document.querySelector('#child');
    // #child要素を取り除く
    parentElement.removeChild(childElement);
}, 3000);
// ----------------------------
// - 자기자신의 요소를 삭제
//   노드.remove()
//   : 삭제하고 싶은 요소에 대해 처리를 실시
// 3秒後に処理を行う
setTimeout(() => {
    const childElement = document.querySelector('#child');
    // #child要素を取り除く
    childElement.remove();
}, 3000);
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 요소를 생성
//   document.createElement('태그명', 옵션)
// create-modal-buttonをクリックしたときの処理
document
    .querySelector('#create-modal-button')
    .addEventListener('click', displayModalWindow);

/** モーダルウインドウを表示する */
function displayModalWindow() {
    // モーダルウインドウを生成する
    const modalElement = document.createElement('div');
    // modalクラスを付与する
    modalElement.classList.add('modal');

    // モーダルウインドウの内部要素を生成する
    const innerElement = document.createElement('div');
    innerElement.classList.add('inner');
    innerElement.innerHTML = `
        <p>モーダルウインドウの中身です</p>
        <div class="character"></div>
    `;
    // モーダルウインドウに内部要素を配置する
    modalElement.appendChild(innerElement);
    // body要素にモーダルウインドウを配置する
    document.body.appendChild(modalElement);

    // 内部要素をクリックしたらモーダルウインドウを削除する処理
    innerElement.addEventListener('click', () => {
        closeModalWindow(modalElement);
    });
}

/** モーダルウインドウを閉じる */
function closeModalWindow(modalElement) {
    document.body.removeChild(modalElement);
}
// ----------
// CSS
// @import url(../../common/css/base_photo.css);
// body {
//     background-size: cover;
//     background: url("../common/bg_nature.jpg") center;
// }
// 
// .modal {
//     width: 100%;
//     height: 100%;
//     position: absolute;
//     top: 0;
//     left: 0;
//     background-color: rgba(0, 0, 0, 0.2);
//     display: flex;
//     justify-content: center;
//     align-items: center;
// }
// 
// .modal .inner {
//     width: 100%;
//     height: 100%;
//     background-color: rgba(255, 255, 255, 0.9);
//     margin: 10px;
//     display: block;
//     width: 960px;
//     height: 540px;
//     border-radius: 5px;
//     -webkit-backdrop-filter: blur(16px);
//     box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.3);
//     box-sizing: border-box;
//     padding: 20px;
//     text-align: center;
//     background-color: rgba(255, 255, 255, 0.9);
//     max-width: 600px;
//     max-height: 400px;
//     display: flex;
//     justify-content: center;
//     align-items: center;
//     flex-direction: column;
//     color: #333;
//     font-size: 1.5rem;
//     animation: fadeInAnimation 200ms ease-out;
// }
// 
// @keyframes fadeInAnimation {
//     from {
//         opacity: 0;
//     }
//     to {
//         opacity: 1;
//     }
// }
// ----------------------------
// - 요소를 복제
//   노드.cloneNode([진위값])
//   인수에 true를 넣으면 자식노드도 복제
setTimeout(() => {
    // #myBox要素を子ノードも含めて複製
    const clonedBox = document.querySelector('#myBox').cloneNode(true);
    document.querySelector('.container').appendChild(clonedBox);
}, 3000);
// ----------------------------
// - 요소를 다른 요소로 치환
//   부모노드.replaceChild(신노드, 구노드)
//   치환된 노드를 리턴
//   신노드와 구노드를 교체
//   교체대상이 자식노드가 아닐경우 에러발생
setTimeout(() => {
    // コンテナ
    const container = document.querySelector('.container');
    // 旧ボックス要素
    const oldBox = document.querySelector('.old-box');
    // 新ボックス要素。div要素を作り、「新ボックス」というテキストノードを追加する
    const newBox = document.createElement('div');
    newBox.textContent = '新ボックス';
    // new-box, boxというCSSクラスを追加する
    newBox.classList.add('new-box', 'box');
    // 新旧ボックスを入れ替える
    container.replaceChild(newBox, oldBox);
    }, 3000);
// ----------------------------
// - 신노드를 구노드와 교체
//   구노드.replaceWith(신노드)
//   리턴값없음
setTimeout(() => {
    // 旧ボックス要素
    const oldBox = document.querySelector('.old-box');
    // 新ボックス要素。div要素を作り、「新ボックス」というテキストノードを追加する
    const newBox = document.createElement('div');
    newBox.textContent = '新ボックス';
    // new-box, boxというCSSクラスを追加する
    newBox.classList.add('new-box', 'box');
    // 新旧ボックスを入れ替える
    oldBox.replaceWith(newBox);
    }, 3000);
// ----------
// CSS
// .container {
//     display: flex;
//     border: 2px dotted #fff;
//     padding: 10px;
// }
// 
// .container .new-box {
//     border: 4px solid #d03939;
// }
// ----------------------------
// - 요소내의 텍스트 취득/치환
//   노드.textContent
//   Node오브젝트의 프로퍼티
//   텍스트내의 HTML태그는 무시됨
const weatherElement = document.querySelector('#weather');

// 3秒後に#weatherの中身を書き換える
setTimeout(() => {
    weatherElement.textContent = '気温は24℃の予想です。';
}, 3000);
// ----------------------------
// - 요소내의 HTML을 취득/변경
//   요소.innerHTML
//   Element오브젝트의 프로퍼티
//   텍스트 뿐만 아니라 태그도 변경할 경우 사용
const weatherElement = document.querySelector('#weather');

// 3秒後に#weatherの中身を書き換える
setTimeout(() => {
    weatherElement.innerHTML = '気温は<strong>-3℃</strong>の予想です。';
}, 3000);
// ----------------------------
// - 요소(자기자신포함)의 HTML을 취득/변경
//   요소.outerHTML
//   innerHTML과 달리 자신도 대상에 포함
// a要素を一括取得する
const aElementList = document.querySelectorAll('a');

// 各a要素について処理する
aElementList.forEach((element) => {
    // aタグにtarget属性が存在しなかったらreturn
    if (element.hasAttribute('target') === false) {
        return;
    }
    // target属性_blankではなかったらreturn
    if (element.getAttribute('target') !== '_blank') {
        return;
    }
    // rel属性にnoopenerを付与する
    element.setAttribute('rel', 'noopener');
});</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 155
// - 요소의 속성을 취득/변경
//   요소.getAttribute(속성명, 값)
//   요소.setAttribute(속성명)
//   요소.hasAttribute(속성명)
const anchorElem = document.querySelector("#anchor");
console.log(anchorElem.getAttribute('href'));

const imageElem = document.querySelector("#image");
imageElem.setAttribute('src','test2.jpg');
// ----------------------------
// - [ref="noopener"]
//   [target="_blank"]가 설정되어 있는 a태그로 윈도우를 열면,
//   열린 윈도우에서 window.opener를 사용해서 원래의 윈도우를 
//   조작가능해짐. 위험을 동반하기 때문에 noopener를 사용.
// a要素を一括取得する
const aElementList = document.querySelectorAll('a');

// 各a要素について処理する
aElementList.forEach((element) => {
    // aタグにtarget属性が存在しなかったらreturn
    if (element.hasAttribute('target') === false) {
        return;
    }

    // target属性_blankではなかったらreturn
    if (element.getAttribute('target') !== '_blank') {
        return;
    }

    // rel属性にnoopenerを付与する
    element.setAttribute('rel', 'noopener');
});
// ----------------------------
// - 요소의 클래스 속성의 추가/삭제
//   요소.classList.add(클래스1, 클래스2, ...)
//   요소.classList.remove(클래스1, 클래스2, ...)
//   요소.classList.contains(클래스)
const box = document.querySelector('#box');
console.log(box.classList.contains('red'));
// ----------------------------
// - 요소의 클래스의 유무를 전환(동적으로 붙였다가 뗌)
//   요소.classList.toggle(클래스)
//   클래스가 설정되어 있다면 추가, 아니면 삭제를 토글
setInterval(()=>{
    box.classList.toggle('red');
});
// ----------
// .button要素すべてについて処理をする
document.querySelectorAll('.button').forEach((button) => {
    // .button要素をクリックしたときの処理を設定する
    button.addEventListener('click', () => {
        // .button要素の次の要素のクラスを切り替える
        button.nextElementSibling.classList.toggle('show');
    });
});
// ----------
// CSS
// @import url(../../common/css/base_photo.css);
// body {
//     background-size: cover;
//     background: url('../common/bg_snow.jpg') center;
// }
// 
// h1 {
//     -webkit-text-stroke: 1px white;
//     text-stroke: 1px white;
//     font-weight: bold;
// }
// 
// main {
//     padding: 10px;
// }
// 
// .section-wrapper {
//     display: flex;
// }
// 
// section {
//     width: calc(100% / 3);
//     padding-left: 5px;
//     padding-right: 5px;
//     box-sizing: border-box;
// }
// 
// .button {
//     width: 100%;
//     text-transform: none;
//     height: 40px;
//     line-height: 40px;
//     font-size: 20px;
//     background-color: #2673a6;
// }
// 
// .button:hover {
//     background-color: #2688bc;
// }
// 
// .button:active {
//     background-color: #265c8f;
// }
// 
// .button + .content {
//     display: none;
//     font-size: 20px;
//     margin-top: 10px;
//     border: 1px solid white;
//     background: rgba(0, 0, 0, 0.7);
//     border-radius: 2px;
//     padding: 10px;
//     box-shadow: 0px 1px 1px rgba(0, 0, 0, 0.3) inset;
//     text-align: left;
//     color: white;
// }
// 
// .button + .content.show {
//     display: block;
// }
// 
// .button + .content h2 {
//     font-size: 22px;
// }
// 
// .button + .content dt {
//     margin-bottom: 10px;
// }
// 
// .button + .content dl,
// .button + .content dt,
// .button + .content dd {
//     margin: 0;
// }
// ----------------------------
// - 스타일을 변경
//   요소.style.프로퍼티명
//   CSS의 케밥케이스가 아닌 카멜케이스
//   인라인스타일도 같은 취급
//   인라인스타일이 우선순위가 높다
const information = document.querySelector('#information');

// colorプロパティーの変更
information.style.color = 'white';
// font-sizeプロパティーの変更
information.style.fontSize = '70px';
// font-weightプロパティーの変更
information.style.fontWeight = '600';

const strokeColor = '#c52b84';
// -webkit-text-strokeプロパティーの変更
information.style.webkitTextStroke = `2px ${strokeColor}`;
// text-strokeプロパティーの変更
information.style.textStroke = `2px ${strokeColor}`;
// text-shadowプロパティーの変更
information.style.textShadow = `7px 7px 0 #bf3384`;
// ----------------------------
// - 스타일을 취득
//   getComputedStyle(요소).프로퍼티명
// ----------
// HTML
// &lt;div id="box" class="red"&gt;&lt;/div&gt;
// ----------
// CSS
// #box {
//     width: 100px;
//     height: 100px;
// }
// .red {
//     background-color: #ff2bc2;
// }
// .blue {
//     background-color: #2b85ff;
// }
// ----------
const box = document.querySelector('#box');
console.log(getComputedStyle(box).width);
// width値を取得する。100px
console.log(getComputedStyle(box).backgroundColor);
// background-colorを取得する。rgb(255, 43, 194)
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 161
// - 텍스트박스 정보 취득
//   인풋요소.value
//   인풋요소는 &lt;input type"text" /&gt;
const element = document.querySelector('#myText');
const value = element.value;
console.log(value);
// ----------------------------
// - 텍스트 박스 변경감지 이벤트
//   input  : input요소의 키입력과 동시에 발생
//   change : input요소의 변경시 발생(키입력시 또는 포커스떠날때 발생)
// input要素の参照
const element = document.querySelector('#myText');
// イベントを登録
element.addEventListener('input', handleChange);

function handleChange(event) {
    // 値を取得する
    const value = event.target.value;
    // 画面に反映
    document.querySelector('.log').innerHTML = value;
}
// ----------------------------
// - 텍스트애리어의 정보 취득
//   텍스트애리어요소.value
// textareaの参照
const element = document.querySelector('#myText');
// 値を取得
const value = element.value;
console.log(value); // 結果: '今日の天気は、(改行)曇りです。'
// ----------------------------
// - 텍스트애리어 변경 감지 이벤트
//   input  : 키입력과 동시 발생
//   change : 지연후 발생
// textareaの参照
const element = document.querySelector('#myText');
// イベントを登録
element.addEventListener('input', handleChange);

function handleChange(event) {
    // 値を取得
    const value = event.target.value;

    // 改行コードを改行タグに変換
    const htmlStr = value.split('\n').join('<br />');
    document.querySelector('.log').innerHTML = htmlStr;
}
// ----------------------------
// - 체크박스 정보 취득
//   인풋요소.checked
//   선택된 상태인가 아닌가를 반환
//   &lt;input type"checkbox" /&gt;
const cbA = document.querySelector('#cbA');
const checkedA = cbA.checked; // 選択状態を確認
console.log('checkedAの値', checkedA); // 結果: false
// true로 변경
cbA.checked = true;
// ----------------------------
// - 체크박스의 변경감지 이벤트
//   change 
// チェックボックスの参照
const cb = document.querySelector('#cbA');
cb.addEventListener('change', (event) => {
    // 選択状態を確認する
    const value = event.target.checked;

    // 画面に表示する
    const log = `チェックボックスAは ${value} になりました`;
    document.querySelector('.log').innerHTML = log;
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// ----------------------------
// - 로컬파일의 정보취득
//   인풋요소.files
//   &lt;input type"file" /&gt;
//   선택된 파일의 배열을 리턴
//   change이벤트의 event.target.files프로퍼티를 통해 파일리스트 참조 가능
//   multiple속성의 지정으로 복수파일의 업로드도 가능
// input要素を参照
const element = document.querySelector('#myFile');

// ファイル選択ダイアログが選択されたら
element.addEventListener('change', (event) => {
    const target = event.target;
    // 選択されたファイルを参照
    const files = target.files;
    // 配列になってるので、0番目のファイルを参照
    const file = files[0];

    // ユーザーが選択したファイル名を表示
    alert(`${file.name}が選択されました`);
});
// ----------------------------
// - 로컬파일을 텍스트로 읽기
//   readAdText(파일)
//   FileReader오브젝트를 사용
//   파일의 읽기는 비동기로 이루어지기때문에 
//   addEventListener()메소드를 사용해서, 읽기완료를 나타내는
//   load이벤트를 감시. load이벤트 완료후에는 FileReader오브젝트의
//   result프로퍼티를 통해 데이터에 액세스가 가능해짐.
// ----------
// HTML
// &lt;input type="file" id="myFile" accept=".txt"/&gt;
// &lt;p class="log"&gt;&lt;/p&gt;
// ----------
const element = document.querySelector('#myFile');
const pEl = document.querySelector('.log');

// ファイル選択ダイアログが選択されたら
element.addEventListener('input', (event) => {
    const target = event.target;
    // 選択されたファイルを参照
    const files = target.files;
    // 配列になってるので、0番目のファイルを参照
    const file = files[0];

    // FileReaderのインスタンスを作成
    const reader = new FileReader();
    // 読み込み終わったら
    reader.addEventListener('load', () => {
        // 結果をp要素に出力する
        pEl.textContent = reader.result;
    });
    // テキストファイルとして読み込む
    reader.readAsText(file);
});
// ----------------------------
// - 로컬파일을 DataURL데이터로 읽어들임
//   readAsDataURL(파일)
//   데이터를 송신용으로 취득하고싶을때
// ----------
// HTML
// &lt;input type="file" id="myFile" accept=".png, .jpg"/&gt;
// &lt;p class="log"&gt;&lt;img /&gt;&lt;/p&gt;
// ----------
const element = document.querySelector('#myFile');
const imgEl = document.querySelector('.log img');

// ファイル選択ダイアログが選択されたら
element.addEventListener('input', (event) => {
    const target = event.target;
    // 選択されたファイルを参照
    const files = target.files;
    // 配列になってるので、0番目のファイルを参照
    const file = files[0];

    // FileReaderのインスタンスを作成
    const reader = new FileReader();
    // 読み込み終わったら
    reader.addEventListener('load', () => {
        // 画像を表示
        imgEl.src = reader.result;
    });
    // テキストファイルとして読み込む
    reader.readAsDataURL(file);
});
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript">// ----------------------------
// - 라디오버튼 정보취득
//   폼요소[키명]
// ----------
// HTML
// form要素を参照
// &lt;form id="radioGroup"&gt;
// &lt;!-- 1つ目のラジオボタン群 --&gt;
// &lt;label&gt;&lt;input type="radio" name="fruit" value="apple" checked/&gt;Apple&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="fruit" value="orange"/&gt;Orange&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="fruit" value="grape"/&gt;Grape&lt;/label&gt;
// 
// &lt;!-- 2つ目のラジオボタン群 --&gt;
// &lt;label&gt;&lt;input type="radio" name="drink" value="coke" checked/&gt;coke&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="drink" value="wine"/&gt;wine&lt;/label&gt;
// &lt;label&gt;&lt;input type="radio" name="drink" value="tea"/&gt;tea&lt;/label&gt;
// &lt;/form&gt;
// ----------
const element = document.querySelector('form#radioGroup');

// 現在の選択状態を取得
const drinkValue = element.drink.value;
const fruitValue = element.fruit.value;

console.log(`drinkの値は ${drinkValue} です`);
console.log(`fruitValueの値は ${fruitValue} です`);
// ----------------------------
// - 라디오버튼 변경감지이벤트
//   change
// form要素を参照
const element = document.querySelector('#radioGroup');
// 変更を監視
element.addEventListener('change', handleChange);

function handleChange(event) {
    // 現在の選択状態を取得
    const drinkValue = element.drink.value;
    const fruitValue = element.fruit.value;

    console.log(`drinkの値は ${drinkValue} です`);
    console.log(`fruitValueの値は ${fruitValue} です`);
}
// ----------------------------
// - 드롭다운메뉴의 정보취득
//   셀렉터요소.value
// ----------
// HTML
// &lt;select id="mySelect"&gt;
// &lt;option value="apple"&gt;apple&lt;/option&gt;
// &lt;option value="orange"&gt;orange&lt;/option&gt;
// &lt;option value="grape" selected&gt;grape&lt;/option&gt;
// &lt;/select&gt;
// &lt;p class="log"&gt;&lt;/p&gt;
// ----------
// select要素の参照
const element = document.querySelector('#mySelect');
// 値を取得
const value = element.value;
// 整形して画面に表示
const log = `選択されているのは ${value} です`;
document.querySelector('.log').innerHTML = log;
// 값 변경
element.value = 'orange';
// ----------------------------
// - 드롭다운메뉴의 변경감지이벤트
//   change
// select要素の参照
const element = document.querySelector('#mySelect');
// 変更イベントを監視
element.addEventListener('change', handleChange);

function handleChange(event) {
    // 値を取得
    const value = element.value;

    // 整形して画面に表示
    const log = `選択されているのは ${value} です`;
    document.querySelector('.log').innerHTML = log;
}
// ----------------------------
// - 슬라이더의 정보취득
//   인풋요소.value
//   &lt;input type"range" /&gt;
//   슬라이더의 현재값을 문자열로 반환
// input要素の参照
const element = document.querySelector('#myRange');
// 現在の値を取得
const value = element.value;
// 画面に表示
document.querySelector('.log').innerHTML = `現在の値は ${value} です`;
element.value = 99;
// ----------------------------
// - 슬라이더의 변경감지 이벤트
//   input  : 슬라이더를 움직이는 중에도 발생
//   change : 이동이 끝난 후에만 발생
// input要素の参照
const element = document.querySelector('#myRange');
// 変更イベントを監視
element.addEventListener('input', handleChange);
function handleChange(event) {
    // 現在の値を取得
    const value = event.target.value;
    // 画面に表示
    document.querySelector('.log').innerHTML = `現在の値は ${value} です`;
}
// ----------------------------
// - 컬러픽커
//   인풋요소.value
//   &lt;input type"color" /&gt;
//   선택한 색을 리턴(문자열)
const element = document.querySelector('#myColor');
const value = element.value;
console.log(value); // 結果: '#ff0000'
// 변경
element.value="#00ff00";
// ----------------------------
// - 컬러픽커의 변경감지 이벤트
//      change : 이동이 끝난 후에만 발생
const cbA = document.querySelector('#myColor');
cbA.addEventListener('change', (event) => {
    // 選択された色を確認する
    const value = event.target.value;
    // 画面に表示する
    const log = `選択された色が ${value} になりました`;
    const logEl = document.querySelector('.log');
    logEl.innerHTML = log;
    logEl.style.backgroundColor = value;
});     
// ----------------------------
// - 47도도부현
// JISコードに対応した都道府県の連想配列
const PREF_LIST = [
    { value:  1, name: '北海道'   },
    { value:  2, name: '青森県'   },
    { value:  3, name: '岩手県'   },
    { value:  4, name: '宮城県'   },
    { value:  5, name: '秋田県'   },
    { value:  6, name: '山形県'   },
    { value:  7, name: '福島県'   },
    { value:  8, name: '茨城県'   },
    { value:  9, name: '栃木県'   },
    { value: 10, name: '群馬県'   },
    { value: 11, name: '埼玉県'   },
    { value: 12, name: '千葉県'   },
    { value: 13, name: '東京都'   },
    { value: 14, name: '神奈川県' },
    { value: 15, name: '新潟県'   },
    { value: 16, name: '富山県'   },
    { value: 17, name: '石川県'   },
    { value: 18, name: '福井県'   },
    { value: 19, name: '山梨県'   },
    { value: 20, name: '長野県'   },
    { value: 21, name: '岐阜県'   },
    { value: 22, name: '静岡県'   },
    { value: 23, name: '愛知県'   },
    { value: 24, name: '三重県'   },
    { value: 25, name: '滋賀県'   },
    { value: 26, name: '京都府'   },
    { value: 27, name: '大阪府'   },
    { value: 28, name: '兵庫県'   },
    { value: 29, name: '奈良県'   },
    { value: 30, name: '和歌山県' },
    { value: 31, name: '鳥取県'   },
    { value: 32, name: '島根県'   },
    { value: 33, name: '岡山県'   },
    { value: 34, name: '広島県'   },
    { value: 35, name: '山口県'   },
    { value: 36, name: '徳島県'   },
    { value: 37, name: '香川県'   },
    { value: 38, name: '愛媛県'   },
    { value: 39, name: '高知県'   },
    { value: 40, name: '福岡県'   },
    { value: 41, name: '佐賀県'   },
    { value: 42, name: '長崎県'   },
    { value: 43, name: '熊本県'   },
    { value: 44, name: '大分県'   },
    { value: 45, name: '宮崎県'   },
    { value: 46, name: '鹿児島県' },
    { value: 47, name: '沖縄県'   }
];
// select要素を参照
const selectElement = document.querySelector('#pref');

// option要素の初期表示を作成
let optionString = '<option value="">選択ください</option>';

// option要素を配列から作成
PREF_LIST.forEach((item) => {
    // 都道府県ごとにvalueとnameを反映
    optionString += `<option value="${item.value}">${item.name}</option>`;
});
// option要素をselect要素内に追加
selectElement.innerHTML = optionString;

// 変更時のイベント
selectElement.addEventListener('change', (event) => {
    // 現在の値を取得
    const value = event.target.value;
    // メッセージを作成
    const message = value === '' ? '選択されていません' : `選択されているのは ${value} です`;
    // 画面に表示
    document.querySelector('.log').innerHTML = message;
});
// ----------------------------
// - 폼의 송신시의 처리
//   송신전에 처리를 추가/재확인
//   submit : 폼의 송신시의 이벤트
// form要素の参照
const formElement = document.querySelector('form');
// 送信イベントを監視
formElement.addEventListener('submit', handleSubmit);

// 送信イベント発生時
function handleSubmit(event) {
    // confirmでユーザーに確認する
    const isYes = confirm('この内容で送信していいですか？');

    // 「いいえ」を選択した場合
    if (isYes === false) {
        // 挙動をキャンセル
        event.preventDefault();
    }
}
// ----------------------------</code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>
<!-- ############################################# -->
<pre><code class="javascript"></code></pre>




</body>

</html>